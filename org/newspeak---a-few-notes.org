#+STARTUP: showall
#+STARTUP: hidestars
#+OPTIONS: H:5 num:t tags:t toc:t timestamps:t
#+LAYOUT: post
#+AUTHOR: mzimmerm
#+DATE: 2021-05-02 Sun 12:51
#+TITLE: Newspeak - a few notes
#+DESCRIPTION: Running, notes on Newspeak
#+TAGS: newspeak programming
#+CATEGORIES: category-newspeak category-blog category-programming
#+TODO: TODO IN-PROGRESS-NOW IN-PROGRESS-NOW-DONE IN-PROGRESS WAITING NOTE DONE

* This document: Introduction to Newspeak on Webassembly (Wasm)

TL;DR: The purpose of this document is to help /myself/ starting with *Newspeak version 3 (year 2021-2023, runs on Webassembly)*. Newspeak is a modern, principled platform and language: dynamic, reflective, modular.  It supports both object-oriented and functional styles.  But having reached here, you probably already know that much.  Hopefully this document can help other reader's as well.

Much of this document is collected from Newspeak sources listed below. Any errors, misunderstandings or potential misrepresentations are mine.

- The Newspeak google groups posts at https://groups.google.com/g/newspeaklanguage
- The Newspeak core site at https://newspeaklanguage.org/
- Gilad Bracha's Room 101 blog at https://gbracha.blogspot.com/
- Newspeak code on Github https://github.com/newspeaklanguage/newspeak
- Primordialsoup (the VM) code on Github https://github.com/newspeaklanguage/primordialsoup. Only needed if we want to build the VM, not necessary for Newspeak development.
  

* Changelog: last change 2023-10-03

|       Date |   | Author           |   | Change                                                                                                                                                                                                                                       |
|------------+---+------------------+---+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 2021-05-02 |   | Gilad Bracha     |   | Important clarifications and help throughout the document                                                                                                                                                                                    |
| 2021-05-04 |   | Milan Zimmermann |   | Expanded on using the Newspeak IDE, mostly in the section [[Run the online version of the Newspeak IDE.  Read docs, watch videos]]                                                                                                               |
| 2021-06-07 |   | Milan Zimmermann |   | Wording changes and clarifications in several sections                                                                                                                                                                                       |
| 2021-07-05 |   | Milan Zimmermann |   | Reworked the saving paragraph:  "lastSaved" vs "backup" in [[Saving changes in Newspeak]]                                                                                                                                                        |
| 2021-07-16 |   | Milan Zimmermann |   | Added section [[*Newspeak: An ide-driven journey leading to Hello World][Newspeak: An ide-driven journey leading to Hello World]]                                                                                                                                                                         |
| 2021-07-28 |   | Milan Zimmermann |   | Added sections [[How does Ampleforth work to create live literate Newspeak demos such as http://bracha.org/Literate/literate.html?][How does Ampleforth work to create live literate Newspeak demos such as http://bracha.org/Literate/literate.html?]] and [[How does Newspeak displays itself in DOM and HTML?][How does Newspeak displays itself in DOM and HTML?]]                                                      |
| 2021-08-10 |   | Milan Zimmermann |   | Added section [[*The Newspeak UI, *HopscotchForHTML5*: Analysing it by code browsing; Discovering *Subject*, *Model*, *Presenter*, *Fragment*; Writing *CheckedItemApp* sample App][The Newspeak UI, *HopscotchForHTML5*: Analysing it by code browsing; Discovering *Subject*, *Model*, *Presenter*, *Fragment*; Writing *CheckedItemApp* sample App]]                                                              |
| 2021-08-15 |   | Milan Zimmermann |   | Added section [[*Exemplars: Enabling liveliness everywhere][Exemplars: Enabling liveliness everywhere]]                                                                                                                                                                                      |
| 2021-08-15 |   | Milan Zimmermann |   | Added section [[*Newspeak terminology][Newspeak terminology]]                                                                                                                                                                                                           |
| 2021-10-25 |   | Milan Zimmermann |   | Added section [[* Access control and access modifiers in Newspeak][Access control and access modifiers in Newspeak]]                                                                                                                                                                                |
| 2023-10-02 |   | Milan Zimmermann |   | Added sections [[* Newspeak: Script which builds deployable vfuel files][Newspeak: Script which builds deployable vfuel files]]  [[* Ampleforth and HTML documents in Newspeak][Ampleforth and HTML documents in Newspeak]]. [[* Newspeak: The price of being principled. The hard parts: *namespace*, *manifest*, *platform*, *module*, *convention methods*, *packaging*. What are these things?][Newspeak: The price of being principled. The hard parts: *namespace*, *manifest*, *platform*, *module*, *convention methods*, *packaging*. What are these things?]]  Lots of cleanup |
|            |   |                  |   |                                                                                                                                                                                                                                              |


   
* Terminology and notation

*** Newspeak code example

First to show some code, simplified from https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterUI.ns.

The comments obscure the code but provide syntax guidence.

#+begin_src

(* This is a comment in Newspeak. It can spread across lines *)

(* Declaration of a top level class "CounterUI"
   ALONG WITH it's primary factory method (constructor in other OO) method "usingPlatform: p".
*)
class CounterUI usingPlatform: platform  = (
  (* Slot (instance methods) section is inside bars | .. |
  *)
	|
  (* "Subject" and "Presenter" are immutable slots (instance members)
  *)
	private Subject = platform hopscotch Subject.
	private Presenter = platform hopscotch Presenter.
	|
) (
  (* "Counter" class is an inner class of "CounterUI"
  *)
  public class Counter = (
    (* Counter is a mutable slot. It also defines a type Integer. Type is optional. *)
  	| public count <Integer> ::= 0. |
  ) (
  )
  (* "CounterPresenter" class is another inner class of "CounterUI",
     ALONG WITH method "onSubject: subject".
     The syntax " = Presenter onSubject: subject" makes Presenter a superclass of CounterPresenter,
     without any keywords.
   *)
  class CounterPresenter onSubject: subject = Presenter onSubject: subject () (
    (* "definition" is a method, the carret ^ means "return"
    *)
    definition = (
      (* method "definition" returns a row of widgets *)
      ^row: {
          (* "subject" in "subject count" is a member on super "Presenter". *)
          label: subject count. 
          mediumBlank. 
          button: 'increment' action: [updateGUI: [subject increment]].
          button: 'decrement' action: [updateGUI: [subject decrement]].
          button: 'reset' action: [updateGUI: [subject clear]].     
          }.
    )  
  )
  (* "CounterSubject" class is another inner class of "CounterUI". See "CounterPresenter" for comments
  *)
  public class CounterSubject onModel: model <Counter> =  Subject onModel: model () (
    createPresenter ^ = (
      ^CounterPresenter onSubject: self
    )
    public decrement = (
      model count: count - 1
    )
    public increment = (
      model count: count + 1
    )
    public count ^ <Integer> = (
      ^model count
    )
    public clear = (
      model count: 0
    )
   ) 
  ) 
#+end_src


    
*** Notation: In the text, how do we express a class name, a message (function, method) name, or a slot name?

This is a brief introduction to explain a notation used in this document.

Newspeak is a class based, and message based system.  All runtime operations are message sends (method calls).

- What do we mean by a 'message'?  Think of it as a method or function name with parameter names (method signature). 
- What do we mean by a 'message send'?  Think of it as calling (invoking) a method on an object.

In fact, we may use 'method name' and 'message name' interchangeably, although it is not quite precise.  We also may use the terms 'send a message', 'call a method' or 'invoke a method' interchangeably.

Here is the notation we want to introduce: When you see in text, something like ~Rectangle>>#initWidth: width andHeight: height~, it means: "class /Rectangle/ has a method named /initWith:andHeight/, with first parameter named /width/ and second parameter named /height/". 

If you see just ~#initWidth: width andHeight: height~ it means the same as above, but we assume the class name "Rectangle" on which the method is declared, is clear from the context, and the meaning is same as above.

The parameter names are not part of the signature (a unique method name), and are often not included in the method signature.  If the parameter names are not included, we shorten the signature to ~Rectangle>>#initWidth:andHeight:~ or ~#initWidth:andHeight:~.

Examples of this notation:

- ~Rectangle>>#initWidth width :andHeight: height~
- ~Rectangle>>#initWidth:andHeight:~
- ~#initWidth:andHeight:~
- ~#main: platform args: args~ 
- ~#usingPlatform: platform~
- ~Number>>squeared~ - in this example, note there is not colon ~:~ at the end of the signature. The message ~squared~ is unary (does not accept a parameter) acts only on the Number instance, returning the squared value of the ~Number~ instance.
- ~squared~ - as above, but ~Number~ is clear from the context in the text.



*** Newspeak terminology

Newspeak is different. Below we list terms that are generally used in documentation and in this document.  This section sort of jumps ahead of the gradual introduction to Newspeak, but should help when reading the text.

- *Top level class* : Class that appears on the top level class list in the IDE. Top level class has no enclosing class. 
- *Module Declaration* : Source code of a top level class.
- *Module Definition* or *Module class* : The class object of a top level class.  This is the object that has the /primary factory method/ defined below.
- *Module* :   Instance of a top level class. When talking about API, we sometimes use the term /module/ instead of /module declaration/. 
- *Slot* :  Equivalent of an instance variable (instance slot) or a local variable (local slot) in other languages. In Newspeak, everything is a message send, so a slot is a getter (immutable slot) or also a setter (mutable slot). Example:  ~|mySlot =:: 1|~ declares a mutable slot,  ~|mySlot = 1|~ declares an immutable slot. See the local and instance slot sections below for more details.
- *Instance slot declaration* : Name on the left of an expression between the bars ~| |~ located inside the *primary factory method*.  Instance slot is an *equivalent* of a member variable in other OO languages, and it's scope is the instance, with some small but important context differences due to class nesting. The slot name can have the symbol ~=~, ~=::~ or nothing to the right of the slot name.  ~|mySlot =:: 1|~ is a declaration of a mutable slot named ~mySlot~.  ~|mySlot = 1|~ is a declaration of an immutable slot named ~mySlot~ (in either example, initialized to ~1~ at the point of the declaration).  ~|mySlot|~  is a declaration of an immutable slot, which can be initialized later in code. The ~::~ expresses mutability in Newspeak. Read it as 'the name on the left is set to the value on the right'.
- *Local slot declaration* : Similar to /instance slot declaration/, except the local slot is declared in (and its scope is) the body of an instance method or a factory method (but NOT in the primary factory method body, that is reserved for *instance slots*). Equivalent of a local variable in other languages. 
- *Primary factory method* : The method that allows to accept parameters (capabilities), declare instance slots, and produce an instance of a class.  In practical terms, looking at code, the primary factory method is the method starting on the same line where the class code starts. Also, the /primary factory method/ is the only place in which we can declare instance slots.  The 'class factory object' in code, is referenced using the uppercase class name. An example of a primary factory method named ~#usingPlatform: p andA1: A1~ on class ~A2~:
    #+begin_example
      (* The string "usingPlatform: andA1:" is the primary factory method signature.
         The primary factory method is declared as follows:
      *)
      class A2 usingPlatform: p andA1: A1 =
        (
          (* Section 1. Primary factory method slots and body.*)
          |slots|
          (* .. instantiation code here .. *)
        )
    #+end_example
    - Implementation detail: The 'primary factory method' is in fact a method on a "special" object, not a method on the class.  The class declaration above creates a "special" object termed 'class factory object' that provides the means of producing instances of the class. The 'class factory object' supports at least one message that produces new instances (of the class). This message on the 'class factory object' is the 'primary factory method'.  But for practical purposes, we can think of the 'primary factory method' as a class method that produces instances of a class.
      - So code such as ~AMyApp packageUsing: manifest~ invokes the factory method ~#packageUsing~ on the 'class factory object' ALSO named ~AMyApp~, and it produces an instance of the ~class AMyApp~.  We can use use it to store the produced instance in code such as ~myAppInstance:: AMyApp packageUsing: manifest~. 
- *Factory method* : The method that produces an instance but cannot declare instance slots.  Note the distinction from /primary factory method/ above.  In practical terms, looking at code, /factory method/ is the method in the class code section after the ":" - in this example, in section 3.  Below is an example of /factory method/ named ~#factoryMethod1~ on class ~A2~:  
    #+begin_example
      class A2 usingPlatform: p andA1: A1 =
        (
          (* Section 1. Primary factory method slots and body. *)
          |slots|
          (* .. instantiation code here .. *)
        )
        (
          (* Section 2. instance methods and nested classes *)
        )
        :
        (
          (* Section 3. factory methods *)
          factoryMethod1 = ( (* Code returning instance, but cannot declare slots. *) )
        )
    #+end_example 
- *Class factory object* : The user accessible object that represents the class in the language. This object provides the factory methods (both primary factory methods and factory methods). From user's perspective, the *class factory object*, *class object*, and *class* are all informal names for the same thing!  This is slightly different for the language implementor, for whom the class factory object is distinct from the class - see the section below.
  

Note on the terms *factory method*, *primary factory method* and *constructor*.  
  - Readers familiar with object oriented languages can think of the term "factory method" as "constructor". (The short term "factory" is sometimes used instead of the term "factory method"). 
  - The Newspeak term "primary factory method" may not exist in other OO languages, but it is very important in Newspeak, as it is the only method that can declare instance slots.  A Newspeak class must have exactly one "primary factory method".
  - While the role of a "primary factory method" in Newspeak is similar to "constructor", Newspeak intentionally chooses to avoid the name "constructor" for several reasons.  Perhaps the core reason is that "constructor" suggests constructing (creating) something, which is not always a correct connotation.  For example, a constructor may return an existing object from a cache, for which the name is misleading.  Hence, Newspeak uses the term *factory method* (*factory* in brief) instead of the term *constructor*. 


Incomplete resources for terminology:
  - https://groups.google.com/g/newspeaklanguage/c/0LMOc5LaxwU/m/IYJe4hVQAQAJ
  - https://groups.google.com/g/newspeaklanguage/c/0LMOc5LaxwU/m/lYUM43dsAQAJ

**** Terminology differences for language user vs. language implementor 

 In a language implementation, there is likely a representation of the *class*, that probably points to a mixin and a superclass. For the language implementor, this representation of *class* is called a *class factory object*. This object is distinct, from the _user accessible object that represents the *class* in the language_. So the term *class factory object* is used to distinguish it from the *class* itself, but that is a distinction for the implementor, not the user.

Informally, when speaking from the language user's perspective, we often refer to this user accessible object as the *class*, or the *class object*, or the *class factory object* (all names for the same thing). 

So I suppose when talking about the language, we should use the term "class" or perhaps "class object" for this thing.


**** Furter notes on terminology

 See the Newspeak specs, section 6.4. Also see 3.5 which discusses methods and what defines them (mixins) as opposed to their declarations (again, essentially source).


* Perhaps the best high level summary of Newspeak

For me it is this article's summary is perhaps the best high level summary of Newspeak:  [[https://bracha.org/newspeak-modules.pdf][Modules as Objects in Newspeak]]. Let me paste it here removing references that would not make sense in another context:

/Like Self, all computation - even an object's own access to its internal structure  is performed by invoking methods on objects. Newspeak is class-based. Classes can be nested arbitrarily. Since all names denote method invocations, all classes are virtual; in particular, superclasses are virtual, so all classes act as mixins. Unlike its predecessors, there is no static state in Newspeak, nor is there a global namespace. Modularity in Newspeak is based exclusively on class nesting. There are no separate modularity constructs such as packages. Top level classes act as module definitions, which are independent, immutable, self-contained parametric namespaces. They can be instantiated into modules which may be stateful and mutually recursive./

This is a beautiful summary. But it is also not easy to "visualize" how is this tranfered to practice in Newspeak.

This document is both a personal experience of learning Newspeak, an an attempt of making sense of the practical ways the above text means for a Newspeak user.


* Newspeak: A quickstart.  Explore the IDE.  Then develop CounterApp, package it and deploy it

TL;DR: This quickstart section provides an incremental introduction to Newspeak.  First, we introduce the Newspeak online IDE, then we build and deploy a sample Newspeak app called ~CounterApp~.  A spoiler: we can look ahead and run the app we will be building - the ~CounterApp~ - online at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel. 


** Run the online version of the Newspeak IDE.  Read docs, watch videos

TL;DR: This section introduces the online version of Newspeak IDE, and how to use it.

This is a brief section.  Starting with Newspeak is easy.  We just point the browser to https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel.

In more detail, let us try the following:

- Action: In a new browser tab, open the Newspeak online IDE at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- Result: The Newspeak IDE opens, similar to
  [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
- Action: To edit source code: Click the "Newspeak Source" link
  [[file:img/newspeak---a-few-notes.org-go-to-newspeak-source.png]]
- Result: A new page opens, showing Newspeak classes, similar to
  [[file:img/newspeak---a-few-notes.org-newspeak-source.png]]
- Note: The blue links are classes.  To view, or change them, click the class link 
- Action: Click the "+" beside the "Root" to add a class.
- Result: A class editor opens, with a template of a new class declaration (class source code; the IDE uses the term class definition).  At first, let's just create a dummy class by editing the template
  [[file:img/newspeak---a-few-notes.org-newspeak-source-defining-a-new-class.png]]
- Action: Click the checkbox on the top right [[file:img/newspeak---a-few-notes.org-accept-image.png]] to "Accept" the new class declaration.  Note: Clicking the "Accept" button is important.  If you make any code changes, or workspace code changes, do not forget to click "Accept", otherwise your changes will be lost immediately after moving away from the source editing page.  See the discussions in [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]].

- Result: The class now appears in the list of classes (may need to scroll down, classes are sorted alphabetically)
  [[file:img/newspeak---a-few-notes.org-my-new-class-now-added.png]]
- Action: Return back to the main page by pressing the browser "Back" button, to get back to
  [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
- To run some Newspeak expressions, click the "Workspaces" link
  [[file:img/newspeak---a-few-notes.org-go-to-workspaces.png]]
  - Result: A new page opens, similar to
    [[file:img/newspeak---a-few-notes.org-workspaces.png]]
- To run some simple one-liner code, type for example "1+2" into the text field, and press keyboard *Shift + ENTER*.  This will evaluate the expression and print a result "3"
  - Result: expression "1+2" was evaluated to "3"
    [[file:img/newspeak---a-few-notes.org-workspaces-expression.png]]
- To run multi-line Newspeak code, type the code line by line.  Press keyboard *ENTER* to open new lines.  When ready to run the code, *highlight all lines, then press keyboard Shift + ENTER* to run the code.  Another term for running code like this, is "evaluating all highlighted lines".  The image below shows the Workspace after the *Shift + ENTER* was pressed, showing the evaluated code, and the result of the evaluated code: ~2~.
      [[file:img/newspeak---a-few-notes.org-workspaces-multiline-expression.png]]
  - The image above uses a white-mode image, as the dark-mode pages do not show highlight too well.
  - When running multi-line code, we can paste it from outside, instead of typing it.
- To save our changes "now", click the diskette "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]].  The changes are saved in the browser local storage.  See Notes below for discussion on the details.
  
Notes:

- We are now using Newspeak, in its full power.
- The browser tab opened on https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel IS the Newspeak live IDE.
- Everything we do in the IDE is alive, changes and actions have immediate responses in the running system.


Saving your changes:

*Any changes we make (for example: we add a class, we change a class, evaluate something in the workspace) are stored in the browser local storage in two entries: "lastSaved" and "backup".* The "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]] saves the changes in local storage under the key "backup", while the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], saves the changes under the key "lastSaved".  See [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]] for details.
  
Documentation:

- Some selected documentation sites and videos:
  - The core site for all Newspeak is https://newspeaklanguage.org/.  It has *papers, talks, demos, and repo links.*
  - A great start would be the last 2 videos on the "talks" tab https://newspeaklanguage.org/talks.html
    - Live IDEs in the Web Browser: What's Holding Us Back - https://youtu.be/CJX_6B24Hho
    - What is a Live Programming System? - https://youtu.be/VUfZ1sL4aps

Summary:

- This section showed the simplest way of starting with Newspeak - we just point the browser to https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and start using it.
  - In "Workspaces", we can experiment with Newspeak expressions, or snippets of code.
  - In "Newspeak Source", we can experiment with adding Newspeak classes, or creating a Newspeak app, such as the app created in the next section.

Potential "gotchas":

- If you make code changes, do not forget to click the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]].  Otherwise your changes will be lost immediately after moving away from the source editing page.
- What is the difference between The "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], and the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]]? 
  - The "Accept" button is needed to save your changes beyond moving away from the editor.  For example, if you make a change to a class method, and do not click "Accept", your changes will be lost after pressing the browser "Back" button, browser "Reload" - generally any state changes.
    
Next:

In the next section we show how to create a simple ~CounterApp~ in Newspeak.


** Code, run, and debug the CounterApp in Newspeak

TL;DR: This section describes coding, running, and deploying a Newspeak Application with UI. We name the Application ~CounterApp~. ~CounterApp~ is also the name of one of it's top level classes.  To concentrate on the IDE handling applications, we use pre-existing code for the ~CounterApp~, provided in  https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterUI.ns, and https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterApp.ns.  To skip the coding details above, we can download, then [[compile-files]["Compile file(s)"]] to load the fully finished code from there; the loaded classes will appear in the IDE. Then we can browse, run, or deploy the Application.  It's running UI looks like this: [[file:img/newspeak---a-few-notes.org-counter-app-running.png]]

Prerequisites:

- We will simply borrow the code without talking about it until later.  Download the files ~CounterApp.ns~ and ~CounterUI.ns~ from Github to the local filesystem.  To do that, just click https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterUI.ns, then https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterApp.ns, then right-click and select "Save as..." to save each file.
  - Either way, note the location of the two files.

 
Notes: 

- We deploy the ~CounterApp~, in this section using the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- However, a local Newspeak webserver could be used instead.
  - If we wanted to deploy the ~CounterApp~ in "production", we would need a local Newspeak server - because there is no way to deploy the app to the online Newspeak site.
  - Deployment of the  ~CounterApp~ to "production" requires our "own" Newspeak, such as the local Newspeak webserver.  See [[Download, install, and start a local Newspeak webserver]] for how to install Newspeak locally.
- We may ask, "what is an Application in Newspeak"? In a nutshell, an "Application" is an instance of a class - obviously.  But which class, and what does the class need, to be able to "live" or "run" inside a Newspeak IDE or Newspeak runtime? Read the steps below for details.


*** Steps: To create and run the ~CounterApp~ (from existing code that we borrowed from Github), follow the Action/Result steps below:

- Action: In a new browser tab, open the online Newspeak IDE at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- Result: The Newspeak IDE opens, similar to [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
  - Note: The "Did you know" section is a ever-changing hint system
- Action: Click "Newspeak Source" in [[file:img/newspeak---a-few-notes.org-go-to-newspeak-source.png]] 
- Result: A new page opens, showing Newspeak classes, similar to [[file:img/newspeak---a-few-notes.org-newspeak-source.png]]
  - Note on the result: In the result, you should NOT see classes named ~CounterApp~ or ~CounterUI~.  If you do, you have most likely run through this tutorial before, and the classes are already in your browser local storage.  To clean any local changes saved locally for the online Newspeak, you can clean them in the browser local storage, or click the 3-dot on the class line, and Remove the class.
- *Motivation for the next action: We want to build the sample app ~CounterApp~.  We choose to build it simply by downloading and compiling existing source files in the Newspeak github repo.*
- Action:  <<compile-files>> In the top right of the page (in the same line where we see "Root +") [[file:img/newspeak---a-few-notes.org-3-vertical-dots.png]], click the *vertical 3-dot* button on the far right.
- Result: A popup  [[file:img/newspeak---a-few-notes.org-compile-files.png]] shows

- Action: Click "Compile File(s)".  This will ask us to select files stored on disk, and compile them.
- Result: OS file browser opens, and ask us to select files in the operating system file browser. 
- Action: Navigate to the directory where we checked out the Newspeak github repo, OR where we saved the source for the ~.ns~ files (see Prerequisites of this section).  Select ~CounterApp.ns~ and ~CounterUI.ns~
- Result: *The classes from the selected ~.ns~ files compile, and show in your IDE.* In your class list (the list under Root +), you should now see a section similar to this [[file:img/newspeak---a-few-notes.org-counter-classes.png]]
  - Note 1: We have loaded the code of the  ~CounterApp.ns~ and
    ~CounterUI.ns~ classes into Newspeak by running "Compile
    file".  Alternatively, we could have added the classes through the IDE by
    clicking the "Root-+" button
    [[file:img/newspeak---a-few-notes.org-root-plus-button.png]] and typing or pasting the code in.
    Instead, we choose to load pre-existing files at the moment to concentrate on the process, not the code.   
  - Note 2: click the ~CounterApp~ or ~CounterUI~ link.  This shows the corresponding class. 
  - Note 3: The ~CounterApp~ shows links to ~[deploy] [configuration] [run] [debug]~.  Why do only the "app" classes such as ~CounterApp~ (and no other classes) show the ~[deploy] [configuration] [run] [debug]~ links in the Newspeak IDE? The IDE decides to show those links based on the presence of a convention method ~#packageUsing: manifest~.  See [[*Newspeak modules API summary][Newspeak modules API summary]] for what makes a module an App, a Library, or a TestConfiguration, and how the IDE handles the API.
- Action: To save the classes we added, (~CounterApp~ or ~CounterUI~) in the browser local storage explicitly "now", click the diskette "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]]
- Result: The two classes are stored in the browser local storage.  To read more about details of the browser local storage, see [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]].
- Action: click the *[run]* link beside the  ~CounterApp~.  This runs the code in the app (specifically, the ~CounterUI~ code). 
- Result: The counter app opens and runs in the same browser tab; it should look like this:  [[file:img/newspeak---a-few-notes.org-counter-app-running.png]] The code presents a counter (integer), and 3 buttons, which actions are to "increment", "decrement" and "reset" the counter. 
- Action: click "increment"
- Result: counter increments by one.
- Note: We can click [debug] instead of [run] and a debugger will open.

Summary: 

- We have shown how to code, run, and debug, a Newspeak app ~CounterApp~ in "development mode", inside the online Newspeak IDE. 
- Newspeak online is similar to (but we dare say superior to) running, in "development mode", a Java, Android or Flutter application in IntelliJ, Eclipse, Visual Studio, Atom, Emacs, vi, or any IDE.
- Your changes are always stored, as long as you "Accept".  See [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]] for saving changes details.

Next: 

- Let's pretend the CounterApp is useful, usable, and production ready.
- How do we deploy it for us to use it as a browser app "in production mode"? Read the [[Deploy CounterApp as standalone app into local Newspeak webserver][Chapter Deploy CounterApp as standalone app into local Newspeak webserver]] section.


** Download, install, and start a local Newspeak webserver

TL;DR: This section describes:

- How to download, install, and start a *local Newspeak webserver*.

- How opening a browser tab at http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel runs the local version of the Newspeak IDE (reaching the just installed local Newspeak webserver).

Prerequisites: 

- Python is installed on your system.  This is needed for the ~serve.sh~ script to run an HTTP server. 

Notes: 

- You can use a server of your choice instead of the Python server needed by ~serve.sh~.  Just place all the files downloaded in the sections below to your server's serving directory.
- You can potentially skip this section.  However, if you want to deploy a Newspeak app such as the ~CounterApp~, this section is needed.  

*Action steps to download, install, and start using a local Newspeak webserver*

- First, you may want to review the Newspeak downloads page at https://newspeaklanguage.org/downloads.html, in particular the *For all platforms* link.

- Next, to install and start a local Newspeak webserver, you can 

  - Either download and unzip the file *servable.zip* from the link above (https://github.com/newspeaklanguage/newspeaklanguage.github.io/raw/master/servable.zip) to any directory, then start the Newspeak server by running ~serve.sh~ from the extracted file.

  - Or run the following commands from the command line (this assumes your directory from which Newspeak is served is ~$HOME/software/newspeak/my-serve-http~:
    #+begin_src shell :noeval
      MY_SERVE_NEWSPEAK=$HOME/software/newspeak/my-serve-http
      mkdir --parent $MY_SERVE_NEWSPEAK || echo Unable to create directory $MY_SERVE_NEWSPEAK 
      cd $MY_SERVE_NEWSPEAK
      curl --location https://github.com/newspeaklanguage/newspeaklanguage.github.io/raw/master/servable.zip --output $MY_SERVE_NEWSPEAK/servable.zip
      unzip -o servable.zip
      
      # The directory just above "servable" must be the directory
      # where we saved the zip file, see above.
  
      cd servable
      # Make serve.sh executable, and start the Newspeak local server.
      chmod u+x serve.sh
      ./serve.sh
    #+end_src

- Expected Result: "serving at port 8080".  Note: In *servable.zip* there is a file ~server.py~, which defines the Newspeak server port.  The port is set to 8080.  Edit the file and change port if needed.


To use the local Newspeak webserver, navigate browser to http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel.  This should open the locally hosted Newspeak IDE, started using the ~./serve.sh~ command. 

Your browser should show a page similar to 
  [[file:img/newspeak---a-few-notes.org-local-ide.png]]

Note: The use of the local version is the same as the use of the online version.  We can now start editing Newspeak code by clicking on the "Newspeak Source" link.

Summary: 

- In this section we installed the local Newspeak webserver, and started using the served Newspeak IDE.

- The installation method described here is the [[install-method-2][Installation method 2 (local Newspeak webserver)]]   

Next: [[*Deploy CounterApp as standalone app into local Newspeak webserver][Chapter Deploy ~CounterApp~ as standalone app into local Newspeak webserver]]


** Deploy CounterApp as standalone app into local Newspeak webserver

TL;DR: This section describes 

- How to create and deploy the ~CounterApp~ into the local version of Newspeak.
- That the deployment is achieved by creating a deployable file, ~CounterApp.vfuel~, in the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and placing the created ~CounterApp.vfuel~ in the running local Newspeak webserver.
- How to run the ~CounterApp~ from the local Newspeak webserver, by accessing the  ~CounterApp.vfuel~ from the local HTTP server.

Prerequisites: 

1.  We have followed the online section [[* Code, run, and debug the CounterApp in Newspeak]].  In that section, we have downloaded (from Newspeak Github) and compiled two classes ~CounterApp~ and ~CounterUI~ *while attached to the online Newspeak*.
   - This statement requires a "fine point" explanation. 
     - In the earlier section  [[* Code, run, and debug the CounterApp in Newspeak]], the two classes, ~CounterApp~ and ~CounterUI~, were saved to the browser local storage. 
     - In this current section, we re-attach to online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel. 
     - As explained in [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]], the changes we made in the online version are still stored locally in the browser local storage. 
     - So, when we re-attach to online Newspeak in this section, the classes ~CounterApp~ and ~CounterUI~ are still available.  We use them to "create the CounterApp" (by saving it "as victory fuel" - that is, as file ~CounterApp.vfuel~) which is the app. 
     - This app - the  file ~CounterApp.vfuel~ - can then be copied to the serving directory of local Newspeak, and can be opened from there.
2.  We have installed the local version of Newspeak by following the section [[*Download, install, and start a local Newspeak webserver]].*


Notes: 

- We will create the deployable file, ~CounterApp.vfuel~ using the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel 
- *However, apps can NOT be deployed to the online version, since that would require write access to the newspeak web site.  We can do the coding and create the deployable .vfuel file online (as described above), but the actual deployment and running of the standalone app has to be done in a Newspeak webserver we control.  We will show how to create a standalone local Newspeak webserver just a bit later.*
- We will deploy the deployable file with the standalone ~CounterApp.vfuel~, into the local Newspeak webserver as  http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel. (this link will only work when we finish all steps in this section)

One more "fine point" note:

- This flipping between the online Newspeak and local Newspeak could be confusing.  We could have started by downloading Newspeak locally, and follow the whole tutorial in local Newspeak.  However, we thought that may discourage some people who want to "take the shortest path", and start online.


*Steps: <<make-deployment-file>> Now we have introduced the context, we start the core of this section: We create the deployable file, ~CounterApp.vfuel~ and deploy it to the local Newspeak, by following the Action/Result steps below:*

- Action: Navigate to the online version of Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and click the "Newspeak Source"
- Result: Under "Root" you should see an alphabetically organized list of classes, similar to [[file:img/newspeak---a-few-notes.org-newspeak-source.png]], 
  - Note: If you followed the online section [[* Code, run, and debug the CounterApp in Newspeak]], there should be ~CounterApp~ and ~CounterUI~ classes in the alphabetic list.
- Action: In the class list, find the ~CounterApp~, and click the [deploy] to the right of the "CounterApp"
- Result: a popup showing deployment options, starting with ~asVictoryFuel~: [[file:img/newspeak---a-few-notes.org-click-deploy-on-counter-app.png]]
- Action: Select ~asVictoryFuelWithMirrors~.  We choose the option 'asVictoryFuelWithMirrors' if our app uses the GUI (there's some mirror dependency in the UI) and 'asVictoryFuel' otherwise.
- Result: After a long wait, a file named ~CounterApp.vfuel~ is created, and asked to be saved.
- Action: Save the file ~CounterApp.vfuel~ on our disk to the directory where local Newspeak was deployed - for example ~$HOME/software/newspeak/my-serve-http/servable~
- Result: *The counter app is now deployed to the local Newspeak webserver!*


To prove the counter app is now deployed to the local Newspeak webserver, do the following:

- Action: Open a new browser tab, and navigate to the just saved application  ~CounterApp.vfuel~ in the local Newspeak webserver as http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel
- Result: In the new tab, you should see the "locally deployed" ~CounterApp~ is now running
  [[file:img/newspeak---a-few-notes.org-counter-app-local-run.png]]

Summary: 

- In this section, using the online Newspeak, we built our "Newspeak production deployable" file ~CounterApp.vfuel~, and deployed it to the local Newspeak version at http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel.

Next: This is the end of coding, building and running the ~CounterApp~


* Newspeak: An ide-driven journey leading to Hello World

** Motivation of writing this journey

On this journey, I would like to walk back and capture some of my surprises, gotchas, but also amazement of simplicity during a journey of my first week (stretched over 2 months) starting with Newspeak.  But hopefully I manage to organize this journey into a somewhat streamlined story.  Actually "the first week" is not completely correct.  I did first discover Newspeak long time ago, almost when it started, read available articles back then, and covered the syntax which helped.  But I did not have time back then to get my hands on it properly.

Most learning, and often "unlearning" for me was the discovery different the Newspeak platform is, compared to most mainstream platforms, such as Java, Python, C++, even Smalltalk (with Smalltalk, Newspeak shares syntax and extreme late boundedness).

At this moment I should give readers some links to jump off here and do this alone.  If you found this, you probably already searched to learn about Newspeak.  But I hope, if you get back here after googling and reading the links, the rest of this text may still be helpful :) ..  so, some selected links:

- First of all, the home of the Newspeak language https://newspeaklanguage.org/ has links to all documentation, videos, installers and more.
- Second, to run Newspeak online, navigate to  https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel.
- Next, if I was to:
  - recommend selected few documents, it could be
    - [[http://bracha.org/newspeak.pdf][The Newspeak programming platform]], an older document, briefly introduces both the syntax, and the core principles of Newspeak.
    - [[https://newspeaklanguage.org/samples/Literate/Literate.html][Newspeak by example]]  which is a live document, introduces the syntax of Newspeak, sort of a Jupyter notebook for Newspeak: reader can type and evaluate Newspeak expression in a web page, interleaved with document text.
  - recommend a hands-on Newspeak introduction, it could be
    - Either use (still relevant where not Squeak dependent) [[https://newspeaklanguage.org/ns101/ns101.html][Newspeak on Squeak - A Guide for the Perplexed]]
    - Or follow the hands-on section [[*Newspeak: A quickstart.  Explore the IDE.  Then develop CounterApp, package it and deploy it][Newspeak: A quickstart.  Explore the IDE.  Then develop CounterApp, package it and deploy it]].

Getting back to my first week journey; it is unfair to hikers, as my journey was at times, that of a wanderer almost lost in a forest; haphazardly reading all I can get my hands on, trying code snippets things in the IDE, re-tracing running and deploying the existing ~CounterApp~, and overall, taking one step forward, then two steps back as the step forward discovered more unknowns.

Some concrete talk please!

OK.  But first one more paragraph of meta-talk.  Just a heads up, I will start using the word *platform* a lot.  Let me try explain what I mean by /platform/ or /language platform/.  Often we think of learning a "computer language" as learning its syntax.  But syntax is only a small part of being able to be productive in the language.  There are all those things around the syntax, that are needed to be comfortable and productive with a "computer language": How is it installed, how we create projects to start writing a useful program, the core idioms, how to use programs written by other people in that language (the libraries), how the programs we write are packaged and send to users to use (building, packaging and installing apps), how to secure the resulting program.  It is all these things listed in the long sentence that I mean by the "language platform" or "platform". 

Newspeak syntax is not a major obstacle.  Well, it is quite different too, even for someone knowing Smalltalk, which Newspeak shares syntax with.  But one can get syntax basics from the links above.  Also, Newspeak syntax is a bit like speaking English.  Just different from the mainstream.  I will not address syntax too much here.

Newspeak is a principled language and *platform* (in the sense described).  Gilad Bracha and collaborating authors describe several principles (adherence to which removes many mainstream platforms' weaknesses).  Those principles are described in the above linked paper [[http://bracha.org/newspeak.pdf][The Newspeak programming platform]] and other documents.

As this section title states, Newspeak is different. *Being different is not for fun.  Newspeak must be different to implement its core principles*

- Dynamicity
- Modularity (including how dependencies are provided)
- Classes can be nested (nesting provides the core of modularity)
- Security
- Reflectivity
- intentional lack of static state
- support for both object-oriented and functional styles
- the only operation is a message send

  
I will add one multi-item principle.
- Everything in the Newspeak language is an object (instance of a class). 
  - Most(?) mainstream languages use separate concepts for packages, apps, modules, namespaces, classes.  They also use the filesystem a lot.
  - All concepts in the item above exist in Newspeak, but they are all implemented by objects.

But, given a Newspeak object, how do we know it is a *module, a library, or an application*? The distinction between them is determined by:

1) the object's position in the class nesting and
2) presence of certain API (convention methods such as ~#main:platform args:args~. This is discussed in [[*Newspeak modules API summary][Newspeak modules API summary]] and other sections leading to it.

Given a Newspeak object, how does it acquire it's dependencies (objects it depends on to be functional)? This is one core point discussed at length in this text. See [[*Dependencies and modularity: Important but hard to "get" at first][Dependencies and modularity: Important but hard to "get" at first]] the links therein, and sections afer.

"Being different" does came at a steep initial learning curve (for me at least). 



** Dependencies and modularity: Important but hard to "get" at first

This section is only a quick "look ahead summary" to provide more motivation and contex for the rest of the parent chapter.

Due to Newspeak's modularity, the process of bringing dependencies into a Newspeak program is different from mainstream language platforms. Because of it, large parts of this text deals with the topic of dependencies. 

As a look ahead summary we can say that 
- Every computation in Newspeak starts at an instance of a top level class. Instances of top level classes are called modules.
- Modules can be packaged and distributed.
- Dependencies are also modules (which some distributed module depends on).
- The ~manifest~ and ~platform~ objects are the vehicles of bringing dependencies to objects at runtime by passing them to modules' "convention methods".
- From modules, the dependencies are also available to the distributed module's nested classes and objects. 

Later sections decribe the process of bringing dependencies into a Newspeak programs. We use the /manifest/ passed to module APIs, from the manifest, dependency classes are stored on slots ("imported"), later picked up from slots when needed to instantiate.  [[*Modules: Application, Library, TestConfiguration, General][Modules: Application, Library, TestConfiguration, General]], the recipy section [[*Newspeak recipy for writing modules API][Newspeak recipy for writing modules API]], and the [[*Hello World in Newspeak - several versions][Hello World in Newspeak - several versions]] and other sections are largely about bringing dependencies into modules and objects.


** Starting the journey

To do anything useful with Newspeak, we have to use the IDE.  There is no command line per se (there is, but it is inside the IDE.  It is called the Workspace).  So let us open the Newspeak IDE to look around.  Navigate to  https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel.

We see something like

[[file:img/newspeak---a-few-notes.org-local-ide.png]]

Click the "Newspeak Source" link.

Each paragraph below is devoted to a feature that was surprising (to me) or unusual in some way. 


** Namespaces and Modules

*** Top level classes in the IDE

Top level classes in the IDE are crucial because their instances are Newspeak modules. A Module can play a role of an Application or Library.

I the IDE, click on the "Newspeak Source" button. We see the word *Root* on top left, and below, a list of class names. 

[[file:img/newspeak---a-few-notes.org-ide-full-page-classes-collapsed.png]]

First: what is the "Root" on the top? According to documentation, this is the IDE's top namespace - /Root/ is the name of the  namespace.

In Newspeak, each class in the screenshot above (AccessModifierTesting, and below) is called a *top level class*, and it belongs to the /Root namespace of the IDE/.  Each /instance of a top level class/ is referred to as a *module*, see [[*Discussion of Modules][Discussion of Modules]].  


*** Discussion of Modules

In software in general, /Modules/ are related to namespaces in a way that we cannot precisely define here.  See [[*Discussion of Namespaces][Discussion of Namespaces]] as well.  But we can say this about modules: Modules are meant to be artifacts providing some useful non trivial functionality, without needing any help - apart from the help of "dependencies" - that is, help of other modules intended to provide some "sub functionality".  There must be a way to package and distribute modules.

In Newspeak, modularity is one of the key concepts. Modules, the key constructs of modularity, are based on class nesting.

Lets again quote from [[https://bracha.org/newspeak-modules.pdf][Modules as Objects in Newspeak]]: 

/In Newspeak, nor is there a global namespace. Modularity in Newspeak is based exclusively on class nesting. There are no separate modularity constructs such as packages. Top level classes act as module definitions, which are independent, immutable, self-contained parametric namespaces. They can be instantiated into modules which may be stateful and mutually recursive./

Newspeak uses the following definitions (from the section [[*Newspeak terminology][Newspeak terminology]]):

- */Module declaration/* is the source code of any top level class
- */Module definition/* or */Module class/* is any */top level class object/*.  We will use the terms interchangeably depending on context.
- */Module/* or */Newspeak module/* is an */instance of any top level class/*.

So, an instance of any class shown on the top level in the IDE is a /module/.

*/Newspeak Module/ is not only an empty new term.  It turns out, that, by nesting other classes, /modules/ also satisfy what we normally want from software modules: they are self-contained elements of data and functionality which can be distributed or executed, given expected API.*  To understand more about how expected API determines a module's role, see [[*Newspeak modules API summary][Newspeak modules API summary]]. In addition, /Newspeak modules/ cannot cross-access each other when deployed - unless one module explicitly requests another /module/ or /module class/ during packaging and building.  


*** Discussion of Namespaces

/Namespaces/ in softwware in general provide grouping and organization of artifacts used in programs (packages, classes, or functions).  A Java namespace example would be "org.mypackage".  All classes in that package belong to the namespace "org.mypackage".  Python concept of a package is similar. 

Most platforms and languages have a concept and need for a *global namespace*. How can we describe it? Perhaps a good high level description of a /global namespace/ would go like this: In a program, we want to use other programs, classes, functions, or what have you, created by other developers, at compile time or runtime, depending on the platform.  If our Java program is in the "org.mypackage" and a class "org.mypackage.MyClass wants to use "org.apache.SomeClass", then at compile time or at runtime, the platform (Java, but e.g.  Python is equivalent) has to find "org.apache.SomeClass".  How does it do that? By looking through CLASSPATH or PYTHONPATH.  The CLASSPATH or PYTHONPATH play the role of the /global namespace/!  All other namespaces, such as "org.apache" belong to the /global namespace/.  In a Java or Python program, any class and it's instance at runtime has access to artifacts on the CLASSPATH or PYTHONPATH. For example, this code

#+begin_src java
// In org.mypackage.MyClass: 
Object newObject = Class.forName("org.apache.SomeClass").newInstance();
#+end_src

Creates an instance of "org.apache.SomeClass" at runtime by finding it on CLASSPATH - on the /global namespace/ of Java. As long as the classloader can find "org.apache.SomeClass" on the CLASSPATH, and SomeClass has the default constructor, an instance can be created - without "org.apache.SomeClass" ever being imported to the code. Instances of classes in "org.mypackage" can create instances of classes in "org.apache" and vice versa, without importing each other.  *This is why the availability of the /global namespace/ harms modularity, as it enables "hidden dependencies" like the one described in this short Java example!* 

The Newspeak language does not have a /global namespace/ but the Newspeak IDE does have a /global namespace/ - the /Root/ on top of the IDE we have seen in the previous chapter. There is some discussion regarding why that is in [[*Namespaces and existence of global namespace in the IDE][Namespaces and existence of global namespace in the IDE]].

The consequence of /no global namespace in the language/ is that, at runtime (outside of IDE), a Newspeak module class must declare it's dependency on another module class (or module) explicitly, by storing the dependency module definition (or dependency module) on it's module slot! This storing of a dependency on a slot can be looked at as "importing" the dependency. Example of code where showing all classes needed at runtime are "imported" by holding on to them on module slots:
- In [[*4. Hello World Application using 3rd party dependency][4. Hello World Application using 3rd party dependency]] the ~HelloTranslatorLib~ holds on to the ~HelloTranslator~
- In [[4. Application module: API of module that needs to be distributed as an App][4. Application module: API of module that needs to be distributed as an App]] ~RecipyWithDepApp~ holds on to the ~RecipyWithDep~, and ~RecipyNoDep~.

*The dependency management goes deeper: A distributable module (Application or Library object), when instantiated and serialized on the source system, 'carries along', ALL imported dependencies on it's module slots - classes or instances of other classes from it's slots. After deserialization on the target system, it has all the code and objects it needs to work on the target system. (The Platform object is an exception: it is assumed to exist on both the source the target platform with same API, and it is not a part of the serialized artifact.)*

For the more complete language discussion of what a namespace is, and why a global namespace is not needed in the Newspeak language, see https://gbracha.blogspot.com/2008/12/living-without-global-namespaces.html. 


*** Namespaces and existence of global namespace in the IDE

The existence of the /Root namespace/ in the Newspeak IDE describes one of my surprises - although I realized only later that I should be surprised.  I should have been surprised because there are many places in the Newspeak documentation describing that "Newspeak has no global namespace".  So I was wondering why this "Root", is not a global namespace? Turns out that it is! But there is an important distinction, /the Newspeak *language* does not have a global namespace while the Newspeak *IDE* does - it's name is "Root"/.

Next we can ask, why does the Newspeak IDE need a global namespace (Root), while the Newspeak language does not have one, in fact very intentionally does not have one?  The reason is, when working in the IDE, we want cross-access between the /module classes/ (the /top level classes/).  At runtime, that is, after packaging and deployment of any Newspeak module (outside the IDE), only the modules intended to be used by other modules should be available!  Modules cannot freely cross-use each other, because there is no global namespace to find each other (or each other's class).  If a moduleA needs to use moduleB, moduleA must explicitly ask to include moduleB's definition (the class of moduleB) at the packaging stage. See also the text and links in [[*Dependencies and modularity: Important but hard to "get" at first][Dependencies and modularity: Important but hard to "get" at first]].


** Class structure, primary factory methods, platform and manifest, modules API

*** Section TL;DR:

This section starts an IDE-guided step by step discovery of some core aspects we encounter when we first dig into the IDE and the classes on top: Newspeak class structure, app and library API, platform and manifest.

*** Top level classes in the IDE - expanded

Let us expand each top level class in the "sources" screenshot above.  We expanded two classes (named ActivationMirrorTestingConfiguration and AliensForV8) in the screenshot below:

[[file:img/newspeak---a-few-notes.org-ide-full-page-classes-expanded.png]]

Continue reading what we can learn from looking at the expanded classes.


*** Newspeak class structure

First, we can see, each top level class has 4 sections.  Let's take the ActivationMirrorTestingConfiguration as an example

1.  A collapsible class name section for the class, ~ActivationMirrorTestingConfiguration~ with two sub items
   - on top the ~#packageTestsUsing: manifest~.  This is a method which can be viewed as the "core" or "primary" constructor.  In Newspeak, the method is called the *Primary factory*. 
   - a list of ~Slots~.  Slots are like "member variables".  Slots can only be created in the /primary factory method/!
2.  a list of ~Classes~.  Those are nested classes of the class ActivationMirrorTestingConfiguration
3.  a list of ~Instance methods~.  Those are instance methods we can call on instances of ActivationMirrorTestingConfiguration
4.  a list of ~Class methods~.  Those are class methods we can call on the class ActivationMirrorTestingConfiguration.  They are "alternative constructors".

There is a plus ("+ ") symbol  in the header of some of them.  The reason there is no plus ("+ ") symbol beside slots, is that slots can only be added in the code of the /primary factory method/.  Add a slot from the  /primary factory method/ code, and the added slot name will show in the IDE.


*** Primary factory methods

We mentioned the methods on the first line of the class declaration such as ~class MyClass packageTestsUsing: manifest~ are termed the /primary factory methods/.

*The core role of a /primary factory method/ is to produce instances (and declare and initialize their slots). The difference between a /primary factory method/ and a /factory method/ or an /instance method/ is that ONLY /primary factory method/ can declare in initialize slots!*

Newspeak language implementation detail: We also mentioned that the /primary factory methods/ are methods on special objects, the 'class factory object'(s).  One such special object is created for each class declaration: for example, when a class declaration ~AMyClass new = ()()~ is loaded or saved in the IDE, one instance of the 'class factory object' named ~AMyClass~ is created.  The role of the special object ~AMyClass~ is to produce instances of ~class AMyClass~

*The platform objects (objects that represent the Newspeak system), or the dependencies objects or classes (classes that need to be "imported" from the manifest) are passed to the primary factory method and held on slots.  From there, they are available to all nested classes and nested objects of the top level instance!*

The /primary factory method/ names on the /top level classes/ have eerily similar signatures.  I was asking myself why, what do they have in common.  So I listed examples of the primary factory method names.  Here is the list of the /primary factory methods/ on some top level classes:

#+BEGIN_EXAMPLE
class AccessModifierTesting                 usingPlatform:       platform  testFramework: minitest = (| etc
class AccessModifierTestingConfiguration    packageTestsUsing:   manifest = (| etc
class ActivationMirrorTesting               usingPlatform:       platform minitest: m = (| etc
class ActivationMirrorTestingConfiguration  packageTestsUsing:   manifest = (| etc
class ActorsForPrimordialSoup               usingPlatform:       platform = (| etc
class AliensForV8                           usingPlatform:       platform = ( etc
class Browsing                              usingPlatform:       platform ide: webIde = ( etc
class Collections                           usingPlatform:       platform = ( etc
class CollectionsForPrimordialSoup          usingInternalKernel: ik = ( etc
class CombinatorialParsing                  usingPlatform:       platform = ( etc
class RuntimeForV8                          packageUsing:        manifest = ( etc
class Streams                               usingPlatform:       platform = ( etc
#+END_EXAMPLE

We can see that the primary factory methods accept, at first position, one of 2 arguments

- ~platform~
- ~manifest~

If the constructor first argument is ~platform~, the constructor name *always starts with*

- ~#usingPlatform: platform~

If the constructor first argument is ~manifest~, the constructor name is *always one of*

- ~#packageUsing: manifest~
- ~#packageTestsUsing: manifest~ (for tests only)
  
Clearly, ~platform~ and ~manifest~, must be significant!

What are those objects? And what do they contain, why are they significant, and what role do they play in Newspeak? 


*** The manifest object

**** What is in the manifest object?

So what is in the manifest, why it is significant, and what role does it play in Newspeak?

We can look at the code, and ask what Newspeak passes into the ~manifest~ parameter.  We find that there is only one place that calls ~#packageUsing: manifest~, and it passes for ~manifest~ the value of object ~ide namespacing manifest~.  So we can examine what ~ide namespacing manifest~ contains.  In Workspace, let us evaluate it:

#+begin_src 
ide namespacing manifest
#+end_src

[[file:img/newspeak---a-few-notes.org-ide-namespacing-manifest.png]]

Drilling into the instance, we can see it is a map, and sorting by the key, we can see the map elements:

#+begin_example
at: AccessModifierTesting   AccessModifierTesting
at: AccessModifierTestingConfiguration   AccessModifierTestingConfiguration
  etc
#+end_example

By looking at the IDE, we see that the *manifest is a map containing exactly all top-level classes in the IDE - that is, all module classes known to the IDE!*

So we have a experiment based answer to what the manifest object contains.

But what is the manifest good for?  We discuss that further down, but as a look ahead: the values of the manifest map are classes that can be "imported" and "kept" during packaging of the module! 


**** Why is the manifest object significant, and what role does it play in Newspeak?

OK, so from the previous chapter we know the ~manifest~ object that is passed to 

- ~#packageUsing: manifest~
- ~#packageTestsUsing: manifest~ (for tests only)

is a map of all top-level classes in the IDE.

See [[*Common and distinct roles of platform and manifest in modules][Chapter Common and distinct roles of platform and manifest in modules]] for a discussion the significance and role of the /manifest/ object.


*** The platform object

**** What is in the platform object?

As in manifest, we can ask: what is in the platform, why it is significant, and what role does it play in Newspeak?

We can look at the code, and ask what Newspeak passes into the ~platform~ parameter when calling, for example, ~#usingPlatform: platform~.

This is little harder than with manifest, so let's cheat a bit.  In Workspace, let us evaluate ~platform~
[[file:img/newspeak---a-few-notes.org-workspace-eval-platform.png]]
Drilling into the link "instance of PlatformWithHopscotch`number", we see a list of instances. Sorting the list, we can see it contains ~instances~ of a few classes that look like system classes:

#+BEGIN_EXAMPLE
instance of ActorsForPrimordialSoup
instance of CollectionsForPrimordialSoup
instance of FontsForHTML5
instance of GraphicsForHTML5
instance of HopscotchForHTML5
instance of JSForPrimordialSoup
instance of Kernel
instance of MirrorsForPrimordialSoup
instance of PrimordialFuel
instance of TextModule
#+END_EXAMPLE

Classes of all of those instances also exist in the ~manifest~ object. 

From the above, we have a good indication as to what does the platform object contain: *the platform object contains instances of system classes from the manifest!*



**** Why is the platform object significant, and what role does it play in Newspeak?

OK, so we know what is in the ~platform~ object that is passed to 

- ~#usingPlatform: platform~

See [[*Common and distinct roles of platform and manifest in modules][Chapter Common and distinct roles of platform and manifest in modules]] for a discussion the role of the /platform/ object.


*** Common and distinct roles of platform and manifest in modules

TL;DR: Recall that module is instance of a top level class in IDE.  ~manifest~ is needed during Applications and Libraries instance creation for packaging for distribution, to pull from it (include) all class declarations instance depends on; ~platform~ is needed any time a module  requires an instance of another module (top level class) - the only way for module to gain another module is through platform. More details are below, and in the section [[*Modules: Application, Library, TestConfiguration, General][Modules: Application, Library, TestConfiguration, General]].  

Why are the ~platform~ and ~manifest~ objects so important to appear again and again in the /top level classes' factory parameters/, as seen in [[*Primary factory methods][Primary factory methods]] ?

The answer is somewhat common for ~manifest~ and ~platform~, so we describe their role in this common section.

The common need for both ~manifest~ and ~platform~ stems from modularity.  But what does that mean?

In [[*Newspeak terminology][Newspeak terminology,]] we saw that the /modules/ are DEFINED AS /instances of top level classes/.

And we saw that there is no global namespace in Newspeak.  Modules need other objects (dependencies) to do useful work.  In Newspeak, for a module to "contain" ANY dependency, such dependency must be on the module instance slot (slot is like a member variable).  Also, at the point of the module construction we MUST supply such dependency.  Because only the /primary factory/ can define slots, the *module primary factory must be passed everything the module needs from outside*.  

This is where ~platform~ and ~manifest~ come in.  They are "special" in the sense that they supply objects and classes needed by the module.  But each is needed at a special point of the module lifecycle: 

- _The /manifest/ object is needed at packaging step on the system where we create the package_: /manifest/ is passed to the module packaging method such as ~#package(Something)Using: manifest~ which packages dependencies that need to be carried over from the system we are packaging on, to the module artifact that is copied to the deployment platform.
- _The /platform/ object is needed on the deployment step on the deployment system_, to instantiate the module by ~#(buildSomething)usingPlatform: platform~ or perform the module work and passed there to the runtime method such as or ~main: platform args: args~.


We can reword the above as follows:

We already know that any Newspeak object can have only one "slot defining constructor" (called /primary factory/) in it's API.  But, as a module needs both ~platform~ and ~manifest~, how can we ensure a module has both available?  This is done by *convention methods*, that are either a /primary factory/ or a regular /instance method/, depending whether the module is an /App, Library, and Test configuration module/ OR a /General/ module.

- App, Library, and Test configuration modules (but not "General modules") have a *primary factory* passing a ~manifest~ in it's API. This /primary factory/ is named similar to ~#package(Something)Using: manifest~.  This factory is called on the system where we create the package to "import" objects and/or their classes during packaging (by placing them to the package artifact which can be delivered over to the runtime system).
- Any "General" modules (not App, Library, or Test configurations) have a *factory* passing a ~platform~ in it's API. This /primary factory/ is named similar to ~#(buildSomething)usingPlatform: platform~.  This factory is called on the runtime system for module instantiation.  An App, Library, and Test configuration module (where the /primary factory/ is already taken by presence of method passing platform such as ~#package(Something)Using: manifest~) would typically also have this method in it's API, but NOT as a factory, rather as an instance method.

To read more details about which method is used on which module type, and why, follow the next section [[*Modules: Application, Library, TestConfiguration, General][Modules: Application, Library, TestConfiguration, General]].


*** Newspeak platform and manifest objects summary

In a nutshell, 
- We need /manifest/ classes for packaging.  Manifest provides the classes needed to "bring along" (import) in the package.  Those "bring along" or "import" classes may not exist on the end-user system, so they need to be added to the package!
- We need /platform/ for execution.  Platform provides instances of "system classes".  Those "system classes instances" are assumed to exist on the end-user system, so we do not need to bring them along in the package!


** Modules: Application, Library, TestConfiguration, General

TL;DR: This section is the core reason why I started writing the top section [[Newspeak: An ide-driven journey leading to Hello World]].  It exploits the /role/s (aka /abilities/, aka /requirements/) any program in most languages on most Operating systems performs: a program must be able to *start execution*, then *instantiate, load or link libraries, then use them*. In addition, any program should be *packageable* for distribution.  Libraries are shareable artifacts.  In Newspeak, programs, libraries, even tests, are instances of top level classes (modules).  In Newspeak, each /role/ a particular module performs, is enabled by providing the module with a "convention method" which performs the /role/.  This section is about the /role/s and the "convention method" signatures for Newspeak modules.

Terminology: We use the name /role/s for what is above described as /role/s (aka /abilities/, aka /requirements/).

*** Application and library in computing

In computing, any program in most languages on most Operating systems must be able to *start execution*, then *load or link libraries, then use them*; in addition,  any program should be *packageable* for distribution.  We term each such ability a /role/.  In computing, we tend to separate artifacts into (executable) Application and (linked) Libraries.  We can itemize such roles as follows.

1. An Application must be able to *start execution* on the platform to which it is targeted (here, platform in the sense of "Linux platform", "Android platform", "Windows platform", and in our situation, the "Newspeak platform"). 
2. A Library must be able to be *load and link other libraries*, at least in principle, by the caller Application or another Library on that platform.  The library /used/ by an Application or another Library is often called a dependency.  The term /used/ implies that the Library is *found* and *connected* to the Application or Library which is using it. We can call this ability *buildDependencies*
3. In addition, we should be able to *package* both the Application and the Library for distribution (deployment). Packaging includes *instantiation* and *serialization*.


So an Application needs to provide a facility (API, method) to perform /role/s 1 and 3.  A Library needs to provide a facility to perform /role/s 2 and 3.

From the generic /role/s above, both Application and Library need some way to perform the /role/s.  Methods perform /role/s, so we need some "convention methods" to perform the roles 1, 2, 3.  Such "convention methods" represent a public API, described in the following section.


*** Application and library API in computing

Following the basic /role/s from the previous section [[*Application and library in computing]] in mainstream computing, we need  "convention methods" to perform the /role/s 1, 2, 3 in the previous section.  We choose to name such "convention methods" as follows:  (the names are arbitrary, but conventional, and represent the APIs understood on the platform)

- For an App:
  - To perform /role/ 3, /instantiateForPackaging/, let's call the method ~#package~.
  - To perform /role/ 1, /start execution/, let's call the method ~#main~
- For a Library:
  - To perform /role/ 3, /instantiateForPackaging/, let's call the method ~#packageLibrary~
  - To perform /role/ 2, /buildDependencies/, let's call the method ~#build~

A mainstream system has the advantage of access to a global namespace - generally a filesystem via a PATH, CLASSPATH, PYTHONPATH or similar.  We discussed that earlier as well.  Inside any of these methods, during execution, the program can look and find various artifacts it needs on the platform.  If we start the method equivalent to "#main" in Python, inside #main there may be a line of code such as ~from graphics import Rectangle~.  So we need the Rectangle class.  No problem, we go to the classpath, find the namespace /graphics/, there lives the module /graphics/, and the class /Rectangle/ is there.  We load it and continue. 


*** Application and library modules in Newspeak

In Newspeak, everything is done via objects.  So Application and Library must be an object.  Further, Newspeak starts all operations on the instances of top level classes, that is, on modules. For terminology, see [[*Newspeak terminology][Newspeak terminology]], also [[*Discussion of Modules][Discussion of Modules]].

But Newspeak cannot load anything globally.  If the API for the Application and library was as defined above in [[*Application and library API in computing][Application and library API in computing]], applications would not run as there would be no way to bring anything from a construct such as the CLASSPATH.  In more detail if the App's ~#main~ method defined above was to run, and Newspeak would discover the equivalent of "import" (which is slot creation in primary factory methods), it would not be able to find the "imported" dependency module.  It does not have the global namespace or access to the  PATH, CLASSPATH, PYTHONPATH or similar. 

*The solution is, during instantiation of Newspeak Application and Library objects, all the runtime dependencies (or rather their classes) are passed to the /primary factory methods/ and stored on slots, to be "carried along" in the objects for serialization and distribution. The dependencies are passed to the factory methods in the manifest object, which has all the top level classes in it*. See [[*The manifest object][The manifest object]].

Once an Application and Library object exists, it is serialized on the source system, and sent to a different (target) system where it is deserialized. At that point, on the target system, it needs to be used to be useful. *Newspeak defines methods for such use. These methods accept an object which is TYPICALLY NOT part of the serialized instances: The ~platform~ object. It encapsulates the common capabilities of the Newspeak system on all systems (platforms, hence the name)*. See [[*The platform object][The platform object]].

Nespeak extends the signatures of /role/s 1, 2, 3 from previous chapter to provide the "carry over" (imported) classes from ~manifest~, and system classes from ~platform~, Newspeak uses the following signature names:

- *For an App*:
  - To perform /role/ 3, /instantiateForPackaging/, Newspeak uses the primary factory method ~#packageUsing: manifest~.
  - To perform /role/ 1, /start execution/, Newspeak uses the instance method ~#main: platform args: args~
- *For a Library*:
  - To perform /role/ 3, /instantiateForPackaging/, Newspeak uses the primary factory method ~#packageLibraryUsing: manifest~
  - To perform /role/ 2, /buildDependencies/, Newspeak uses the instance method ~#buildUsing: platform~

These four methods are core "convention methods" for all Newspeak modules which we want to behave as either Apps or Libraries.

See also [[* How do I bring dependencies into modules to be distributed?][How do I bring dependencies into modules to be distributed?]]


*** Newspeak modules API summary

This section is a summary and reference of Application, Library, and Test configuration modules API in Newspeak.  It is sort of the pinnacle of the parent section about Apps and Libraries. 

*As explained in the previous section, in Newspeak, compared to a mainstream platform which has access to global namespace, we have to change the API signatures described in [[*Application and library API in computing][Application and library API in computing]] by passing the /platform/ and the /manifest/ object.*  We also change the signatures to match actual Newspeak names.

*Here are the APIs which define whether a Newspeak module is an App, a Library, a TestConfiguration, or a General module*.  The /role/s 1, 2, 3 refer to the /role/s (roles) in  [[*Application and library API in computing][Application and library API in computing]]. Please note that Newspeak is not using the terms "App module", "Library module", "General module", or "TestConfiguration module". I find such classification of modules useful though.

- *Newspeak Application module* is defined by the presence of:
  - Primary factory method ~#packageUsing: manifest~ which performs /role/ 3, /instantiateForPackaging/. 
    - Implementations should
      - pull needed classes from the manifest and place then on slots. optionally instantiate the classes from manifest unless they need platform.
      - instantiate Libraries from manifest and store resulting objects on slots using ~a3RdPartyDependency = A3RdPartyDependency>>#packageLibraryUsing: manifest~.
  - Instance method ~#main: platform args: args~ which performs /role/ 1, /start execution/.
    - Implementations should instantiate, from slot classes and platform objects, all object needed to run the app,
      then call methods on them which perform "running the app"

- *Newspeak Library module* is defined by the presence of:
  - Primary factory method ~#packageLibraryUsing: manifest~ which performs /role/ 3, /instantiateForPackaging/.
    - Implementations should do the same as Application does in ~#packageUsing: manifest~  - see above. 
  - Instance method ~#buildUsing: platform~ which performs /role/ 2, /buildDependencies/
    - Implementations should build, then return a working instance of the module we want to distribute, *NOT the Library instance* on which this #buildUsing is defined!! See example in [[* How do I bring dependencies into modules to be distributed?][How do I bring dependencies into modules to be distributed?]]
    - Important note:  *If we want to distribute an existing module MyModule1 (this may or may not be a library module!), we have to either*:
      - Convert MyModule1 to MyLibrary1 
      - create a separate top level Library Module, MyModule1Lib for the purpose of distributing MyModule1.
        The #buildUsing: implementation we are talking about here, is the  "MyModule1Lib>>#buildUsing:" method! -  NOT the  "MyModule1>>#buildUsing:" method, as this may not even exist on MyModule1!
    
- *Newspeak TestConfiguration module* by convention ends with "Configuration", and is defined by the presence of:
  - Primary factory method ~#packageTestsUsing: manifest~ which performs /role/ 3, /instantiateForPackaging/
    - Implementations should put on slot the class of the Module being tested.
  - Instance method ~#testModulesUsingPlatform: p minitest: m~  which performs /role/ 2, /instantiate/, 
    - Implementations should call return instance of the tested class.  Example: ~^{AccessModifierTesting usingPlatform: platform testFramework: minitest}~
  - *Note:* Tests, by convention, need two classes to be created. If class MyTestModule has the test methods, MyTestModuleConfiguration must be created.  This is the class we are talking about in this section. There are no "convention methods" on the test module MyTestModule. 
      
- *Newspeak General module* is /any other module/ - any module that does not have any of the above API.  General modules *do not have any convention API name*.
  - However, we often find they have a /primary factory method/ named *similar to* ~#usingPlatform: platform [and: otherObjects]~ which create a working instance. Note that the [and: otherObjects] portion is completely free, it can be named differently.  
    - These modules can for example be 
      - modules we distribute using the /Library Distribution module/ 
      - tests we run using the /TestConfiguration module/

Note that on Application and Library modules, the methods which *perform the packaging*, are /primary factory methods/ (~manifest~ is passed to them), while the methods which perform *execution or build* are /instance methods/ (~platform~ is passed to them).  The reason is, a /primary factory method/ is the only method which can store stuff in slots! So any classes needed to be "carried along" for packaging (pulled from manifest then "imported" on the target platform during construction), must be placed on slots during the primary factory method call.

Note that the IDE uses the presence of certain methods to show appropriate action links.  For example,

- If the method ~#packageUsing: manifest~ exists in the module, IDE shows links to *[deploy] [configurations] [run] [debug]*
- If the method ~#packageTestsUsing: manifest~ exists in the module, IDE shows links to *[run tests] [show tests]*


*** Newspeak modules API zoo

TL;DR: This section shows a table of Newspeak "Module type"s in rows, and "convention method" signatures each "Module type" must provide.  Given a "convention method" signature, we know the /role/ or /role/s the method performs.  The table is a summary of conclusions of the above section [[*Newspeak modules API summary][Newspeak modules API summary]].  For motivation of the need for "convention methods", see the top section [[Newspeak: An ide-driven journey leading to Hello World]], in particular it's subsection [[*Modules: Application, Library, TestConfiguration, General][Modules: Application, Library, TestConfiguration, General]],

In general computing there are artifacts, performing /role/s of *applications*, *libraries*, and *tests*.  In Newspeak, equivalents of such artifacts are uniform: they are all instances of a specific module.  We say that a module instance has a "Module type" in Newspeak, if the module instance has all required "convention method"s for all /role/(s) required by the "Module type".

Terminology: "Module type" is not a formal term in Newspeak.  We use the term "Module type" to group module instances according to their "convention methods" - in other words, according to their /role/s.  Also, in text, we use the brief /Application module/ instead of /Application module type/, /General module/ instead of /General module type/ etc.

The table below summarizes, for each "Module type" in Newspeak, the "convention methods" names and the /role/(s) each such method performs.


| Module type                              | Convention primary factory method.                    | Note                          | Sep | Convention instance method.                            | Notes: What the code in column "Instance method" typically does |
|                                          | Roles=instantiateForPackaging                         |                               |     | Role=buildDependencies(Library), execute(Application), |                                                                 |
|------------------------------------------+-------------------------------------------------------+-------------------------------+-----+--------------------------------------------------------+-----------------------------------------------------------------|
| Library (no example in code)             | #packageLibraryUsing: manifest                        |                               | -   | #buildUsing: platform                                  |                                                                 |
| Application                              | #packageUsing: manifest                               |                               | -   | #main: platform args: args                             | instantiates classes on slots then calls methods to run app     |
| TestConfiguration                        | #packageTestsUsing: manifest                          |                               | -   | #testModulesUsingPlatform: platform minitest: m        | instantiates Test classes and returns their list (does not run) |
|------------------------------------------+-------------------------------------------------------+-------------------------------+-----+--------------------------------------------------------+-----------------------------------------------------------------|
|------------------------------------------+-------------------------------------------------------+-------------------------------+-----+--------------------------------------------------------+-----------------------------------------------------------------|
| Module type                              | Convention primary factory method.                    |                               | -   | Convention instance method                             |                                                                 |
|                                          | Role=instantiate                                      |                               | -   | is not required, so no defined role                    |                                                                 |
|------------------------------------------+-------------------------------------------------------+-------------------------------+-----+--------------------------------------------------------+-----------------------------------------------------------------|
| General, needs platform + [other module] | #usingPlatform: platform [andModule: m1] (or similar) | Note: name is completely free | -   | not required                                           |                                                                 |
| General, needs only other module         | #usingModule: m1                         (or similar) | Note: name is completely free | -   | not required                                           |                                                                 |
| General, with no needs (dependencies)    | #new                                                  |                               | -   | not required                                           |                                                                 |
| Test                                     | #usingPlatform: platform testFramework: minitest      | runs tests                    | -   | not required                                           |                                                                 |

Notes:

- The headings for "Module type" Library, App, and TestConfiguration are separated from the headings for "Module type" General, and Test as the /role/s differ:
  - The modules of type Library, App, TestConfiguration  require multiple /roles/, provided by two required "convention method"s for each type.
  - The modules of type General and Test only requires the /role/=instantiate, provided by only one required "convention method" for each type.
- For any Application module: When we click the [run] button in the IDE, the IDE calls the Application's primary factory method ~#packageUsing: manifest~, then the instance method ~#main: platform args: args~ which runs the app in the IDE.   Similarly, when we click on the [deploy] button in the IDE, the same methods are (eventually) called, followed by calling serialization methods, which serialize the instance to bytes and save them as ~.vfuel~ file.
- A Library module and an Application module play a similar role.  However, an Application module is intended to be *packaged, distributed and executed* as a standalone App, while an Library module is intended to be *packaged, distributed and included in Application modules or other library modules*.
- For any General module: The method signatures ARE NOT FIXED BY CONVENTION, they are only *softly conventional*. That helps humans to distinquish their invocations from nested classes. The signature ~#usingPlatform: platform [andModule: m1]~ is an example of a primary factory method which is passed the platform and a dependency which is module m1.
- ~TestRunner.ns~ is later packaged(instantiated), then called ~main:args:~ which runs Test instances returned from ~#testModulesUsingPlatform: platform minitest: m~


*** Recipies for modules creation and conversion, by module type

TL;DR: This section provides some guidance of how to code each module type, and convert between them.  Conversion is sometimes needed when a General module grows useful and we want to convert it to an Application or Library module.

**** Application module recipy

We can provide a "recipy" for how any Application module should be written:

- In the primary factory method ~#packageUsing: manifest~, store any "carry along" (imported) classes from the manifest map on the slots
- In the instance method ~#main: platform args: args~
  - First use all (imported) classes on slots to instantiate them:
    - For each slot which is a General module class, call its primary factory methods, to build the module (dependency). The General module primary factory signature may be similar to ~#usingPlatform: platform [andModule: m1]~, or ~#usingModule: m1~, or just ~#new~.
    - For each slot which is a Library module class, call its build instance methods, named similar to ~#buildUsing: platform~, to build the 3rd party module (dependencies) 
  - Next, on the instances created just before, call appropriate methods to run the Application.  If the application has a UI, it usually needs to instantiate its Model and Subject, then invoke code similar to ~platform hopscotch HopscotchWindow openSubject: subjectInstance~. See, for example, [[* When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*][When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*]].
    

**** A recipy to convert a General module to an Application or Library module

Often, we start developing a module (more precisely, a module declaration, the source of a top level class) for "internal" use, with no need to "ship" it as an Application or a Library for others to use. Such module would be built as a General module with methods described above in [[* Newspeak modules API zoo][Newspeak modules API zoo]]. Later, we may decide to make this module available to others as a library or an app. This step of converting a General module available as a Library or an Application, _requires adding specific API methods_, which identify the General module we started with as an Application module or a Library module.  
Note that initially, our General module has a primary factory method named similar to ~#usingPlatform: platform:~. From the API naming "convention" in [[* Newspeak modules API zoo][Newspeak modules API zoo]], we can deduce a "recipy" to convert a General module to an Application or a Library, as follows:

- App: If we want to convert a General module to an Application, we need to
  - move the primary factory method from the General module to an instance method ~#main: platform args: args~.
  - add a primary factory method ~#packageUsing: manifest~ and store any needed classes from manifest. The code of this new primary factory method should generally declare a slot for each class that will be needed at runtime, "import" (pull) the class from the manifest, and store it on the slot.
- Library: If we want to convert a General module to a Library, we need to
  - move the primary factory method to an instance method named ~#buildUsing: platform~
  - add a primary factory method ~#packageLibraryUsing: manifest~.

**** A recipy to wrap a General module to an Application or Library module

An alternative to the previous section could be, that the General module class we created remains unchanged, and we add a "wrapper" Library module or a "wrapper" Application module. In this situation, our original General module code remains unchanged.

Becaus unlike the previous section, we are adding new top level modules, let's give the modules names. Let us assume the original General module is named ~MyModule~ and has a primary factory method, named ~#usingPlatform: platform:~, and instance method ~#doWork~ which performs work for some role useful for client applications. 

- If we want to wrap ~MyModule~ as an App, we could add the Application class wrapper similar to
  #+begin_src 
  class MyModuleApp packageUsing: manifest = (
    |
    MyModule = manifest MyModule.
    |
  ) 
  (
    public main: platform args: args = (
       |myModule|
       myModule:: MyModule 
                      usingPlatform: platform. 
       myModule doWork.
    )
  )
  #+end_src
  
- If we want to wrap ~MyModule~ as a Library, we could add the Library class wrapper similar to
  #+begin_src 
  class MyModuleLib packageLibraryUsing: manifest = (
    |
    MyModule = manifest MyModule.
    |
  ) 
  (
    public buildUsing: platform = (
       |myModule|
       myModule:: MyModule 
                      usingPlatform: platform. 
       ^myModule.
    )
  )
  #+end_src


** Newspeak recipy for writing modules API

Sections above attempted to discover and describe modules API, see [[*Newspeak modules API summary][Newspeak modules API summary]]. This section will attempt to give a "recipy" for the method signatures each module type (Library module, General module, Application module) requires.

**** 1. General module with NO dependencies: API of module with no dependencies

While perhaps rare, this is the simplest case. If our module does not need any dependencies, not even from common classes such as collection:

- provide a /primary factory method/ ~#new~

***** Example:

#+begin_src 
class RecipyNoDep new = ()
(
    public translate: text = (
      text = 'Hello World' ifTrue: [^ 'Hallo Welt'.].
      
      ^ 'unable to translate'.
    )  
)
#+end_src

Note: Because ~#new~ is default, no need to name it. An equivalent would be 

#+begin_src 
class RecipyNoDep = ()
(
    public translate: text = (
      text = 'Hello World' ifTrue: [^ 'Hallo Welt'.].
      
      ^ 'unable to translate'.
    )  
)
#+end_src


**** 2. General module with dependencies: API of module with dependencies

If our module need some other module from IDE, such as collections, you have to pass it the ~platform~ object, and potentially other objects or classes our module depends on

- provide a /primary factory method/ ~#usingPlatform: platform~
- OR if another module is needed, provide a /primary factory method/ such as ~#usingPlatform: platform andModule: translator~

***** Example:

#+begin_src
class RecipyWithDep usingPlatform: platform andModule: translator = (
  |
  List = platform collections List.
  translator = translator.
  |
)
(
    public translate: fromRevertedList = (
      |sortedList|
      sortedList:: List new.
      sortedList add: (fromRevertedList at: 2).
      sortedList add: (fromRevertedList at: 1).

      ^ translator translate: ((sortedList at: 1), (sortedList at: 2)).
    )
)
#+end_src

and we can use this in workspace as:

#+begin_src 
|sortListTranslator|
sortListTranslator:: RecipyWithDep  usingPlatform: platform andModule: (RecipyNoDep new).
sortListTranslator translate: {' World'. 'Hello'}.
#+end_src

Note that the RecipyNoDep class could be passed instead of the instance; obviously the slot translator in RecipyWithDep would have to be a class, instantiated in ~#translate:~


**** 3. Library module: API of module that needs to be distributed for use in other modules

This next step describes an example of a module which is intended to be distributable as a library. In Newspeak, *this means such module must be both packageble and distributable* - the roles of "packageble" and "distributable" are achieved by implementing the 2 methods below. We call such modules informally /Library modules/.

In the previous section, we introduced a general module ~RecipyWithDep~. If we needed this module to be used as a library we could
1. either "convert" ~RecipyWithDep~ into a library,
2. or add a "wrapper library" which will be the module used for distrubution.

In this example, we show the second method - we add a "wrapper library" for ~RecipyWithDep~ in two steps

1. We add a *separate module - the wrapper library* with a descriptive name (to make clear it is a library), ~RecipyWithDepLib~
2. In the new ~RecipyWithDepLib~, add the following API methods:
  - primary factory method ~#packageLibraryUsing: manifest~, which allows to "import" the ~RecipyWithDep~ and the other needed dependency ~RecipyNoDep~
  - Instance method        ~#buildUsing: platform~, which allows dependencies to be pulled at construction time

Note that in this case, /#buildUsing: platform/ must not be added any other arguments. Any "carry along" (imported) classes that may be needed at build time, must be saved on slots in the /#packageLibraryUsing: manifest/ primary factory method.  See also [[* Newspeak modules API zoo][Newspeak modules API zoo]].

***** Wrapper for RecipyWithDep:

To create a packageble and distributable library module for the above ~RecipyWithDep~, create this library module 

#+begin_src 
class RecipyWithDepLib packageLibraryUsing: manifest = (
  |
  RecipyWithDep = manifest RecipyWithDep.
  RecipyNoDep   = manifest RecipyNoDep.
  |
) 
(
  public buildUsing: platform = (
     |revertedTranslator|
     revertedTranslator:: RecipyWithDep 
                    usingPlatform: platform 
                    andModule: (RecipyNoDep new).
     ^revertedTranslator.
  )
)
#+end_src

Note how the library must store any "carry along" (imported) classes on slots during packaging, then instantiate them during building. 

Also note how the passing of ~platform~ moves from the primary factory in the module, to the instance method in the library:
  - In the module ~RecipyWithDep~ , it is on the /primary factory method/ /#usingPlatform: platform:/ 
  - To the distribution library ~RecipyWithDepLib~, it is on the /instance method/ /#buildUsing: platform/.

Although intended for distribution, for testing this process, the library can be used in workspace as 

#+begin_src 
|sortListTranslatorLib sortListTranslator |
(* this would run on the developer's packaging system *)
sortListTranslatorLib:: RecipyWithDepLib packageLibraryUsing: ide namespacing manifest.

(* this would run on end-user runtime system *)
sortListTranslator:: sortListTranslatorLib buildUsing: platform.

sortListTranslator translate: {' World'. 'Hello'}.
(* Expected result: 'Hallo Welt' output string just below the Workspace line *)
#+end_src


**** 4. Application module: API of module that needs to be distributed as an App

This next step describes an example of a module which is intended to be distributable as an App. In Newspeak, *this means such module must be both packageble and runnable* - the roles of "packageble" and "runnable" are achieved by implementing the 2 methods below. We call such modules informally /App modules/.

If we need our module ~RecipyWithDep~ to be packagable as an App:

1. Generally, add a *separate module* with a descriptive name  - to make clear this separate module is an App, end the name with the string 'App'.
2. In this *separate module*, provide the following API:
  - primary factory method ~#packageUsing: manifest~ 
  - Instance method ~#main: platform args: args~

*Note 1:*

We sometimes see Newspeak Application modules lacking the ~#main: platform args: args~ method. Such modules are used as library modules.

*Note 2:*

Compare the parallel role between the following methods for a Library module and an Application module:

| Library module standard method | is              |                                        | Application module standard method | is              |
|--------------------------------+-----------------+----------------------------------------+------------------------------------+-----------------|
| #packageLibraryUsing: manifest | primary factory | - role is instantiate for packaging  - | #packageUsing: manifest            | primary factory |
| #buildUsing: platform          | instance method | - role is build -                      | #main: platform args: args         | instance method |

The primary factory methods for Library and Application have similar names, both serve to package the library or the app on the "source" system.

The instance methods serve to build (for Library) or execute (for App).

If an Application uses a Library, the library's (build) ~#buildUsing: platform~ would be called in the App's ~#main: platform args: args~ method to build (create) the library's instance.

***** Example:

We will create an Application module ~RecipyWithDepApp~, which is a bit more complex App, in the sense it uses a pre-existing library module, ~RecipyWithDep~, defined in [[*3. Library module: API of module that needs to be distributed for use in other modules][3. Library module: API of module that needs to be distributed for use in other modules]].

To create a packageble and runnable Application module ~RecipyWithDepApp~, it must have a primary factory method ~#packageUsing: manifest~ and an instance method ~#main: platform args: args~.  The Application must also store at it's slots everything the ~RecipyWithDep~ needs for it's instantiation. Here is how the code may look:

#+begin_src 
class RecipyWithDepApp packageUsing: manifest = (
  |
  RecipyWithDep = manifest RecipyWithDep.
  RecipyNoDep   = manifest RecipyNoDep.
  |
) 
(
  public main: platform args: args = (
     |revertedTranslator|
     revertedTranslator::  RecipyWithDep 
                    usingPlatform: platform 
                    andModule: (RecipyNoDep new).

    (revertedTranslator translate: {' World'. 'Hello'}) out.
  )
)
#+end_src

Note how the Application stores any "carry along" (imported) classes from the manifest on slots during packaging in the ~packageUsing: manifest~ factory, then instantiate the "carry along" classes in ~#main: platform args: args~ at runtime. For a library, this happ build time). 

Also note when we converted the General module to an App:
  - In the General module ~RecipyWithDep~, the ~platform~ object is passed to the /primary factory method/ ~#usingPlatform: platform:~. 
  - In the Application module     ~RecipyWithDepApp~, the ~platform~ object is passed to the /instance method/ ~#main: platform args: args~.

See the section [[* A recipy to convert a General module to an Application or Library module][A recipy to convert a General module to an Application or Library module]] for a general recipy to convert a General module such as  ~RecipyWithDep~ to an Application such as ~RecipyWithDepApp~.

Also note, as you add the Application class ~RecipyWithDepApp~ in the IDE, (using the "+ " button ), the IDE shows  *[deploy] [configurations] [run] [debug]* links beside it, recognizing the top level class as an App. 


**** TODO 5. Test module: TODO 

**** TODO 6. Test module configuration: TODO 


** Hello World in Newspeak - several versions

*** Section Summary

This section will show several versions of a 'Hello World' program in Newspeak.  Each version uses a different method.  The initial versions are due to Gilad Bracha's answer on the Newspeak group https://groups.google.com/g/newspeaklanguage/c/Cq2Ej0_THew

All Hello World programs are created by starting the Newspeak online IDE at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel, then following the steps.


*** 1. Hello World from Workspace

Workspace is like the command line or REPL in Newspeak.  We can send 'Hello World' from there as a ~String>>#out~ message.

Steps to run Hello World from Workspace 

- Open Workspace
- Type there (including quotes) ~'Hello World from Workspace' out~
- Select the text 
- Press "Shift+Enter" - this takes the selected text and evaluates it's expressions.  The single expression is the message ~#out~ send to the string object.  
- Notice that 'Hello World from Workspace' appears both right below the line, and also at the bottom of the page.  The text at the bottom of the page was appended at the end of the DOM.  We will see text showing at the bottom of the page again in all non-Application examples.

[[file:img/newspeak---a-few-notes.org-hello-world-workspace.png]] 


*** 2. Hello World from general module

TL;DR: In this section, we will build a Hello World which is a /module/ (an /instance of top level class/ as we know already).  The code for this module is already in https://github.com/mzimmerm/newspeak-doc/tree/main/newspeak---a-few-notes-code/hello-world/2-as-general-module.  To skip the coding details above, we can download the ~.ns~ file(s), then [[compile-files]["Compile file(s)"]] to load the fully finished code from there; the loaded class will appear in the IDE.


The [[*Newspeak modules API summary][Newspeak modules API summary]] section would classify this module as "General" module, because it does not have any of the special "convention methods" in it's API.  The only method of this class is it's default /primary factory method/ ~#new~.  

Continuing with the painfully detailed steps to create the Hello World general module in the Newspeak IDE:

- In "Newspeak Source", on the top left, click the "+ " button next to the link "Root" 
- In the popup, select "Add Class"
- Replace the text under "Defining a new class" with
  #+begin_src 
    class HelloWorldGeneralModule = (
    (*
     If we Accept this class declaration,
     or if we click on the class link,
     the "Hello World" string shows on the bottom.
      - How did it get there?
        - After click on the class link, the IDE prepares some things to present the class.  In the IDE, the class is presented inside an instance of the class.  So, the IDE creates an instance of the ~HelloWorldGeneralModule~, by invoking the implicit ~HelloWorldGeneralModule>>#new~ primary factory method.  The method body is executed, calling ~'Hello World ' out~.  ~#out~ is a method on String; it is implemented in the Wasm version to append a ~<div>'Hello World '</div> element to the IDE's HTML document body, thus displaying the string at the end of the IDE's page.
        - Similarly, every time just click on the > expand action to the left of the class name, a new instance is created by the IDE, causing one more 'Hello World' to appear.
    *)
    
    'Hello World ' out
    ) (
    ) : (
    )
  #+end_src
  
- Click the "Accept" [[file:img/newspeak---a-few-notes.org-accept-image.png]]
- Now the class link "HelloWorldGeneralModule" will appear in the list of classes
- Click on the class link, and the class presented appears
  [[file:img/newspeak---a-few-notes.org-hello-world-general-module-class-viewer.png]]
- What happened?
  - First of all the "Hello World" shows on the bottom again.
  - How did it get there?
    - After click on the class link, the IDE prepares some things to present the class.  In the IDE, the class is presented inside an instance of the class.  So, the IDE creates an instance of the ~HelloWorldGeneralModule~, by invoking the implicit ~HelloWorldGeneralModule>>#new~ primary factory method.  The method body is executed, calling ~'Hello World ' out~.  ~#out~ is a method on String; it is implemented in the Wasm version to append a ~<div>'Hello World '</div> element to the IDE's HTML document body, thus displaying the string at the end of the IDE's page.
    - Similarly, every time just click on the > expand action to the left of the class name, a new instance is created by the IDE, causing one more 'Hello World' to appear.
      [[file:img/newspeak---a-few-notes.org-hello-world-3-times-after-body.png]] 
    
This concludes the section on General Module class.  Before the next step, please reload the page, and select the third option to start fresh.  Alternatively, remove the class ~HelloWorldGeneralModule~.  It's presence would repeatedly output "Hello World" at the end of the page body.  Class deletion can be done by clicking on the three dot popup menu  beside the classname, and selecting "Remove HelloWorldGeneralModule"
[[file:img/newspeak---a-few-notes.org-remove-class-from-3-dot-menu.png]]

For a more complex example of a general module, see [[*1. General module with NO dependencies: API of module with no dependencies][1. General module with NO dependencies: API of module with no dependencies]]


*** 3. Hello World from Application

TL;DR: In this section, we will build another Hello World version which is a full blown but rudimentary Newspeak Application.  The code for this module is already in https://github.com/mzimmerm/newspeak-doc/blob/main/newspeak---a-few-notes-code/hello-world/3-as-app/HelloWorldApp.ns.  To skip the coding details above, we can download the ~.ns~ file(s), then [[compile-files]["Compile file(s)"]] to load the fully finished code from there; the loaded class will appear in the IDE.

We now create a class that behaves as a Newspeak Application (as opposed as a general module in the previous section).  We need to give the module class two specific "convention methods" described in the sections [[*Newspeak modules API summary][Newspeak modules API summary]] and [[* Newspeak modules API zoo][Newspeak modules API zoo]].

Here are the steps to create the ~HelloWorldApp~ *Application* in the Newspeak IDE's
 
- As shown in the previous section, click the "+ ", paste the following class to the IDE, and click the "Accept" button.
  #+begin_src 
    class HelloWorldApp packageUsing: manifest = () (
      public main: platform args: args = (
        (* 
        - In the IDE, we should see this class in the top classes list.  However, (as opposed to previous example ~HelloWorldGeneralModule~), this class has the links *[deploy] [configurations] [run] [debug]* beside it.  This shows as a result of the presence of the convention ~#packageUsing: manifest~ factory method.  The tools (the IDE) understand this message and use it to show actions that can be done with an App: run, debug, deploy, show available configurations.  In addition, the presence of the ~#main: platform args: args~ instance method makes the module runnable as a standalone Application.
        - Click the *[run]* link to run the app inside the IDE.  The IDE calls first the ~#packageUsing: manifest~, then the ~#main: platform args: args~ which runs, and the text 'Hello World from HelloWorldApp' will be appended at the end of the page, as described in  ~HelloWorldGeneralModule~.
        *)
      
        'Hello World from HelloWorldApp' out.
      )
    ) 
  #+end_src
- In the IDE, we should see this class in the top classes list.  However, (as opposed to previous section ~HelloWorldGeneralModule~), this class has the links *[deploy] [configurations] [run] [debug]* beside it.  The links shows as a result of the presence of the convention factory method ~#packageUsing: manifest~.  The tools (the IDE) understand this message and use it to show actions that can be done with an App: run, debug, deploy, show available configurations.  In addition, the presence of the ~#main: platform args: args~ instance method makes the module runnable as a standalone Application. 
- Click the *[run]* link to run the app inside the IDE.  The IDE calls first the ~#packageUsing: manifest~, then the ~#main: platform args: args~ which runs, and the text *'Hello World from HelloWorldApp'* will be appended at the end of the page. This is similar but not the same as in the General module version [[* 2. Hello World from general module][2. Hello World from general module]].  Here, unlike the General module version, the text is NOT appended when clicking on the class link.  That is because, in this Application version, the text ~out~ message is in the ~#main: platform args: args~ method, which runs after clicking the [run] button.  In the General module version, it is in the primary factory, which the IDE runs as it constructs an instance of the class on click. 
  [[file:img/newspeak---a-few-notes.org-hello-world-app-output.png]]


*Next, we will show how to deploy our ~HelloWorldApp~ as a standalone Application.*

From the section [[*Deploy CounterApp as standalone app into local Newspeak webserver]] we know an Application can be packaged and deployed standalone into a local Newspeak webserver.

Follow steps below to create a deployable app ~HelloWorldApp.vfuel~, then deploy it in a local Newspeak installation.

- Action: In the class list, find the ~HelloWorldApp~ again, and click the [deploy] to the right.
- Result: a popup showing deployment options, starting with ~asVictoryFuel~: [[file:img/newspeak---a-few-notes.org-click-deploy-on-counter-app.png]]
- Action: Select ~asVictoryFuel~.  We choose the faster option 'asVictoryFuel' because our Application does not have GUI.  Otherwise, we would select 'asVictoryFuelWithMirrors'
- Result: After a long wait, a file named ~HelloWorldApp.vfuel~ is created, and asked to be saved.
- Action: Save the file ~HelloWorldApp.vfuel~ on our disk to the directory where local Newspeak was deployed - for example ~$HOME/software/newspeak/my-serve-http/servable~
- Result: *Assuming you installed you local Newspeak webserver as in e [[Download, install, and start a local Newspeak webserver]], the app is now deployed to the local Newspeak webserver!*
- Action: Navigate to http://localhost:8080/primordialsoup.html?snapshot=HelloWorldApp.vfuel
- Result: We see the output of the standalone-running app
  [[file:img/newspeak---a-few-notes.org-hello-world-app-standalone-output.png]]
  
This concludes the section on Application Module class.  We have shown how to create an App, run it in IDE, create a deployable .vfuel file, then deploy the Application standalone in local Newspeak webserver.

For a more complex example of an Application module, see [[4. Application module: API of module that needs to be distributed as an App][4. Application module: API of module that needs to be distributed as an App]]


*** 4. Hello World Application using 3rd party dependency

TL;DR:  This section builds, step by step, a Hello World Application named ~HelloWorldAppUsingLib~. The goal of this section is to show how to *use a 3rd party Library named ~HelloTranslatorLib~ in an application*.  All code is in https://github.com/mzimmerm/newspeak-doc/tree/main/newspeak---a-few-notes-code/hello-world/4-as-app-using-translator-lib-as-3rd-party-dependency.  To skip the coding detailed steps, we can download, then [[compile-files]["Compile file(s)"]] to load the fully finished code; the loaded classes will appear in the IDE. Then you can browse, [run], or [deploy] the Application. Running the Application produces the text translated to German: [[file:img/newspeak---a-few-notes.org-hello-world-with-dependency-german.png]]

But continuing with the step by step process:

Let's pretend our Application wants to use a Newspeak module produced by a 3rd party (3rd party to us). Call the 3rd party the /TranslatorCorp/. Let's pretend /TranslatorCorp/ provides the module ~HelloTranslator~, packaged as ~HelloTranslatorLib~.

/TranslatorCorp/ would implement and package their modules as follows:

#+begin_src 
class HelloTranslator = ()
(
    public translate: text = (
      text = 'Hello World from HelloWorldApp' ifTrue: [^ 'Hallo Welt von HelloWorldApp'.].
      
      ^ 'unable to translate'.
    )  
)
#+end_src

#+begin_src 
class HelloTranslatorLib packageLibraryUsing: manifest = (

    (* Library (distribution) class provides packaging and building of the HelloTranslator module *) 
    | 
    HelloTranslator = manifest HelloTranslator. 
    |
)
(
   public buildUsing: platform = (
     |helloTranslator|
     helloTranslator:: HelloTranslator new.

     ^helloTranslator.
   )
)
#+end_src

Note that for every module the /TranslatorCorp/ wants to distribute (such as ~HelloTranslator~), they need to create a library module for packaging and disctribution(such as ~HelloTranslatorLib~)

The ~HelloTranslator~, hence the ~HelloTranslatorLib~ 
  - could have used (depended on) other module ~HelloTRanslatorHelper~  developed by the /TranslatorCorp/
  - and also depend on a module ~LanguageSelectorLib~ developed by another entity /LanguageCorp/ (so /LanguageCorp/ is "3rd party to /TranslatorCorp/).

Then, the /TranslatorCorp/ would work in their helper module and the /LanguageCorp's/ module as follows:

#+begin_src
class HelloTranslatorLibWithMoreDependencies packageLibraryUsing: manifest = (

  (* This version of HelloTranslatorLib is not ready yet due to missing
     HelloTranslatorHelper and LanguageSelectorLib.
     Use the above version in your IDE experiments
  *)
  | 
  HelloTranslator = manifest HelloTranslator.
  HelloTranslatorHelper = manifest HelloTranslatorHelper.
  LanguageSelectorLib = manifest LanguageSelectorLib packageLibraryUsing: manifest.
  |
)
(
  public buildUsing: platform = (
    |defaultlanguageSelector helloTranslator|

    defaultlanguageSelector = LanguageSelectorLib buildUsing: platform.

    helloTranslator = HelloTranslator
                        helpedBy: (HelloTranslatorHelper new)
                        with3rdPartyLanguageSelector: defaultlanguageSelector.
    (* or #usingPlatform:helpedBy:with3rdPartyLanguageSelector: if platform was needed *)

    ^helloTranslator.
  )
)
#+end_src


Either way, we would develop our Application by packaging the 3rd party dependency and storing it on slot as ~helloTranslatorLib~, then at runtime, build instance of the ~helloTranslator~ using the packaged ~helloTranslatorLib~, and last, calling the method on ~helloTranslator~ which performs the translation:

This is how the Application ~HelloWorldAppUsingLib~ would look. 

#+begin_src 
class HelloWorldAppUsingLib packageUsing: manifest = (
  |
  helloTranslatorLib = manifest HelloTranslatorLib packageLibraryUsing: manifest.
  |
)
(
  public main: platform args: args = (
    |helloTranslator|
    helloTranslator:: helloTranslatorLib buildUsing: platform.

    (helloTranslator translate: 'Hello World from HelloWorldApp') out.
  )
)
#+end_src

As shown in the previous section [[*3. Hello World from Application][3. Hello World from Application]], we can click [run] to run the Application from the IDE, or package it a ".vfuel" file, and distribute to run as a standalone Application from a local Newspeak webserver (or as an Electon based on Android, iOS, or desktop, but this is not shown yet).


*** 5. Hello World Application presenting to DOM using Newspeak binding to DOM

A simple DOM-manipulation in Newspeak.

Load and run the application https://github.com/mzimmerm/newspeak-doc/blob/main/newspeak---a-few-notes-code/hello-world/5-as-general-module-to-dom/HelloDOM.ns

This version, when run, completely replaces the body of the IDE page with a formatted Text of the Application.


This concludes the 'Hello World' sections, as well as the broader section [[*Newspeak: An ide-driven journey leading to Hello World][Newspeak: An ide-driven journey leading to Hello World]].


* Newspeak: Using it online or installing it locally

TL;DR There are several ways of using Newspeak:
- Using Newspeak online web version from browser.  No installation required, see [[install-method-1][Installation method 1 (online, no local installation)]]
- Using Newspeak locally from browser, after installing your local Newspeak webserver, see [[install-method-2][Installation method 2 (local Newspeak webserver)]]
- Using Newspeak on desktop or as a mobile App, see [[*System specific methods to install and run Newspeak][Chapter System specific methods to install and run Newspeak]].  This includes installing and using an Electron-based version in [[install-method-4][Installation method 3]].

This section is describing all usage ways and installation methods.  Initially, users should consider either [[install-method-1][Installation method 1 (online, no local installation)]] or [[install-method-2][Installation method 2 (local Newspeak webserver)]].

In this hands-on document we use the Newspeak online version for most chapters; when describing installable Apps, we use the local Newspeak webserver. 

** Simple methods to install and run Newspeak

*** <<install-method-1>> Installation method 1: No installation or setup, run Newspeak online

TL;DR: This section describes the simplest setup - in fact, this is a "no setup, no installation" method.  We only need a browser and internet access.  This is the recommended method to start with Newspeak.

- Action: Navigate your browser to Newspeak online at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel, 
- Result: You should see a page similar to this

[[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]


Notes:

- By using this page, you are now using the Newspeak IDE
- click the "Newspeak Source" link to view code, edit edit code and manipulate code.
- Your changes will be stored in the browser local storage.
- A more detailed description of what we can do with Newspeak is in the introduction section [[Run the online version of the Newspeak IDE.  Read docs, watch videos]]  


*** <<install-method-2>> Installation method 2: Download and start a local Newspeak webserver

This method downloads a pre-packaged Newspeak, and allows you to start your local Newspeak webserver, which starts the pre-packaged Newspeak.  This method is described in detail in the "hands on" section [[Download, install, and start a local Newspeak webserver]].  Follow the steps there.

Differences of this installation from using Newspeak online described in [[install-method-1][Installation method 1 (online, no local installation)]]
- If we install using this method 2 (local Newspeak webserver):
- Pros:
  - No need for internet access
  - Your version does not change if you need stability (this may be a cons too)
- Cons:
  - We have to run our own Newspeak server, and reinstall to care of any updates or bugs fixed.


*** <<install-method-3>> Installation method 3: Download or setup a local Electron version of Newspeak on MacOS or Windows

To install using this method, download the available versions for Windows and Mac, see https://newspeaklanguage.org/downloads.html, section "Downloadable IDE App". 

Electron is basically Chromium underneath.  It's just set up to read from a page that's built in to the app.  So no server needs to be started.  It starts with starting the app.

An advantage of Electron that I have seen is a better integration with OS File access dialogues.  It doesn't insist on using a downloads directory for everything (and while browsers let you set the directory, they don't let you change it on the fly, on a file-by-file basis).


** System specific methods to install and run Newspeak 

*** <<install-method-4>> Installation method 4: Setup a local Newspeak webserver from code on Github.

This method is described in the "Just in Case" section in https://github.com/newspeaklanguage/newspeak.


*** <<install-method-5>> Installation method 5: Manual setup which will produce an equivalent of [[install-method-2][Installation method 2 (local Newspeak webserver)]]

As this method produces an equivalent that is already downloadable, this is only if we want to dig in more details, but not going all the way to doing all the steps in [[install-method-4][Installation method 4]].

If the build isn't working for you there is one option that hasn't been discussed, which is relevant to Linux folk who don't have an Electron app.  You can get the web IDE vfuel file at:

https://newspeaklanguage.org/samples/HopscotchWebIDE.vfuel 

BUT ...  this isn't enough because you need a bunch more stuff, such as primordialsoup.html, primordialsoup.js, primordialsoup.wasm.
If you run that, you'll find that you also need a longish list of .png files for the various images used by the IDE.  Here they are (probably a few that are no longer used too).

accept16px.png				hsHistoryDownImage.png
accept16pxDown.png			hsHistoryImage.png
accept16pxOver.png			hsHistoryOutImage.png
arrowGreenLeft.png			hsHistoryOverImage.png
arrowGreenRight.png			hsHomeDownImage.png
arrowOrangeLeft.png			hsHomeImage.png
cancel16px.png				hsHomeOutImage.png
cancel16pxDown.png			hsHomeOverImage.png
cancel16pxOver.png			hsNewDownImage.png
classPresenterImage.png			hsNewImage.png
classUnknownImage.png			hsNewOutImage.png
clearImage.png				hsNewOverImage.png
conflictRed.png				hsRefreshDownImage.png
disclosureClosedImage.png		hsRefreshImage.png
disclosureMinusImage.png		hsRefreshOutImage.png
disclosureOpenImage.png			hsRefreshOverImage.png
disclosurePlusImage.png			hsReorderDownImage.png
disclosureTransitionImage.png		hsReorderImage.png
downloadImage.png			hsReorderOutImage.png
editImage.png				hsReorderOverImage.png
findImage.png				hsToolsDownImage.png
findSquareLeftDownImage.png		hsToolsImage.png
findSquareLeftImage.png			hsToolsOutImage.png
findSquareLeftOutImage.png		hsToolsOverImage.png
findSquareLeftOverImage.png		itemBothOverride.png
helpImage.png				itemDeleteImage.png
hsAddDownImage.png			itemMenuImage.png
hsAddImage.png				itemReferencesImage.png
hsAddOutImage.png			itemSubOverride.png
hsAddOverImage.png			itemSuperOverride.png
hsBackDownImage.png			languageJS.png
hsBackImage.png				languageM.png
hsBackOutImage.png			languageNewspeak3.png
hsBackOverImage.png			languageSmalltalk.png
hsCollapseDownImage.png			menu16px.png
hsCollapseImage.png			menu16pxDown.png
hsCollapseOutImage.png			menu16pxOver.png
hsCollapseOverImage.png			menuButtonImage.png
hsDropdownDownImage.png			metaMenuDownImage.png
hsDropdownImage.png			metaMenuImage.png
hsDropdownOutImage.png			metaMenuOutImage.png
hsDropdownOverImage.png			metaMenuOverImage.png
hsExpandDownImage.png			operateMenuDownImage.png
hsExpandImage.png			operateMenuImage.png
hsExpandOutImage.png			operateMenuOutImage.png
hsExpandOverImage.png			operateMenuOverImage.png
hsFindDownImage.png			peekingeye1610.png
hsFindImage.png				privateImage.png
hsFindOutImage.png			protectedImage.png
hsFindOverImage.png			publicImage.png
hsForwardDownImage.png			repositoryGit.png
hsForwardImage.png			repositoryMercurial.png
hsForwardOutImage.png			saveImage.png
hsForwardOverImage.png			tinySubclassResponsibilityImage.png

You can place it all in the directory of your choice and serve from there (the serve.sh script wants it in the repo, in the out directory).
It seems easier to build, but I'm putting it out there.




* Newspeak: Script which builds deployable vfuel files

TL;DR: This section provides a script which builds both the Wasm VM and deployable ~.vfuel~  files from source ~.ns~ files (builds ~.vfuel~ files for any Newspeak application as well as the NewspeakIDE, called ~HopscotchWebIDE.vfuel~).  All ~.vfuel~ files are created in Step 7 of the script. Step 7.  Step 7 is typically run any time we make a code change in a Newspeak ~.ns~ file and want to redeploy it.

** Script to build ~.vfuel~ files for Newspeak IDE, and any Newspeak app

The script in this section installs software packages, which enable building ~.vfuel~ deployable files from source ~.ns~ files (for the Newspeak IDE, as well as tools, and any Newspeak app).

*Warning: This script should NOT be run directly, it should be used as a step-by-step process followed manually.  Running portions of this script, or in full, as any user WILL OVERRIDE files in the ~$HOME/software/emsdk~ and ~$HOME/software/newspeak-wasm-build~ directories. In addition, if the user is "root" on OpenSUSE, it will, install some ~gcc~ ~gpp~ or ~c++~ libraries.*

*Steps 1. to 6. are one-time (provided they succeed). They provide prerequisits, then build the "primordialsoup" - the executable VM for Newspeak. Primordialsoup is used in step 7 to compile the Newspeak source ~.ns~ files into the browser-loaded ~.vfuel~ extension files.*

*Step 7. is intended for repeat. It runs the ~newspeak/build.sh~, which creates deployable ~.vfuel~ files. It should be run any time we make a code change in any Newspeak ~.ns~ file and want to redeploy it as ~.vfuel~.  For example, if we creats a Newspeak app we want to deploy, run only this step.* 

#+begin_src bash

    ## 1. Prerequisits: This script downloads projects from github. For this script to work, we need:
    #    1.1. A github account with our ssh public key downloaded.
    #    1.2. The shell session's ssh keyring loaded with corresponding ssh private key;
    #         for example, this can be done as follows:
    #            $ ssh-add ~/.ssh/milan.zimmermann_at_gmail.com_id_rsa\:generated-by-ssh
    #    Notes:
    #    1.3. The ~primordialsoup/SConstruct~ is the configuration file for
    #         the scons ~build~ used in primordialsoup.
    #
    #

    ## 2. Installing emscripten from github into the directory assumed by primordialsoup/build.
    #     If you have emsdk in a different directory, you have to change this, and also primordialsoup/build.

    # Assuming this directory for Emscripten SDK
    EMSDK_HOME=~/software/emsdk

    # Cloning emsdk which creates the emsdk directory
    mkdir --parent $EMSDK_HOME
    cd $EMSDK_HOME/..
    git clone https://github.com/emscripten-core/emsdk.git

    ## 3. Creating the directory structure for the Newspeak Wasm build,
    #     and cloning Newspeak and PrimordialSoup from github

    # Assuming this directory for the Newspeak build
    NEWSPEAK_WASM_BUILD_DIR=$HOME/software/newspeak-wasm-build
    mkdir --parent $NEWSPEAK_WASM_BUILD_DIR
    cd $NEWSPEAK_WASM_BUILD_DIR

    # Cloning newspeak and primordialsoup github, which creates
    #   directories newspeak and primordialsoup
    git clone git@github.com:newspeaklanguage/newspeak.git
    git clone git@github.com:newspeaklanguage/primordialsoup.git

    # Checking out the appropriate branch from primordialsoup
    cd primordialsoup
    git checkout extraRevs

    ## 4. Downloading CodeMirror in the top directory of newspeak
    cd $NEWSPEAK_WASM_BUILD_DIR
    cd newspeak
    curl https://codeload.github.com/codemirror/dev/zip/refs/heads/main/dev-main.zip  --output dev-main.zip
    unzip dev-main.zip # creates dir dev-main
    mv dev-main CodeMirror

    ## 4. Installing Opensuse specific libraries supporting the primordialsoup 32 bit build

    zypper install -t pattern devel_basis   devel_C_C++   32bit # !! but maybe we need 32bit-devel which does not exist? So more added below
    zypper install glibc-32bit glibc-devel-32bit glibc-devel-static-32bit glibc-locale-base-32bit glibc-profile-32bit
    zypper install gcc-32bit gcc-c++-32bit


    ## 6. Building primordialsoup using "build". This creates the "out" directory.
    #     If we encounter errors during build, other OS-level packages may need
    #     to be installed, depending on your distro.

    cd $NEWSPEAK_WASM_BUILD_DIR/primordialsoup
    ./build

    ## 7. Building newspeak using "build.sh". It places output in the "newspeak/out" directory.
    #
    #     Running the ~build.sh~ builds the psoup VM as well as deployable ~.vfuel~ file
    #     for each app listed in ~build.sh~.  
    #     Currently listed in ~build.sh~ are the Newspeak IDE, the CounterApp, and a few more. Add your app there.
    #    
    #     This step 7. is typically run any time we make a code change in any Newspeak ~.ns~ file and want to redeploy it.
    #     For example, if we code a Newspeak app which we want to deploy, we run this step.

    cd $NEWSPEAK_WASM_BUILD_DIR/newspeak
    source ./build.sh

    # Error: bash: RuntimeForCroquet: command not found

    # HopscotchWebIDE.vfuel should now exist in the ./out subdirectory of the newspeak repository.

    # You can access it by running a web server, using the serve.sh script:

    # source serve.sh


#+end_src


* IN-PROGRESS Programming in Newspeak

** The Newspeak IDE

*** Updating the IDE

How to update the IDE? The answer differs depending on what version you are using.

**** Updating the online version

If you use Newspeak as online from https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel, no updating is necessary.  If a newer version is installed online, a reload will update.

After the update, the system will ask user if to re-apply your browser-local storage changes from the /backup/ and /lastSaved/.  For details of the local changes re-application, see [[*Saving changes in Newspeak][Saving changes in Newspeak]].

**** Updating your local Newspeak webserver, installed for all platforms as shown in [[install-method-2][Installation method 2 (local Newspeak webserver)]].

To update your local Newspeak webserver to the latest (thus getting fixes done since the last deployment), re-download and unzip as described in [[* Download, install, and start a local Newspeak webserver]]


*** Updading a single class that was fixed on Github source into local Newspeak webserver (thus IDE)

Could there be situations we do not want to simply reinstall the local Newspeak webserver? Perhaps one example of such situation is that we run our local Newspeak webserver with changed files, and we want to patch a class that has a known fix, without reinstalling the local Newspeak webserver and losing changes.

To describe a concrete (somewhat artificial) situation: Let's say that on Github, there is a bug fix or change in a 'system' class, ~Browsing.ns~, and we want to update this single class locally.  We can identify changed files or files with fixes, and compile them in (that is, start using them in) the local version, using the following process:
  
- Look for files committed on Github. 
- Find files changed since your last local install - let's say file ~Browsing.ns~ changed today to fix a bug.  As your local server uses the servable.zip file, ~Browser.ns~ is already compiled in your local vfuel.
- So from the browser IDE, http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel from the 3-dot I "compile" the new version of Browsing.ns 
- Save the changes from IDE (clicking the save diskette image)
- You can confirm that your changes were "Compile"d, by exporting of Browsing.ns (click the "Save to file" button to export the code).
- The result of the above process is your local server are now using the github-fixed ~Browsing.ns~.
  



** Saving changes in Newspeak

TL;DR: Changes can be saved either /inside the browser/ in the browser's local storage, or, /outside the browser/ on the filesystem.  Any changes you make (for example: you add a class, change a class, evaluate something in the workspace) are stored in the browser local storage in two entries: *lastSaved* and *backup*.  Clicking the "Accept" button  [[file:img/newspeak---a-few-notes.org-accept-image.png]] saves the changes in the local storage under the key /backup/, while clicking the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], at any time after "Accept", saves the changes under the key /lastSaved/.  Alternatively, you can `export` code by clicking the "three dot menu" button to the right of the class, then clicking the "Save to file" item in the popup menu.  You can `import` code back to the browser IDE by clicking the "three dot menu" on the top, to the right of "Root +", then selecting the "Compile File(s)" in the popup menu.

*** Saving changes inside the browser

How is the browser local storage handled, and how is /lastSaved/ different from /backup/? Here is a detail description of how changes are saved and restored:

- After making any code change or addition, to keep your changes, you have to click the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]].  Clicking "Accept" saves the changes in local storage under the key /backup/.
- while
- Clicking the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], at any time after "Accept", saves the changes under the key /lastSaved/ (the changes under /backup/ are added and merged in to the changes under /lastSaved/).  Once saved using the "Save" button, changes are stored "forever", unless you reset browser local storage for the site.  We need to clarify, that making a change, followed by just clicking "Save" without a previous "Accept", nothing is saved.  So "Accept" and "Save" are sort of like two phase commit.
- You can view the changes made, in the browser debugger.  For example, in Chrome or Chromium:
  - Press F12 to open Chrome debuger. 
  - Then click the "Application" tab.
  - In the "Storage" section expand "Local Storage".
  - You can see our changes in the appropriate URL, both under the key /lastSaved/ and the key /backup/.

- How does the/lastSaved/ and /backup/ system work on browser restart? On restart, the Newspeak system checks to see if there are any changes under the key /backup/ and/or under the key /lastSaved/.  If /lastSaved/ changes exists, Newspeak checks if there are any subsequent changes under /backup/.  If not, we use the /lastSaved/ version.  If there are unsaved changes (/backup/ entry is not empty), a dialog will come up asking you how to proceed:  [[file:img/newspeak---a-few-notes.org-message-restore-from-backup.png]]
  - This message tells us, we did make code changes, then clicked "Accept" [[file:img/newspeak---a-few-notes.org-accept-image.png]], without pressing "Save" [[file:img/newspeak---a-few-notes.org-save-button.png]], and reloaded the page.  In other words, changes are stored under the key /backup/ but not(yet) under /lastSaved/.  In most situations, pressing *Restore from backup* is the best choice.  Your code will load the changes from the /backup/ key, and contain all your changes.  At any time, you can click "Save" and merge the /backup/ changes to /lastSaved/.  After, the question above will not be asked until you made new changes and "Accepted" them.
  - For search purposes, here is the text of the message: "You have backup changes that are newer than your last save.  Do you want to restore these changes, or load from the last save?"

- Note: There is a fine point we should make.  Crudely, we can say that "the Newspeak IDE is the file ~HopscotchWebIDE.vfuel~ interpreted by the browser when pointing to the URL https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel.  However, we need to realize that the browser immediately downloads and caches this file.  Changing anything in Newspeak (adding a class, typing to the Workspace), causes the changes to be saved locally.  If we close the browser, and visit the same online URL again, we will see the site as we left it - with the local changes "added" to the vanilla Newspeak IDE! Which local changes are "added" (/backup/ or /lastSaved/ or both), is determined by your answer to the dialog above.

- Caveats: There are a few caveats - a few classes are exempt from this "backup" and "lastSaved" method, due to bootstrap issues (things like KernelForPrimordialSoup and HopscotchWebIDE).  If you tamper with these - save the class explicitly! Also, web storage can surprise you on mobile platforms, where things can be thrown out after a certain amount of time (7 days on iOS?) and the system as a whole may exhibit bugs.

*** Saving changes outside the browser as text files

During development, any code additions and changes we make, are saved in-browser in the browser local storage, as described in [[* Saving changes inside the browser]]. But if we do clear the browser local storage, our changes will be lost.  While the browser local storage can be backed up as part of browser configuration, restoring it is cumbersome.

Consequently, saving our work (/source code/) outside the browser as text files is valuable.

*Current approach to saving our work during development (as text files)*

Until source control is integrated into the IDE, the current approach is to `export` ("Save to file") each class we changed into a directory on your system as a file with ~.ns~ extension.  We can also create a code repository in the directory with the ~.ns~ files.  

How For how to access the "Save to file" and "Compile File(s)" buttons, see TL;DR in section [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]]

Note: To 'import' the saved text ~*.ns~ files back to the Newspeak IDE, click on the "Compile File(s)", as also described above.


** Exemplars: Enabling liveliness everywhere

What are "examplars"? Exemplars are Newspeak code examples, placed inside comments.  Their role is to provide live code for browsing, as well as document typical use of a class and it's methods.

*** Exemplars motivation

We often ask "how is this class used"? "What is the result of calling one of it's methods"?  Answer can be provided by any of the following mechanisms:

- Reading the class code and deriving a result (in our head).
- Finding a test for the class and the method and analyzing it's code and results.
- Writing a simple example program using the class and method.  In Smalltalk and Newspeak, this is done by navigating to "Workspaces" and writing some code - instantiating the class, passing it's factory some arguments, and calling the method you are interested in.
- *Exemplars provide a class-author supplied mechanism to instantiate the class and run it's methods, as if a user was doing that in the Workspace*


*** Exemplars documentation

Gilad Bracha's blog post https://blog.bracha.org/exemplarDemo/exemplar2021.html?snapshot=BankAccountExemplarDemo.vfuel

Gilad Bracha's BankAccount video https://www.youtube.com/watch?v=qKWPSvcF0zA


*** A class with an exemplar

A class with exemplar can be found at [[https://github.com/newspeaklanguage/newspeak/blob/master/BankAccount.ns][BankAccount]] in Newspeak sources.

There are three exemplars in the code

#+begin_example
(* :exemplar: BankAccount balance: 100 *)
(* :exemplar: deposit: 100 *)
(* :exemplar: withdraw: 100 *) 
#+end_example

From the source and the pulled comments, we can see that an exemplar is a piece of metadata inside comments. The metadata is expected to be valid Newspeak code after the text marked as ~:exemplar:~.

We can also guess that the ~:exemplar:~ code provides a way to instantiate the class and run some methods on it - basically mimicking what we would do in a workspace if we wanted to explore the class instance's behavior.

From the source we can also see the ~:exemplar:~ comment is placed before the ~=~ sign in a factory or method declaration - that is the only place where the parser is looking for exemplars. 

#+begin_example
class BankAccount balance: b <Integer>
(* :exemplar: BankAccount balance: 100 *) = ( .. factory code .. )
#+end_example

To make the :exemplar: stand out more, we can format the code so that the comment with exemplar occupies it's own line. The formatting above is "normative" though.

#+begin_example
class BankAccount balance: b <Integer>
(* :exemplar: BankAccount balance: 100 *)
  = ( .. factory code .. )
#+end_example



*** Exemplars role

The role of exemplars is two-fold:

1. Provide lively code in the IDE. By adding appropriate exemplars for a class, the IDE, when browsing the class, will use the exemplars code to create the class instance. Once an instance exists, it can call methods on it.
2. Provide code examples of class instantiation and running it's methods.


*** How does the BankAccount class look in the IDE with and without an exemplar?

If a class such as the ~BankAccount~ provides exemplars (at least an exemplar for the primary factory method), *an instance of the BankAccount is presented in the IDE UI; the BankAccount class presenter is also shown, embedded in the instance*. 

Inclusion of an exemplar allows the IDE to create a live instance, present it's browser, and allows the user to interact with the live instance.

If a class such as the ~BankAccount~ does not provide exemplars, *only the BankAccount class presenter is shown in the IDE UI*. See the section below.


**** BankAccount class with an exemplar in the IDE

Viewed inside the IDE, a class that provides an exemplar:

[[file:img/newspeak---a-few-notes.org-class-with-exemplar.png]]

The line on top, starting with *self   instance of BankAccount* is the beginning of the object presenter. The presented object is the object the IDE created using the code in the ~:exeplar:~  (s).

The line with the blue link to *BankAccount* (after the line with *class*) is the beginning of the class presenter section, embedded in the object presenter. The class presenter section ends just above the line *Evaluate Selection*. 

We can see that the *IDE UI presents the instance of the BankAccount, with the BankAccount class presenter embedded*. That places the emphasis on liveliness: The IDE user can experiment with the instance behavior inside the "Evaluate Selection" mini-workspace. An example of such experiment:

1. In the workspace, type ~deposit: 20~ - a method name, and pass it a value.
2. Use the key Ctrl-A to highlight the code (This is browser specific, the Mac key for highlight would be different)
   [[file:img/newspeak---a-few-notes.org-class-with-exemplar-invoke-method.png]]
3. Use the key Shift-Enter to execute the message send. The IDE sends the message ~deposit: 20~ to the instance created by the IDE using the  code in the ~:exemplar:~, which immediately updates the value of ~balance_slot~ from 100 to 120.
   [[file:img/newspeak---a-few-notes.org-class-with-exemplar-invoke-method-shift-enter.png]]


As we can see, exemplars help to focus to browse instances and experiment with them by sending messages.

We can still browse the classes - in our case the BankAccount class, by clicking on it's link.

[[file:img/newspeak---a-few-notes.org-class-with-exemplar-class.png]]



**** BankAccount class without an exemplar in the IDE

To show the contrasting example, this is how the same class looks in the IDE after removal of the ~:exemplar:~ sections

[[file:img/newspeak---a-few-notes.org-class-without-exemplar-class.png]]


We can see only the class viewer is presented in the IDE (NOT the embedding object browser).

We could still experiment with the BankAccount, but we have to go to Workspaces, or find if a test for the class and methods exists.


*** More details on exemplars

This section is edited from the Google Groups posts around https://groups.google.com/g/newspeaklanguage/c/cPG5Q6NOwiA/m/fSuol8w_AQAJ

**** The presence of an exemplar factory makes the IDE to create the instance and show the instance browser

In the BankAccount video https://www.youtube.com/watch?v=qKWPSvcF0zA, if the exemplar on the primary factory method 
~#balance: b~ was missing, the exemplar instance would not even be shown in the IDE?

Correct. If there isn't an exemplar for self, the method exemplars cannot work.


**** Can there be multiple exemplars in a comment?

There can in fact be multiple exemplar comments. An exemplar comment is one whose identifer (the name given between colons in the tag at the beginning of the comment) starts with #exemplar.

For example, we can define a method #foo:

#+begin_example
  public foo: x (* :exemplar_1:  foo: 3 *) (* an random comment *)  (:exemplar_2: foo: 'a' *) = (^x)
#+end_example

In that case, the Debug button will provide a menu of the two exemplars.
 

**** Are the exemplars always extracted from the comment before the " = (..)" section defining the primary factory method, instance method or class method, OR can they be at any position in the code?

Exemplars must be placed before the method body starts (or for classes, before factory body starts).

For a concrete example, let us look at this pseudo-code of primary factory method ~balance: b~, see markings with <== on the right

#+begin_example
class BankAccount balance: b <Integer>
(* :exemplar: BankAccount balance: 100 *) = ( (* <== This, and only this location is parsed for exemplar *)
	|
    balance_slot <Integer> ::= b.
	|
  (* :exemplar: BankAccount balance: 200 *) = ( (* <== This would NOT be parsed for exemplar *)
) (
)
#+end_example

Exemplar comments are just an instance of the general notion of metadata comments. You can have metadata comments everywhere, but there are general rules for what AST node a metadata comment applies to. Metadata must apply to the correct AST nodes. The mirror system looks for metadata  for methods and classes in these places. You can look at the methods #metadata and #parseMetadata in MethodMirror and ClassHeaderMirror, to see how this works; also the class MetadataParsing.



**** Examplars using block and value: How would an examplar for a more complex object look like?

How do examplars look in general (for factories or methods), if a parameter is a "complex" object? ( rather than an object for which we can create a literal (Number, String, Boolean, List of the above etc) directly in the :examplar: text like in the BankAccount)

I know the second question is open,  but I am now curious how such exemplars are done. I can imagine if a parameter can be constructed from literals, then we just provide those parameter constructions as part of the exemplar. But if it goes deeper?

You may indeed need to build up the object from multiple parts, much as you might do in the #main:args: method of an application. You would want to define local variables for intermediate results etc.  So you write all this code in a block and call value on it:

#+begin_example
class Complicated usingPlatform: p with: s  (* :exemplar: [ | T1 = SomeClass usingPlatform: platform. T2 = AnotherClass with:T1. Complicated usingPlatform: platform with: T2] value *) =  ( .. code here .. )
#+end_example


**** What is the purpose of the exemplar on the primary factory method?

Primary purpose of the exemplar on the primary factory method is to provide an instance for life evaluation in the IDE.

Generally, the exemplar on the primary factory method would call the primary factory method (to get us an instance and also document the signature), BUT this is not always the case.

The overriding purpose of such exemplar is to get an instance whichever way possible, such as getting an instance from the Platform object or from the Ide object.  On top level classes, which expect platform or ide as an argument, such example would be circular.  So, for example, many top level classes have exemplars like this:

#+begin_example
  class CollectionsForPrimordialSoup usingInternalKernel: ik (* :exemplar:  platform collections *) = ( .. slots ..)
#+end_example

#+begin_example
  class Namespacing usingPlatform: p (* :exemplar:  ide namespacing *) = ( .. slots .. )
#+end_example

#+begin_example
  class TextModule usingPlatform: p <Platform> (* :exemplar: platform text *) =  ( .. slots .. )
#+end_example

#+begin_example
class Debugging usingPlatform: platform ide: ide (* :exemplar: ide debugging *) =  ( .. slots .. )
#+end_example

These examples show how to get an instance from the platform, the ide, or similar object available in the IDE.

Note: In fact, whether to use this style is still an open question. Do we want the exemplar to be the same object we use in the system, or a distinct copy? What semantic effects might we see in either case as the user experiments with the exemplar?
Using the IDE's own instance makes the system more live, but may allow users to easily shoot themselves in the foot. It was just the easiest thing to do right now. It also has exposed a bug. Changing methods in this case seems to have no effect, unclear why yet.

**** The examplars are evaluated "as if in a Workspace"

The IDE is the metadata interpreter for exemplar comments, and it uses the same namespace similar to what it creates for workspaces to evaluate them.
 
This ~namespace~ includes top level classes in the root namespace (Root) as well as things like platform and ide, sort of like the

~manifest object + platform object + ide object~

The exact mechanism used right now is that Workspace has a number of methods like #ide, #platform and others, and has a  #doesNotUnderstand: method that looks up names in the root namespace. The code for it looks like this:

~WorkspaceManager>>Workspace>># doesNotUnderstand: message~
#+begin_example
protected doesNotUnderstand: message = (
	^Root
		at: message selector
		ifAbsent: [super doesNotUnderstand: message]
)
#+end_example

So calling in Workspace (to be exact, in an instance, e.g. workspace1)

~workspace1 ide~

returns (via *ide selector -> 'HopscotchWebIDE'*)

~Root at: 'HopscotchWebIDE'~


** Access control and access modifiers in Newspeak

*** Introduction

This section describes access control in Newspeak.

The main backround source for this section is the online presentation [[https://00463064267054129163.googlegroups.com/attach/16b8a25058caa/ns-access-control.pdf?part=0.1&view=1&vt=ANaJVrHvttkWPn-fNP95UFKbcCbbp1VaDJlJSx1HzBevq_xhafVpZ4uz1ffKMTvkAxLFnAk2_xurwU-BTi3FIMnPj1FlU7-S-zKgS2y2eNXheQQsxM8mJUY][Can Beautiful Languages Do Access Control?]].  The text here is based on and borrows from the above, but may introduce terminology that is not part of the presentation.

Access control is a set of rules for class and object members (accessed items).

The access control rules decide whether an expression (a line of code), will be accessible (can be executed) at runtime.

The rules take into account 

1) Access modifiers "private" "public" and default (protected) on the accessed items; 
2) Wheather the accessed items are declared in the same class, nested class or enclosing class of the expression for which the rules evaluate access. In other words, access control rules interact with the lexical structure (nesting) of the classes involved: classes where the code is located, in relation to the classes which are used in the code. 
3) Whether the accessed items are declared in the same class or an inherited class. In other words, access control interacts with inheritance.

Clearly, access control rules are not trivial.  This section attempts to explain them, and provide some practical examples.


*** Access control context, description and terminology

Every expression in Newspeak is a message send.  So let us describe what is meant by the term "Access" or "Access rights" of objA to access objB or objA to send message msg to objB.

- Newspeak classes can be nested and also inherited.
- Newspeak classes can have the following *members*: *slots, methods, nested classes*. 
- Each /member/ may have access modifiers keywords: public, private. No modifier means protected.
- "Access control" describes how objects can access ("have the access rights to") other objects and other objects' members.
- The access rights are determined by rules which navigate in three independent "dimensions"
  - The "accessibility dimension": Points on this dimension are access modifiers: public, private, protected (default, no keyword)
  - The "lexical dimension" : Points on this dimension are enclosing and nested classes
  - The "inheritance dimension" : Points on this dimension are classes on the inheritance chain
- In a Newspeak's (class based) system of objects, each object may contain slots, methods, and nested classes.
- Because in Newspeak runtime, any operation is a message send, we can speak of the following: 
   - At runtime, in Newspeak's system of objects, object objA may or may not be able to reference (see) another object objB.
   - If objA is not allowed to reference objB, a security exception results. 
   - If objA can reference objB, we say that objA has access (or access rights) to objB. Further, if objA has access to objB, assume there is a method, slot, or nested class named ~memberB~ declared on objB. Even though objA has access to objB, objA still may or may not be able to send the message ~memberB~ to objB (execute ~objB memberB~). If objA has the ability to send message msg to objB, we say that "object objA has access to memberB on objB"
   

Combined, we say that objA has *access* (or *access rights*) to send a message ~memberB~ to ~objB~, if a message send ~objB memberB~ is allowed to execute at runtime from some place in code of ~objA~.

  
*** Slides 61, 62, 63: Rules for accessing members above and below the class in the nesting hierarchy

Slides in this presentation serve as a core source for the rules that define accessibility:

 [[https://00463064267054129163.googlegroups.com/attach/16b8a25058caa/ns-access-control.pdf?part=0.1&view=1&vt=ANaJVrHvttkWPn-fNP95UFKbcCbbp1VaDJlJSx1HzBevq_xhafVpZ4uz1ffKMTvkAxLFnAk2_xurwU-BTi3FIMnPj1FlU7-S-zKgS2y2eNXheQQsxM8mJUY][Can Beautiful Languages Do Access Control?]].

This section goes over access control rules described in the above slides.

The core slides are slides 61, 62, 63. They describe how Newspeak code in a class accesses members (classes, slots, methods) above and below the class in the nesting hierarchy and the member members, depending on the accessed member's public, private and protected status.


**** Slide 61: public, protected, private

This slide describes that Newspeak provides three levels of accessibility:
  - public
  - protected (No keyword before the member name makes the member protected)
  - private 


**** Slide 62: Lexical access rules for private and protected members, and inheritance access rule

This slide describes how Newspeak code in a class can access private and protected members (classes, slots, methods) above and below the class in the nesting hierarchy:

  - Rule a) Private and protected members can be seen by nested classes

  - Rule b) Enclosing classes cannot see private or protected members of nested classes

  - Rule c) Subclasses are never aware of private members of superclasses and vice versa

***** *Comments on slide 62*:

1. Rules a) and b) describe *lexical scope based access* from a class (say named C) to it's nested classe and it's enclosing classes. We can interpret lexical access as 'looking at source code'. If we print the code of the module declaration (the code of a top level class, including all nested classes), and use a finger to browse up and down the enclosing and nested classes, we are using lexical access.

     - rule a) can be interpretted as: *code in class C can access all members of all classes in the class C’s lexical scope UP*

     - rule b) can be interpreted as:  *code in class C can only access public members of nested classes in the class C’s lexical scope DOWN*. 
       
2. We can remember rules a) and b) using *Sky and the Ground memoization of rules a) and b)* as follows: 

  - Imagine looking UP, to the sky: sky is see-through, everything is visible and accessible, all the way to the remote stars.  This can be translated as in our situation *all members (private, protected, public) lexically UP are visible and accessible*. 

  - Imagine looking DOWN to the ground: the ground stops any visibility below the surface. This can be translated that all private and protected members DOWN below the bottom of our class are invisible. 

3. Rule c) is for inheritance: private members can be only accessed in the class where they are declared.


**** Slide 63: Is an extension and rewording of slide 62

  - *An object may access a private or protected member only if*

    - a) it is a member of the object or 

    - b) a lexically visible member of an enclosing object

***** *Comments on slide 63*:

1. Slide 63 rule a) clarifies that objects can access their own private and protected members
  
2. Slide 63 rule b) is reworded and summarized Slide 62 rules a) and b) (UP and DOWN lexical rules)

3. So slide 63 does not adds the intuitive but important rule that an object can access any of it's own members, regardless the member's access modifier.  


**** Corollary on slides 61, 62, 63

Corollary 1: Public member on any class ClC is accessible from anywhere.  By "accessible from anywhere" we mean "any class ClA which can be lexically anywhere" - we can write an expression which contains a public member of ClC in any code in ClA (even if the module where we write the code is different from the module where the public member is declared). 

Corollary 2: Non public member on class ClN is only visible from class ClC, if class ClC is nested in ClN.

*** Worked accessibility examples, using rules from slides 61, 62, 63

**** Code used in accessibility examples

This section is a step by step experiment accessibility rules described in slides 61, 62, 63.

We will use the following class code.  To follow the steps of this section, compile the following class into your IDE.  Save the code in a file on your system, then see the paragraph [[compile-files]] how to compile the code into your IDE. 

#+BEGIN_EXAMPLE
  Newspeak3
  'Root'
  class C1 = () (

      class ProtC2 = () (
          class ProtC3 = () (
              protM = (
                  ^'protC3ProtM'
              )
              public pubM = (
                  ^'protC3PubM'
              )
          )
          public class PubC3 = () (
              protM = (
                  ^'pubC3ProtM'
              )
              public pubM = (
                  ^'pubC3PubM'
              )
          )
          protM = (
              ^'protC2ProtM'
          )
          public pubM = (
              ^'protC2PubM'
          )
      )

      protectedFails = (
          ^'protectedFails' 
          (* C1 new protectedFails: Fails. 

          Reason:  I feel the reason is not completely obvious, as we are typing code in the Workspace, and it is not immediately clear how code in Workspace is lexically (nesting wise) related to the class ~C1~. A note: The Newspeak IDE provides a Root namespace, all modules are nested in it. Both the Workspace and the C1 module code are nested in the IDE. Having made that note let's work trough why this message send fails: The workspace context is lexically NOT enclosing C1. The code line that we wrote, ~C1 new protectedFails~ is lexically in the workspace module; the member we are trying to access, ~protectedFails~, is lexically in the C1 module.  In summary, this fails because of rule on slide 63 b: An object (workspace where we type the expression) may access private or protected member (~protectedFails~) only if a) it is a member or b) a lexically visible member of an enclosing class (C1 class is not enclosing to Workspace class). In our situation, the code in expressions ~C1 new protectedFails~ typed in the Workspace class cannot see a private or protected member (~C1>>#protectedFails~) of a class (C1) because the method C1>>#protectedFails is neither a member of  Workspace, nor it is in Workspace's enclosing class.

          Note: As a practical result, because we are testing in the workspace, we will make all our test methods in the C1 class public (for example ~public protC2New~, ~public protC2NewProtM~ and we will investigate the access rules on the expressions inside the methods on ~C1~. We name the methods on C1 so the naming reflects what the tested expression in the method does. For example: the name ~protC2NewProtM~ expresses in the name that we call the expression ~ProtC2 new protM~.  Also there is another important point here: For between-modules visibility: A module C1, looking into another module C2, can only see public members in C2. So C1 must make public any of it's members intended to be used outside of C1 - in other words, C1 module's API methods must be public. 
          *)
      )

      public publicSucceeds = (
          ^'publicSucceeds' 
          (* C1 new publicSucceeds: Success. 

          Reason: A public member (message named ~publicSucceeds~ here) is accessible from any lexical context - 'anywhere in code', even from another module (workspace in this case). 
          *) 
      )

      public protC2 = (
          ProtC2.  
          (* Success. 

          Reason: According to *Slide 63 a, classes are allowed access to all it's members (even private or protected)*. Here, the code is in class C1 (in it's member method ~protC2~), and accesses ~C1~s member nested class ~ProtC2~, so ~ProtC2~ can be accessed. Same would apply if the member nested class was private (~private PrivC2~ instead of ~ProtC2~). 
          *)
          ^ 'ProtC2'
      )

      public protC2New = (
          ProtC2 new.
          (* Success. 

          Reason: Similar reason as in ~protC2~ in the section above: . There is a fine print reason here we should add (this reason is not spelled out in the slide rules): The rules on member class visibility transfer to their primary factory methods; so the fact that code in ~C1~ can access it's member ~ProtC2~, transforms to ~ProtC2~'s primary factory, ~new~ in this case. In other words, ~C1~ can access it's member ~ProtC2~, implies that  ~C1~ can access it's member's primary factory (method ~new~, fully described as ~C1>>ProtC2>>#new~).
          *)
          ^ 'protC2New'
      )

      public protC2NewProtM = (
          ProtC2 new protM.
           
          (* Fails.
             Reason: We showed success all the way before sending ~protM~; sending ~protM~ (fully specified as ~C1>>ProtC2>>#protM~) fails. The code being executed, ~ProtC2 new protM~ is in class ~C1~. Method ~C1>>ProtC2>>#protM~ is a protected member on ~Prot2~, nested in ~C1~. According to *Slide 62 b) Enclosing classes (code in C1) cannot see private or protected members (protected method ~protM~) of nested classes (~ProtC2~).*. Sending message ~ProtM~ in ~ProtC2 new protM~ fails according to this rule, as expected.
          *)
          ^ 'protC2NewProtM'
      )

      public protC2NewPubM = (
          ProtC2 new pubM. 

          (* Succeeds 
             Reason:  ~pubM~ is public member on a nested class ~ProtC2~ (lexically a member of ~C1~). According to [[* Corollary on slides 61, 62, 63][Corollary on slides 61, 62, 63]] public member (here ~pubM~) is accessible from anywhere (here from ~C1~). Obviously, we have already validated access of the first part of the expression, ~ProtC2 new~.  
          *)

          ^ 'protC2NewPubM'
      )
  )
#+END_EXAMPLE

Let us describe this class.

1. We named the class ~C1~. ~C1~ is a top level class (which makes it a module, see the module section). Class  ~C1~ is intended to test a limited subset of accessibility scenarios. Note that ~C1~ is not marked public. However, in Newspeak, all top level classes are public by default!

2. Naming:

   - The strings *Prot* and *Pub* in the class names, denotes whether they are declared public or protected. The numbers 1, 2, 3 in the names C1, ProtC2, PubC3 etc express nesting level 'level 1', 'level 2' and 'level 3'.

   - The naming of the methods, for example ~protC2ProtM~ stands for "on protected class C2, protected method" and denotes class's and method's public / protected status for a quick lookup.

3. ~C1~ has 1 nested class, ~ProtC2~  which in turn has 2 nested classes, protected nestd class ~ProtC3~ and  public nested class ~PubC3~ to test public and protected access. Also,  ~ProtC3~ and  ~PubC3~  classes has one public and one protected method, named according to their access status, for example, ~PubC3>>#pubC3ProtM~ and  ~PubC3>>#pubC3PubM~

6. The methods just generally return a string with it's name, such as ~^'protC3ProtM'~ or return an expression such as ~ProtC2 new protM~ which we are testing for accessibility.

7. When we want to express the level of nesting in text, we may refer names such as ~C1>>ProtC2>>PubC3>>#pubC3PubM~

9. During testing, we will concentrate on why a certain expression evaluation succeeds or fails from the accessibility perspective, and will explain the success or failure based on rules in Slides 61, 62, 63.

  
**** Execute expressions in C1, gradually adding terms, to study by example


***** Structure of examples

Each example we run to test accessibility has the following structure.

- Workspace expression: *Here we can see the expression to type in workspace. In most cases, this is a method (message sent) to instance of class. With a few exceptions in methods 'publicSucceeds' and 'protectedFails', this message sent always succeeds;  we are testing accessibility in the code which is in the method contents - this is the code listed in 'Examines accessibility using this code:'*
- Examines accessibility using this code: *Here we can see the contents of the method - the code we are testing for accessibility*
- Does: *Here we describe in brief what the code in 'Examines accessibility using this code:' does* 
- Code Result: Success/Fails *Here we describe the result of accessibility experiment in the section*
- Reason: *Here we describe the reason for the Success/Fails result. In most cases, we tie the reason to the accessibility 'theory', generally in slides 61, 62, 63 in n [[https://00463064267054129163.googlegroups.com/attach/16b8a25058caa/ns-access-control.pdf?part=0.1&view=1&vt=ANaJVrHvttkWPn-fNP95UFKbcCbbp1VaDJlJSx1HzBevq_xhafVpZ4uz1ffKMTvkAxLFnAk2_xurwU-BTi3FIMnPj1FlU7-S-zKgS2y2eNXheQQsxM8mJUY][Can Beautiful Languages Do Access Control?]]*

***** C1

Go to Workspace and type of paste ~C1~ there, highlight it, and click on 'Evaluate selection' or do Shift+Enter.

- Workspace expression: ~C1~
- Examines accessibility using this code: ~C1~ in lexical scope of workspace.
- Does: Creates and return a class C1.
- Code Result: Success
  [[file:img/newspeak---a-few-notes.org-access-C1.png]]
- Reason: The top level class ~C1~ is always implicitly public, even without a public keyword! This rule is related to accessibility and modularity, but not spelled out in the Slides 60-63. The top level (and implicitly public!) class ~C1~ can be accessed in any other top level class, including the workspace where we are typing the expression. 

***** C1 new

- Workspace expression: ~C1 new~
- Examines accessibility using this code:  ~C1 new~ in lexical scope of workspace.
- Does: creates a new instance of class C1.
- Code Result: Success
  [[file:img/newspeak---a-few-notes.org-access-C1new.png]]
- Reason: Similar to the previous section, the reason is accessibility and modularity related. As mentioned in section aboce, a top level class is always publicly available in any code; here we find this extentds to it's primary factory method ~new~. A primary factory method on a top level class (module declaration) is always public (even if not explicitly specified).

***** C1 new protectedFails

- Workspace expression: ~C1 new protectedFails~
- Examines accessibility using this code: ~C1 new protectedFails~ in lexical scope of workspace.
- Does: Sends a protected message ~protectedFails~ to instance of ~C1~
- Code Result: Fails
  [[file:img/newspeak---a-few-notes.org-access-C1newProtectedFails.png]]
- Reason:  I feel the reason is not completely obvious, as we are typing code in the Workspace, and it is not immediately clear how code in Workspace is lexically (nesting wise) related to the class ~C1~. A note: The Newspeak IDE provides a Root namespace, all modules are nested in it. Both the Workspace and the C1 module code are nested in the IDE. Having made that note let's work trough why this message send fails: The workspace context is lexically NOT enclosing C1. The code line that we wrote, ~C1 new protectedFails~ is lexically in the workspace module; the member we are trying to access, ~protectedFails~, is lexically in the C1 module.  In summary, this fails because of rule on slide 63 b: An object (workspace where we type the expression) may access private or protected member (~protectedFails~) only if a) it is a member or b) a lexically visible member of an enclosing class (C1 class is not enclosing to Workspace class). In our situation, the code in expressions ~C1 new protectedFails~ typed in the Workspace class cannot see a private or protected member (~C1>>#protectedFails~) of a class (C1) because the method C1>>#protectedFails is neither a member of  Workspace, nor it is in Workspace's enclosing class.

Note: As a practical result, because we are testing in the workspace, we will make all our test methods in the C1 class public (for example ~public protC2New~, ~public protC2NewProtM~ and we will investigate the access rules on the expressions inside the methods on ~C1~. We name the methods on C1 so the naming reflects what the tested expression in the method does. For example: the name ~protC2NewProtM~ expresses in the name that we call the expression ~ProtC2 new protM~.  Also there is another important point here: For between-modules visibility: A module C1, looking into another module C2, can only see public members in C2. So C1 must make public any of it's members intended to be used outside of C1 - in other words, C1 module's API methods must be public. 

***** C1 new publicSucceeds

Having realized in the section above that expression ~C1 new protectedFails~ fails accessibility rules on the protected method ~C1>>#protectedFails~, we now test how things change if we call a public method ~C1>>#publicSucceeds~ instead of the protected  ~C1>>#protectedFails~.  The public method ~C1>>#publicSucceeds~ is equivalent to the failing protected method ~C1>>#protectedFails~ except it's name and it's public modifier.

- Workspace expression: C1 new publicSucceeds
- Examines accessibility using this code: ~C1 new publicSucceeds~ in lexical scope of workspace.
  [[file:img/newspeak---a-few-notes.org-access-C1newPublicSuceeds.png]]
- Does: Sends a public message publicSucceeds to instance of C1.
- Code Result: Success
  
- Reason: A public member (message named ~publicSucceeds~ here) is accessible from any lexical context - 'anywhere in code', even from another module (workspace in this case).

***** C1 new protC2

From this section onward, the method names we run are all public, defined on ~C1~. As public, all methods can be succesfully executed from accessibility perspective by calling the method on an instance such as ~C1 new~.  The method names attempt to express the expression executed. For example

- method named ~protC2~ suggests the method creates a ~ProtC2~ class.
- method named ~protC2New~ suggests the method creates a ~ProtC2 new~ - instance of ProtC2 class.
- method named ~protC2NewPubM~ suggests the method runs ~ProtC2 new pubM~ - sends message ~pubM~ to a new instance of the class ~ProtC2~.


- Workspace expression: ~C1 new protC2~
- Examines accessibility using this code: ~ProtC2~ in lexical scope of ~C1~, in it's method ~C1>>#protC2~
  #+begin_example
    public protC2 = (
        ProtC2.  
        ^ 'ProtC2'
    )
  #+end_example
- Does: Creates class ProtC2
- Code Result: Success
  [[file:img/newspeak---a-few-notes.org-access-C1newProtC2.png]]
- Reason: According to *Slide 63 a, classes are allowed access to all it's members (even private or protected)*. Here, the code is in class C1 (in it's member method ~protC2~), and accesses ~C1~s member nested class ~ProtC2~, so ~ProtC2~ can be accessed. Same would apply if the member nested class was private (~private PrivC2~ instead of ~ProtC2~).

***** C1 new protC2New

- Workspace expression: ~C1 new protC2New~
- Examines accessibility using this code: ~ProtC2 new~ in lexical scope of ~C1~, in it's method ~C1>>#protC2New~
  #+begin_example
    public protC2New = (
        ProtC2 new.
        ^ 'protC2New'
    )
    
  #+end_example
- Does: Creates an instance of class ProtC2 
- Code Result: Success
  [[file:img/newspeak---a-few-notes.org-access-C1newProtC2New.png]]
- Reason: Similar reason as in ~protC2~ in the section above: There is a fine print reason here (this reason is not spelled out in the slide rules): The rules on member class visibility transfer to their primary factory methods; so the fact that code in ~C1~ can access it's member ~ProtC2~, transforms to ~ProtC2~'s primary factory, ~new~ in this case. In other words, if ~C1~ can access it's member ~ProtC2~, implies that  ~C1~ can access it's member's primary factory (method ~new~, fully described as ~C1>>ProtC2>>#new~).
  
***** C1 new protC2NewProtM

- Workspace expression: ~C1 new protC2NewProtM~
- Examines accessibility using this code: ~ProtC2 new protM~ in lexical scope of ~C1~, in it's method ~C1>>#protC2NewProtm~
  #+begin_example
    public protC2NewProtM = (
        ProtC2 new protM.
        ^ 'protC2NewProtM'
    )
    
  #+end_example
- Does: Creates an instance of class ~ProtC2~ and attempts to send protected message ~protM~ to it.
- Code Result: *Fails* to send message ~protM~
  [[file:img/newspeak---a-few-notes.org-access-C1newProtC2NewProtM.png]]
- Reason: We showed success all the way before sending ~protM~; sending ~protM~ (fully specified as ~C1>>ProtC2>>#protM~) fails. The code being executed, ~ProtC2 new protM~ is in class ~C1~. Method ~C1>>ProtC2>>#protM~ is a protected member on ~Prot2~, nested in ~C1~. According to *Slide 62 b) Enclosing classes (code in C1) cannot see private or protected members (protected method ~protM~) of nested classes (~ProtC2~).*. Sending message ~ProtM~ in ~ProtC2 new protM~ fails according to this rule, as expected.

If we make the method we are calling, the ~C1>>ProtC2>>#protM~,  public, then the call to ~protM~ in ~ProtC2 new protM~ will succeed. We will show it by calling an equivalent but public method ~C1>>ProtC2>>#pubM~ in the next section.

***** C1 new protC2NewPubM

- Workspace expression: ~C1 new protC2NewPubM~
- Examines accessibility using this code: ~ProtC2 new pubM~ in lexical scope of ~C1~, in it's method ~C1>>#protC2NewPubM~
  #+begin_example
    public protC2NewPubM = (
        ProtC2 new pubM. 
        ^ 'protC2NewPubM'
    )
    
  #+end_example
- Does: Creates an instance of class ~ProtC2~ and sends public message ~pubM~ to it
- Code Result: Succeeds sending public message ~C1>>ProtC2>>#pubM~ from code in ~C1~
  [[file:img/newspeak---a-few-notes.org-access-C1newProtC2NewPubM.png]]
- Reason:  ~pubM~ is public member on a nested class ~ProtC2~ (lexically a member of ~C1~). According to [[* Corollary on slides 61, 62, 63][Corollary on slides 61, 62, 63]] public member (here ~pubM~) is accessible from anywhere (here from ~C1~). Obviously, we have already validated access of the first part of the expression, ~ProtC2 new~.  


Note: All along during accessibility discussion, we assumed a message in an expression is understood by the receiver, and merely examined whether the code where the expression is, has access to the message.  To make an explicit note in this section:  ~pubM~ is a member method on ~ProtC2~, so the instance ~ProtC2 new~ does understand ~pubM~.  Here, ~C1>>ProtC2>>#pubM~ is accessible from method ~C1>>#protC2NewPubM~, that is all that matters for accessibility evaluation.  The fact that ~pubM~ a member (on ~ProtC2~) but that is not relevant in accessibility evaluation, although obviously necessary for understanding.

Summary: This section [[* C1 new protC2NewPubM][C1 new protC2NewPubM]] shows how to 'resolve' the accessibility failure discussed in the previous section. The takeaway is that if a code wants to access members of any nested class, the nested class must make such member public - as we did here (protected ~protM~ access failed, changing to public ~pubM~ access succeeded).


** Debugging in Newspeak

To debug, insert a line like this in code:

#+begin_example
  break.
#+end_example

To debug in the slot declaration section, insert a code like this

to debug in here, 
#+begin_example
| foo = some expression. |
#+end_example

wrap the expression in a block and call value like this:

#+begin_example
| foo = [break. some expression] value. |
#+end_example


** Ampleforth and HTML documents in Newspeak

TL;DR: We can create HTML Documents in Newspeak. More precisely, we can create a Document object in Newspeak using the *"Add Document"* popup action on the "Root-+" button. Such object is a true Newspeak object; it can contain HTML along with Newspeak-defined actions.  The document can be saved (exported) to a HTML file using the *Download* popup action on the "document-3-dot" button. The exported document can be loaded (imported) back the the IDE using the *"Load Document(s)"* popup action on the "root-3-dot" button.  Ampleforth is a framework that allows HTML documents to perform actions, implemented as Newspeak methods .

The chapters below show the steps in detail.

*** Ampleforth and HTML documents in Newspeak: Creating the document and adding it to the IDE

From the IDE:
- in "Newspeak Source"
- click on the "+" beside Root, in the popup, choose "Add Document"
- give the document a name
- click the "Accept" checkbox.

So far this is equivalent to creating and adding a class, except here we choose "Add Document" rather than "Add Class".

*** Ampleforth and HTML documents in Newspeak: Editing the document and exporting it as HTML

The newly created document named *AMyDocument* may look similar to this

[[file:img/newspeak---a-few-notes.org-document-html-example.png]]

Above is the state *after we clicked the ">" widget just above the document text* - this revealed an editor line:

[[file:img/newspeak---a-few-notes.org-document-html-example-editor-line.png]]

To save the document HTML, click on the "download" button [[file:img/newspeak---a-few-notes.org-downloadImage.png]] in the above line.


The document ~AMyDocument~ will save an HTML file with the document contents stored in a top-level ~<div>~ element. The top-level div class name "ampleforthDocumentClass" is known to Newspeak, which can use it to convert this html back to a Newspeak object, from the top-level div attribute "classBody".

The contents of *AMyDocument.html* is shown below:

#+begin_src html
  <!-- this first div with class ampleforthDocumentClass does not display anything : it contains code for the class AMyDocument.
       It has no methods, but it could have.
    -->
  <div class = "ampleforthDocumentClass" name = "AMyDocument" classBody = "() (
  ) : (
  )
  "
  </div>

  <!-- this second div with class ampleforthDocumentBody displays the document -->
  <div class = "ampleforthDocumentBody">
    <body>
      <div class="self_ampleforth" contenteditable="true" style="border: 2px solid blue; resize: horizontal; overflow: auto; overflow-wrap: break-word; width: 40em;" onkeyup="updateRawHTML()">
        <h1>This is a blank document - testing saving as HTML.</h1>
        <div><br></div>
        <div>Body here.</div>
        <div><br></div>
        <div>- item 1</div>
        <div>- item 2</div><div>
        <br>
        </div>
        <div>The list above is just a bunch of divs.</div>
      </div>
    </body>
  </div>

  <!-- the remaining script elements contain support for loading this file if converted to vfuel (??) -->
  <script type="text/javascript">
        function scheduleTurn(timeout) {
          if (timeout >= 0) {
            setTimeout(function() {
              var timeout = Module._handle_message();
              scheduleTurn(timeout);
            }, timeout);
          }
        }

        var Module = {
          noInitialRun: true,
          noExitRuntime: true,
          onRuntimeInitialized: function() {
            var url = new URLSearchParams(window.location.search);
            var request = new XMLHttpRequest();
            request.open("GET", url.get("snapshot"), true);
            request.responseType = "arraybuffer";
            request.onload = function (event) {
              var jsBuffer = new Uint8Array(request.response);
              var cBuffer = _malloc(jsBuffer.length);
              writeArrayToMemory(jsBuffer, cBuffer);
              Module._load_snapshot(cBuffer, jsBuffer.length);
              _free(cBuffer);
              scheduleTurn(0);
            };
            request.send();
          },
          print: function(text) {
            if (arguments.length > 1) {
              text = Array.prototype.slice.call(arguments).join(" ");
            }
            console.log(text);
          },
          printErr: function(text) {
            if (arguments.length > 1) {
              text = Array.prototype.slice.call(arguments).join(" ");
            }
            console.error(text);
          },
          setStatus: function(text) {
            console.log(text);
          },
        };
      </script>
      <script async type="text/javascript" src="primordialsoup.js"></script>
      <script src="CodeMirror/lib/codemirror.js"></script>
      <link rel="stylesheet" href="CodeMirror/lib/codemirror.css"></link>
      <script src="CodeMirror/addon/display/autorefresh.js"></script>
#+end_src

Opening the file *AMyDocument.html* straight in a browser tab (as Ctrl-O, NOT in the contents of Newspeak IDE), displays the pure HTML contents correctly - assuming any resources it references are available. It would not display any "live" elements that would require calling methods

[[file:img/newspeak---a-few-notes.org-document-html-open-exported-html-file.png]]

The file *AMyDocument.html*:

- contains the document class and methods - but using the methods requires a running Newspeak system, NOT just the browser which only displayes the HTML.
- can be fully instantiated as a Newspeak Document by loading it (compiling it) into a running IDE (which does NOT contain the class ~AMyDocument~). This can be done by clicking the "Load document(s)" on the 3-dot menu in
  [[file:img/newspeak---a-few-notes.org-load-document-object-saved-as-html.png]]
  which puts the document class back to the IDE
  [[file:img/newspeak---a-few-notes.org-loaded-document-object-saved-as-html.png]]
- also somehow, can be instantiated and run by creating a vfuel from it??




*** Ampleforth examples

Blogs
- sourced on https://github.com/gbracha/gbracha.github.io
- run URL on https://blog.bracha.org/

| Title                          | URL                                                                       | Github Dir            | Is HTML Empty (like primordialsoup.html)? |
|--------------------------------+---------------------------------------------------------------------------+-----------------------+-------------------------------------------|
| What You Want                  |  https://blog.bracha.org/WYWIWYG/out/WYWIWYG.html?snapshot=WYWIWYGApp.vfuel                        | WYWIWYG/out           | Y                                         |
| Ampleforth: A Live Literate    |  https://blog.bracha.org/Ampleforth-Live22/out/primordialsoup.html?snapshot=Live22Submission.vfuel | Ampleforth-Live22/out | Y                                         |
| Programmer Like a Pathologist? |  https://blog.bracha.org/exemplarDemo/exemplar2021.html?snapshot=BankAccountExemplarDemo.vfuel     | exemplarDemo          | N                                         |
| Odersky (no contents)          |  https://blog.bracha.org/OderskyFestschrift23/primordialsoup.html?snapshot=Telescreen.vfuel        | OderskyFestschrift23  | Y                                         |
|                                |                                                                           |                       |                                           |




** Examples of applications written in Newspeak

TL;DR: This section collects a few more sophisticated examples, in addition to the introductory [[* Hello World in Newspeak - several versions][Hello World in Newspeak - several versions]], and the ~CounterApp~ in [[* Code, run, and debug the CounterApp in Newspeak][Code, run, and debug the CounterApp in Newspeak]].


*** Example: Extended CounterApp, the CounterAppWithDependencies

TL;DR: ~CounterAppWithDependencies~ is an example of an Application which uses a dependency, the General module ~ATranslation~.  We can download and save the code files from https://github.com/mzimmerm/newspeak-doc/tree/main/newspeak---a-few-notes-code/counter-app-with-dependencies.  We use [[compile-files]["Compile file(s)"]] to load the saved files; the loaded class will appear in the IDE. Then we can browse, run, or deploy the Application. This version is in Czech:  [[file:img/newspeak---a-few-notes.org-counter-app-with-module-dependency-czech.png]]


Note: In this ~CounterAppWithDependencies~ example, the translation class ~ATranslation~ was written by us, as a General module, NOT a library. We have another example [[* 4. Hello World Application using 3rd party dependency][4. Hello World Application using 3rd party dependency]] where the translation class ~HelloTranslator~ is wrapped in a Library module ~HelloTranslatorLib~ - this mimics a situation where ~HelloTranslator~ may NOT be written by us, but by another 3rd party, who packaged packaged  ~HelloTranslator~ in  ~HelloTranslatorLib~ for distribution.  As a result, the Hello World example is slightly different.
     
*** Example: A Hopscotch Model-Presenter-Subject UI Application, the CheckedItemApp

This example Application is in another chapter, as it was developed based on a detail IDE and debug based discovery of Hopscotch UI in that chapter. View it at [[* Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*][Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*]]


** IN-PROGRESS-NOW Snippets of wisdom from various sources

*Sources are rarely listed by URL BUT are generally those in [[*This document: Introduction to Newspeak on Webassembly (Wasm)][This document: Introduction to Newspeak on Webassembly (Wasm)]]: Newspeak website, Room 101 and Newspeak user group.*

Snippets of wisdom

- *Recipy - How to implement what would be static variables in other languages*: Anything that you expected to put in a static variable goes in an instance variable of a module. What about singleton classes? How do I ensure that there is only one instance? The easiest way is to initialize a read only slot of a module with an object literal. What happens if there are multiple instances of the module declaration? Well, each module has its own "singleton". That's exactly what happens with singleton classes in Java when they are defined by multiple class loaders. 
- From https://bracha.org/newspeak-modules.pdf Like Self, all computation - even an object's own access to its internal structure  is performed by invoking methods on objects. Newspeak is class-based. Classes can be nested arbitrarily. Since all names denote method invocations, all classes are virtual; in particular, superclasses are virtual, so all classes act as mixins. Unlike its predecessors, there is no static state in Newspeak, nor is there a global namespace. Modularity in Newspeak is based exclusively on class nesting. There are no separate modularity constructs such as packages. Top level classes act as module definitions, which are independent, immutable, self-contained parametric namespaces. They can be instantiated into modules which may be stateful and mutually recursive.
- StringTest>>#testShout is the Smalltalk way of documenting the testShout method of the StringTest class.  When you actually type the code into the browser, you don't have to type the class name or the >>; instead, you just make sure that the appropriate class is selected.  Documentation example in text should show abstract argument names:
  #+begin_example
    History>>goBackward
      self canGoBackward ifFalse: [self error: 'Already on the first element'].
      stream skip: --2.
      ^ self next.

    History>>goTo: aPage
      stream nextPut: aPage.
  #+end_example
- Modules (top level class instances) can only access other modules and module declarations (module classes) through ~a parameter passed in primary factory - the module instantiation method~
  So this is a module (termed General, see zoo):
  #+begin_src
    class HelloBraveNewWorld usingPlatform: platform = (
      (* This works *)
      platform squeak Transcript open show: 'Hello, Oh Brave new world'.
    )
  #+end_src
  If we had written
  #+BEGIN_SRC
    class HelloBraveNewWorld = (
      (* This does NOT work *)
      Transcript open show: 'Hello, Oh Brave new world'.
    )
  #+END_SRC
  and then created an instance via ~HelloBraveNewWorld new~ (if a class doesn't specify a message for creating instances, new is the default), we would get a doesNotUnderstand: error, because HelloBraveNewWorld does not understand the message Transcript.  There simply is no way to access the standard output stream, or any other system state, without having it passed in via a parameter when a module is instantiated.
- Workspace evaluation
  - ~ide namespacing manifest Collections~ (* Collections class *)
  - ~collections~  (* instance of CollectionForPrimodialSoup *)
  - ~(ide namespacing manifest ATranslation) new translate: 'aaa'~ (* 'cannot translate', good, that means the 'translate:' method was called *)
- *If you are learning, make everything public.  everything = each method, slot, and inner class*.  It may not be the right thing, but it helps as the error messages are not the best currently.  You will just get "Does not understand" too many times.  First time it took me a day to figure out hehe. 
- so, basically, if I have an HTML string with a <div class='helpButton'>, this code in ClassPresenter>>helpText:  can insert a Hopscotch(?) instance of  HelpButton (assuming HelpButton was implemented) and the HelpButton instance will present itself as Html on that div? Hmm, maybe that org-to-ampleforth just got more exciting - but I have to hold myselt. -- answer: Pretty much.  You need to define the mapping from div classes to Newspeak widgets, as ClassPresenter>>helpText: does for the widgets it uses.
- Library is an informal term.  Any Newspeak module definition (i.e., a top level class) is a library, and to use, it you call its class methods, most likely to instantiate it. If you want to deploy a module, you need to use it via an app (i.e, define something with #packageUsing: and #main:args:), directly or indirectly. 
- Hopscotch: *Compositionality* is one of the most crucial, and most often overlooked, properties in software design; it's what sets Hopscotch apart.



* IN-PROGRESS Q&A - answers should be either here directly, or link to an earlier section

** Section goals and resources

To provide no-introduction answers and comments to problems. Some sections grew to large proportions.

Much of this Q&A is sourced and expanded, or simply pasted from the Newspeak google group posts at https://groups.google.com/g/newspeaklanguage



** Newspeak: The price of being principled. The hard parts: *namespace*, *manifest*, *platform*, *module*, *convention methods*, *packaging*. What are these things?

TL;DR: I am a perpetual Newspeak beginner.  I have started looking at Newspeak with low intensity early 2010ish.  Then I stopped, and started again around 2021.  When reading discussions with other Newspeak newcomers, I realized there is some common confusion, that (for me) does not seem to be solvable by reading documents.  This section is a collection of information that I hope helps in the understanding of these concepts.  The 

Most of my confusion was around terms, principles, concepts, convention methods, etc, which are new or different compared to mainstream languages (including Smalltalk which is not mainstream arguably).  Let's list some of the terms first, then devote a chapter to each. The list below includes terms for: principles (no global namespace), concepts (module, modularity), names of objects that reflect concepts (manifest, platform), method names (~#packageUsing: manifest~) etc.

- ~manifest~
- ~platform~
- ~namespace~
- ~module~ and *modularity*
- What role do the *convention methods* play?
  - ~#packageUsing: manifest~
  - ~#packageLibraryUsing: manifest~
  - ~#buildUsing: platform~
  - ~#main:args~ 

    
For all the above terms, at some point I kept asking: what does this thing actually mean and do? It is hard! *Turns out, maybe not hard at all. But that comes with time.*

Below are snippets of discussions related to the above concepts (sometimes rephrased, sometimes things added - all errors are mine).

Links where snippets were acquired from : mostly Gilad Bracha answers on the Newspeak Google groups.

https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/OFdtqSnrBAAJ
https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/34Qc12XyBAAJ
https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/TaCMMqTzBAAJ
https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/9DcOV7wzBQAJ
https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/p3RYdQ5OBQAJ (! packaging libraries)
https://groups.google.com/g/newspeaklanguage/c/27d9nIKKulo/m/Aiq5DHyTAAAJ (! building libraries)

Terminology: Let us call *systemPlatform* the specific system Newspeak runs on: Wasm, Squeak, etc. These in run on Linux, Mac, Windows, Android. So a *systemPlatform* may be "Wasm on Linux", but the "on Linux" is not necessary as Wasm has pretty much the same support on all OSes. 

*** What is a *module*?

- Is instance of a top-level class
  
- Modules (top-level class instances) are invisible to each other?

  - Exactly. This is the result of one Newspeak fundamental design ideas, that make it very different from Smalltalk: "There is no global namespace."
    
- It has no access to anything except a few basic classes inherited form Object, and whatever is passed into its factory (it need not be platform). The arguments to the factory are capabilities, in the sense of the object-capability security model (ocap). Now to actually build things, *you use the IDE as a global namespace* to collect the various pieces you need. 


*** What is a *platform*?

- The platform object reifes the set of standard libraries that one expects to have at any destination.
   
    - In a sane world, this would be the complete story. Alas, we live on Earth instead. We can't expect every device to have Newspeak installed. Therefore, we may need to package an application with additional elements, such as the Newspeak platform and a Newspeak VM. We also need to accommodate different packaging formats and technologies, such as operating systems and web browsers.

- It is a also a message supported by the workspace. It returns an object also termed 'platform'.  

- Is there a way to list what variables are there?
  
  - Yes: type platform and evaluate it (make sure you select 'platform' or type it on a new line, so you don't end up evaluating other stuff in the workspace). Then click on the link, which iwll take you to an object presenter (aka object inspector) on the platform object. 
  
- The platform object also provides the API for all things supported by the infrastructure (systemPlatform) where it is running. This APIs should be implemented by all systemPlatforms where Newspeak runs on.  But it does not lock you in - that's why you have the option of accessing systemPlatform-specific stuff, by going through an accessor method. On the WASM system, that accessor is #js, and it gives you access to Javascript. So it is also something that gives you the only connections to the world outside Newspeak.

- Q: It is usually used in factory method slot declarations, such as
  #+begin_src 
  class AClass usingPlatform: platform  = (
  	|
    (* imports *)
    private Map = p collections Map.
    private Presenter = p hopscotch Presenter.
    |
  )
  #+end_src
  Why do you not just store the Platform object itself in a slot, and only ask it for these other objects when you need them?
  
  - A: You could do that, but that would be bad coding style.  Newspeak is largely about modularity; this is a big part of that story. The code above acts (as the comment says) as a series of imports of classes that the module depends on.  If you store the individual modules as above then you (and the system) know, looking at the factory, exactly what the module's dependencies are. If you store the entire platform, you don't know what you're using; it's like a Java program (or a Smalltalk program, for that matter).

- Improved platform story. You might have noticed an annoying quirk in the various GUI apps, where the app has to set up a Hopscotch-enabled platform in its #main:args: method.  This deviation from Goodthink has been eradicated. The old HopscotchForHTML5Runtime class is gone. Instead, RuntimeForHopscotchForHTML provides a proper platform that one can deploy Hopscotch apps to, and these apps no longer need to anything special/convoluted to use Hopscotch. The apps and build script have been updated accordingly.
  

*** What is a *manifest*?

- *The Newspeak IDE provides a global namespace, which is of course a real object that you can pass around.  That object is a manifest.*

- Manifests and platforms are totally different. Manifests are a development thing - only available in the IDE. Platforms are a deployment thing.

The platform is something that gives you the only connections to the world outside Newspeak. 


*** What is a *namespace*?

- The Newspeak *language* has no global namespace.

- The Newspeak *IDE* provides a global namespace, which is a real object that you can pass around.  That object is a ~manifest~. The section in IDE UI where it is displayed is called "Root".

- Try evaluating ~ide namespacing manifest~ in an IDE workspace. This is the global namespace, but it only exists in the IDE. mz - it does not exist when running an application, unless the application author saves the whole manifest on application's slot. 

- Of course, you can always override the behavior of a given manifest by wrapping it. 
 
- mz : Each *module* is also a non-global namespace for it's inner classes.  A name (of a slot, method, inner class) in a moduleA will never clash with a name from a moduleB.
  

*** What is *#packageUsing: manifest* and *#packageLibraryUsing: manifest*?

- Q: At which step of the lifecycle would the ~AnApplication>>#packageUsing: manifest~ and ~ALibrary>>#packageUsing: manifest~ method be used (invoked), where, by whom?

  - A: Those "convention methods" should be given to Applications and Libraries to be given special way to instantiate for packaging.  They would be invoked as a step to build an Application or Library object for distribution (answering lifecycle), by the IDE (answering by whom) on the source system (answering where).  Their invocation would be followed by serializing the object, which would be saved as a .vfuel file for distribution. We could serialize the object in different serialization and distribution formats, and different assumptions about presence of dependencies on the target system. .vfuel file is the main format. The IDE uses the presence of this method (solely) to determine the module is an Application, and displayes on the class line, the [run][debug][deploy] actions.  The action code after clicking on [deploy] -> asVictoryFuel(WithMirrors) starts with invoking this method, followed by serialization of the Application object this method creates.

- During creation of a software artifact, all the dependencies of the artifact have to be made available by getting them to the *development site* or *build site* (where the *build scripts* will run). This is *commonly addressed by package managers* (mz - e.g. zypper install, apt, flutter pub get, pull dependencies from the web to the "build site" - my system - where I want to create and build my newly-coded package). That much is true in Smalltalk as well. In Smalltalk you put these in your image, which provides a global namespace; in most other systems you put them in the file system, which again, is a global namespace.  In Newspeak, you put them in the IDE, which as a global namespace as well. I am hoping to avoid the plague of package managers; the IDE should be able to do this based on some metadata conventions.

- Next, there is the question of how you put together your program from the available artifacts, given the global namespace. This is the domain of *build scripts* in traditional software. In Newspeak, you can write these scripts in Newspeak itself.  These would take a *namespace object* (we often call a *manifest*) as a parameter. You'd *typically pass in the IDE top level namespace*. Of course, you can always override the behavior of a given manifest by wrapping it.

- So you write class with a ~#packageLibraryUsing: manifest~ method that takes a manifest and instantiates your library as you wish. The manifest needs have all the code you need. Importantly, the manifest is still under 'end user control' and should contain only top level classes (we can also enforce that) so no state or access to the outside world is provided. *Thus, the #packageLibraryUsing: methods are like build scripts*, and they can call other ~#packageLibraryUsing: manifest~ methods, *just like build scripts or makefiles refer to others*. The difference being that none of this is hardwired to a specific global namespace.

- The above deserves reiterating: Despite the name, the *"#packageLibraryUsing: manifest" methods are like /build scripts/*! mz - And, the *"#buildUsing: platform" methods are like loading a module provided by the library into memory and linking it to application*! See the next section on ~#buildUsing: platform~

- And if I write software library that depends on 20 or 30 third party libraries, I'll have to write a factory with 30 specific arguments?

  - No, you can aggregate them into an object (a manifest or submanifest, or even something else), and pass that into the  ~#packageLibraryUsing: myManifest~.  That way clients of your library will not break when you add 31st 3rd party library to your library. Also note that in many cases, you will write factories that take actula module instances rather than classes as arguments.  

- The "convention methods" names for a Newspeak Library, are confusing: they use the method name starting with the word "package" for a step which is in traditional software termed "build(script)", and they use the method name starting with the word "build" for a step which is in traditional software termed "loading" or "linking".
      
  - *package(Library)Using: manifest   performs work similar to build scripts to build for deployment* - factory method

  - *buildUsing: platform              perform work similar to loading and linking* - instance method

  -  The argument to the factory is the manifest, which is a namespace object where all the dependencies of the application can be found. The factory method of the application is analogous to its build script. To deploy an application, you serialize  it (exactly in the sense of object serialization) so that you can then transport it elsewhere, where you can deserialize it, obtaining a live object; then you call #main:args: and run it. Again, it's just like shipping executable. Deserializing is like loading.  


*** What is *#main: platform args: args* and *#buildUsing: platform*?

- At which step of the lifecycle would the "#build: platform" method be invoked?

  - A: When loading an application.

Details:

The ~#buildUsing: platform~ was proposed specifically for the library distribution scenario rather than the application distribution scenario.  It's role is analogous to ~#main:args~. You distribute the library, as you distribute the application, as an object with its dependencies (excluding the platform), all serialized.

1. You produce (build) the application (respectively library) object using ~#packageUsing:~ (resp. ~#packageLibraryUsing:~).
2. You then instantiate the application (respectively module object provided by the library object) using ~#main:args:~ (resp. ~#buildUsing:~).

At that the first stage (dev time on source system) you provided a manifest, a global namespace of the classes you need. At the second stage (load time on target system) you provide a ~platform~ that ties this code to the standard libraries that provide access to real world capabilities.


*** Use case and lifecycle for packaging and building: *#packageUsing: manifest*, *#packageLibraryUsing:*, *#main: platform args: args* and *#buildUsing: platform*

Alice sells a module of type ~AlicesModule~. Alice codes up a Library of type ~AlicesModuleLib~ as a wrapper for her module of type ~AlicesModule~. Bob is building an application of type ~BobsApp~ which wants to use ~AlicesModule~.

I will drop the word "type" below, and use lowercase for objects, Uppercase for classes.

The lifecycle of a library ~alicesModuleLib~ providing the module ~alicesModule~ would be:

1. In IDE of Alice:
1.1  -> Alice writes code for AlicesModule, and ~AlicesModuleLib~, providing on ~AlicesModuleLib~ the factory ~packageLibraryUsing: manifest~ and the instance method ~buildUsing: platform~ which returns ~alicesModule~.
1.2  -> ~AlicesModuleLib~ shows up in the IDE and in manifest
1.3  -> Alice clicks [deploy] (alternatively, this section can be done is a build script)
1.4    ->   ~AlicesModuleLib #packageLibraryUsing:manifest~ (build-like step) is invoked
1.5    ->   above produces ~alicesModuleLib~, the library object with AlicesModule and other classes needed by ~AlicesModuleLib~ on slots
1.6    ->   serialization is invoked for ~alicesModuleLib~
1.7    ->   alicesModuleLib.vfuel is produced and saved from ~alicesModuleLib~
2.   -> Alice sends vfuel to a public repository
3.   -> Bob downloads alicesModuleLib.vfuel from the public repository
4. In IDE of Bob:
4.1  -> Bob clicks the (todo not-existing?) button which calls code to deserialize alicesModuleLib.vfuel to an object and loads the object (todo mechanism?) into Bobs IDE
4.2  -> ~alicesModuleLib~ is now held in Bobs IDE
4.3  -> ~AlicesModuleLib~ shows up in Bobs IDE and is placed on Bob IDEs manifest (todo mechanism? probably from ~AlicesModuleLib~ class deserialized along with ~alicesModuleLib~ ?)
4.4  -> Bob, in his IDE starts writing ~BobsApp~.
4.5      - in ~BobsApp>>#packageUsing: manifest~, he writes code to store ~alicesModuleLib~ on a slot : ~|alicesModuleLib = manifest AlicesModuleLib packageUsing: manifest|~
4.6      - in ~BobsApp>>#main:args: platform~ he writes code to instantiate ~alicesModule~ :  ~alicesModule:: alicesModuleLib buildUsing: platform~ . This yields the alicesModule instance that provides good service to ~BobsApp~ in the following lines.
4.7    -> Bob can now click [deploy] on ~BobsApp~, with steps equivalent to 1.3 to 1.7



I only have questions on
  - for 2. and 3.: is this in principle intended as a sharing mechanism of serialized artifacts?
  - for 4.1 : is such button intended? I do not need to understand the mechanism, just that it may be like that in principle.
  - for 4.2 and 4.3 : I speculate this is just a result of 4.1, but maybe int is not so
I do not have questions on the other items, in fact I would be unhappy if I got those items wrong :)


Thanks todo-00-last - ask the above on newspeak list, also comment on conflicting naming as mentioned above.

  - *package(Library)Using: manifest   performs work similar to build scripts to build for deployment* - factory method

  - *buildUsing: platform              perform work similar to loading and linking* - instance method


Also see  [[* Application and library modules in Newspeak][Application and library modules in Newspeak]] 



*** What makes the [deploy] [configuration] [run] and [debug] buttons to show in IDE on the class line?

They all show if and only if the the class has the "#packageUsing: manifest"

*[run tests] and [show tests]* are displyed iff the class has a ~#packageTestsUsing:manifest~ class method. Again, a convention indicating that the class is a test configuration.


*** What are serialization methods and formats?

 - Can the 'program package' in Newspeak be something else than a vfuel file?

   - A: Yes. Example: you compile the application into Javascript. This too is a way to serialize the application object.  Or you might want to deploy your code as an Electron app, packaged as a MacOS application or a Window application, and these may each have variations (are they to be signed for app store use?; are they to include the Newspeak code as vfuel along with a WASM VM, or as Javascript? etc.). More on this below.

   - As noted above, there are any number of formats. At the very core, there is a serialized Newspeak object. For a CounterApp, this would be ~100Kb. But because we ship the ~platform~ code in a vfuel, we get to about 1Mb. Once we add the engine (300K WASM) and other resources, things grow further, and we are distributing something like zipped directory (e.g. server.zip on the downloads page). If we wrap that in an Electron app, and wrap that in a MacOS app, we have 70Mb zipped, or 175Mb unzipped, because we now are shipping Chromium as well.  

- I can place .vfuel under a webserver and run the CounterApp, but can I, for example, export some other artifact (zip file with binary or source?) that is later loaded into another persons Newspeak IDE?

  - A: In principle, yes, there are other ways to serialize an application. In earlier versions, we would serialize an app without the platform code. This results in very small files (say 100Kb, depending on the app). The IDE (this was the old Smalltalk based system)  would deserialze the app object into a regular Newspeak object in memory. In an ideal world, this is all you would need. Alas, this requires a Newspeak engine to be useful, and we cannot realistically assume this. *So, the current vfuel files include the entire platform code in them*.  Now, since many apps do not require features such as reflection, and reflection tends to greatly increase the footprint of the vfuel file (because we must include source code as well as the mirror module) we have *options to create vfuels with or without mirrors*. The idea of *deployment/serialization configurations* is to generalize this, so one can describe deployments of varying kinds. This is not really properly supported yet. But you can see that there is a large number of combinations (JS or WASM; GUI or non-GUI; mirrors or no mirrors; MacOS, Windows, ChromeOS, iOS, Android; Electron or PWA) not all of which are valid of course.

    

** How do I save my changes? 

Newspeak doesn't have an image.  So what do I actually do to develop software? I mean, I presume I run a copy of Newspeak somehow, and start adding classes to it.  But then where / how do my additions get saved if there isn't an image? When I've added a couple of classes to a running Newspeak environment, I presume they don't just disappear when I switch my computer off? So where do they go? Or where do I put them?

Changes in Newspeak are always saved locally, as long as you click the "Accept" button after making changes.

It won't save your state, but it will save your code.  Bear in mind that the web-based system is young and will crash occasionally, but also that *the system saves your changes as backup regardless of whether you saved explicitly*. 

For a complete discussion, see [[*Saving changes in Newspeak][Chapter Saving changes in Newspeak]].
 

** How would I build and deploy a Newspeak application? 

For ~HelloWorldApp~, see [[*Hello World in Newspeak - several versions][Hello World in Newspeak - several versions]].

For the ~CounterApp~ example, see section [[* Code, run, and debug the CounterApp in Newspeak]]


** How do I bring dependencies into modules to be distributed?

As discussed in [[*Dependencies and modularity: Important but hard to "get" at first][Dependencies and modularity: Important but hard to "get" at firsty]]:

- Due to Newspeak's modularity, the process of bringing dependencies into a Newspeak program is different from mainstream language platforms. 
- The ~manifest~ object, passed to /primary factory/ of Application and Library, provides the ability to bring dependencies into modules for packaging.  The ~platform~ object, passed to convention instance methods to the Application and Library objects, provides runtime objects expected to be found on all Newspeak platforms (on all Newspeak deployments).

Folow the above link and also the [[*Hello World in Newspeak - several versions][Hello World in Newspeak - several versions]] section for concrete examples of bringing dependencies.

Text below provides the example introduced by Gilad Bracha on the Newspeak Google groups list: https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/p3RYdQ5OBQAJ

Imagine a convention whereby *every library intended for distribution is sent out as a class which:*

 - has a factory (or in general, class method) method ~#packageLibraryUsing: manifest~ 
 - has a (build) ~#buildUsing: platform~ method - this method, given a platform object, produces a working instance of the module we actually want to distribute

Now developer A (Alice) intends to distribute a module MyMod1.
It depends on some other code she developed, say, MyMod2, which in turn depends on a 3rd party library from developer B (Bob).
The module Alice distributes is below.

#+BEGIN_SRC
class MyMod1DistributionLib packageLibraryUsing: manifest = ( 
 (* packageManager: ...  metadata describing the expected dependencies *)
  |
  MyMod1 = manifest MyMod1.
  MyMod2 = manifest MyMod2.
  my3rdPartyDep = manifest My3rdPartyDep packageLibraryUsing: manifest.
  |
) (
   public buildUsing: platform = (
      |
      my3rdPartDependency = my3rdPartyDep buildUsing: platform.
      myMod2 = MyMod2 usingPlatform: platform and: my3rdPartDependency.
      myMod1 = MyMod1 usingPlatform: platform mod2: myMod2.
      |
     (* IMPORTANT: buildUsing: returns the General module instance NOT this MyMod1DistributionLib
                   library instance - the library is only vehicle to build and return
                   the module we are distributing!!
     *)
     ^myMod1
   )
)
#+END_SRC

The Library instance method ~#buildUsing: platform~ encapsulates the knowledge of how to build Alice's code, using an internal library she wrote (MyMod2) and Bob's library.  

Note that Alice is using the same convention as Bob, and builds Bob's code with no knowledge of its internal dependencies.
Developer C (Carol) uses these same conventions to build Alice's code.  She can do so regardless of whether
- she is *building an app* : she'd call the Library factory ~AlicesMyMod1DistributionLib>>#packageLibraryUsing: manifest~ from the app's factory (from the ~CarolsApp>>#packageUsing: manifest~), and call ~AlicesMyMod1DistributionLib>>#buildUsing: platform~ from the app's ~CarolsApp>>#main: platform args: args~
- or she is *building another library*: where she'd call ~AlicesMyMod1DistributionLib>>#packageLibraryUsing:manifest~ from the library factory (from the ~CarolsLibrary>>#packageLibraryUsing:manifest~).

If Alice decides to replace Bob's code with code from developer D (David), she changes MyModules, but Carol's code does not change.  Likewise, if Bob or David change their dependencies, neither Alice nor Carol change their code.

It isn't necessary for everyone to follow the exact same convention - what's critical is that a given module maintains its convention so its build API is stable.  Of course, a common convention is good, especially for tools. 

Alice could just distribute an instance of MyModules, but this hard-wires the versions of all the dependencies.  Assuming she doesn't do that, it is true that Carol needs to download all the pieces and their sub-pieces from Bob and Alice etc.  She loads them into the IDE (or the IDE does so by reading the metadata) and the IDE's namespace is used to produce the manifest object passed in when anyone builds an app.

Note that ~platform~ and ~manifest~ need are quite different.  Manifests are a development thing.  Platforms are a deployment thing.

- ~Platforms~ are for runtime capabilities and are security critical.  The platform is something that gives you the only connections to the world outside Newspeak. 
- ~Manifest~ are for code construction (see ~#packageUsing: manifest~).  The Newspeak IDE provides a global namespace, which is a real object that you can pass around.  That object is a manifest.


Anyway, hopefully this helps to answer the question. 

--
Cheers, Gilad
Gilad Bracha
29 Apr 2021, 19:32:52
to newspeak...@googlegroups.com
(slightly edited and merged from other posts by Milan Zimmermann)
 

** When or why to refresh the online IDE?

Why will you refresh? Apart from the odd crash, the more common problem is the performance issues that have been discussed in this forum in December/January.  Basically, we have an unresolved problem that the system slows down painfully under prolonged/heavy use.  Refreshing and loading from backup works fairly well.  This is obviously unacceptable as you lose IDE state (debuggers, workspace/inspector contents, unsaved editors, presenter state such as what method presenters are expanded or collapsed) but it's better than an unresponsive (sluggish to dead) system.


** Why do some classes show the [deploy] [run] [debug[ links?

Only classes that the IDE considers apps (applications) show these links.

IDE concludes a class is an app based on a convention: the presence of the method ~#packageUsing: manifest~.

For details see  [[*Newspeak modules API summary][Newspeak modules API summary]] and [[*Hello World in Newspeak - several versions][Hello World in Newspeak - several versionsy]].


** Why do some test classes show the [run tests] [show tests] links?

Only classes that the IDE considers a test configuration show these links.

IDE concludes a class is an app based on a convention: the presence of the method  ~#packageTestsUsing: manifest~.

For details see [[*Newspeak modules API summary][Newspeak modules API summary]].


** How would I create and distribute a Newspeak Application to run on the web, on mobile, or on desktop?

TL;DR: We can code an app, then produce it's deployable package (a ~.vfuel~ file) in Newspeak, then deploy the ~.vfuel~ on the desktop, on the web, and on mobile.  

*** Code the app

The process of coding a Newspeak Application is described in several example in this document, one example is [[* Code, run, and debug the CounterApp in Newspeak][Code, run, and debug the CounterApp in Newspeak]]. It is also described more succintly in the 'Hello World' programs section [[*3. Hello World from Application][3. Hello World from Application]].

*** Produce the app's deployable package (a ~.vfuel~ file)

Once the app is "coded", *There are two options of producing the app's deployable package (a ~.vfuel~ file)* 

1) From the IDE: There is a 'deploy' option that the IDE displays for apps.  This option is slow but simple, and we can deploy small apps that way.  The process of building an app, the creating a deployable ~.vfuel~ package.  This process is described fully in  [[Deploy CounterApp as standalone app into local Newspeak webserver][Chapter Deploy CounterApp as standalone app into local Newspeak webserver]].
   
2) From a script: Slightly more complex to install, but works faster.  You use a script that runs the C version of the PSoup VM to do  the deployment.  This is faster, more reliable and produces smaller deployments. This is done by Step 7 of the script in [[* Newspeak: Script which builds deployable vfuel files][Newspeak: Script which builds deployable vfuel files]].
   
In either case, ~.vfuel~ file is produced.  We can then serve that file in a webserver, and run your app.

*** Deploy the app's package (the ~.vfuel~ file)

This .vfuel can then be deployed into a locally installed or a globally installed webserver.

- For instructions on how to install the server see [[* Simple methods to install and run Newspeak][Simple methods to install and run Newspeak]]
- For instructions on how to deploy a sample app, in particular the ~CounterApp~, see [[Deploy CounterApp as standalone app into local Newspeak webserver]].
  


** How does Ampleforth work to create live literate Newspeak demos such as http://bracha.org/Literate/literate.html?

TL;DR: Newspeak has a module which allows to present the Newspeak objects (the IDE, classes, instances, workspaces etc) live in any suitably marked up HTML page. This results in an experience of a live document and a literate program - a document containing multiple program snippets or whole programs. The program(s) snippet(s) inside the document can be changed, changing the results right inside the document. The program can also be explored (introspected), drilled into, etc. Everything described in this section can be played with in any of the above links:

- http://bracha.org/Literate/literate.html
- https://blog.bracha.org/illiterateProgramming/out/illiterateProgramming.html
- https://mzimmerm.github.io/2021/07/writing-live-documents-in-newspeak-ampleforth-in-org-mode

The last link also shows instructions on how to create an emacs org mode document which, after export to HTML (C-c C-e), supports such lively HTML interaction.

*Let's describe the TL;DR: in more details.*

The module providing the experience a live document and a literate Newspeak program is called ~Ampleforth~.

Ampleforth is already described in https://blog.bracha.org/illiterateProgramming/out/illiterateProgramming.html by it's author Gilad Bracha. That is definitely the reference description!

This section starts from a slightly different angle.

The Newspeak module ~AmpleforthEmbedder~ (source in AmpleforthEmbedder.ns) is responsible for "presenting" Newspeak objects to HTML, and user interaction with the objects. The module, ~Ampleforth~ is simply a wrapper, wrapping ~AmpleforthEmbedder~ as a Newspeak application.

The liveliness in HTML pages is provided by ~Ampleforth.js~, which is converted from ~Ampleforth.ns~ to Javascript.

When ~Ampleforth.js~ is placed at the end of any HTML page, it works as follows:

After the HTML is opened in a browser, the included script with  ~Ampleforth.js~ looks for <div> elements with specific class names, and inserts Newspeak objects converted to HTML in thos places.

For example, if the HTML contains a div with ~class="evaluator"~, such as

#+begin_src html
  <div class="evaluator" expression = "11+22"> </div>
#+end_src

 ~Ampleforth.js~ evaluates the expression, then inserts Newspeak result objects converted to HTML to the page (before, after, or instead of such specific elements). The 

The HTML is processed in the following call sequence: ~AmplefortEmbeddor>>#start~ -> ~AmplefortEmbeddor>>#processEvaluators~ and the methods that follow.

Here is the relevant code:

#+begin_example
  (* AmplefortEmbeddor>>#start *)
  public start = (
    processEvaluators.
    processMinibrowsers.
    processClassPresenters.
  )

  (* AmplefortEmbeddor>>#processEvaluators *)
  public processEvaluators = (
    domElementsWithClass: 'evaluator' do:
      [:element |
      | 
      expression = element getAttribute: 'expression'. 
      om <ObjectMirror> = platformMirror. 
      es = EvaluatorSubject onModel: (EvaluationViewState onModel: om).
      |
      es initialSource: expression.
      es evaluateLive: expression.
      EmbeddedHopscotchWindow
        into: element
        openSubject: es].
  )
#+end_example

In the above code we see that for each ~domElementsWithClass:~ 'evaluator' found in the HTML, the code will look for contents of attribute named ~expression~. The ~expression~ contents is evaluated, then the result of evaluation is passed to EmbeddedHopscotchWindow which is inserted to the DOM after the <div> with class 'evaluator'.

So, as long as the HTML contains a div with class ~evaluator~, such as

#+begin_src html
  <div class="evaluator" expression = "11+22"> </div>
#+end_src

the above code (or rather it's converted Javascript equivalent ~Ampleforth.js~) evaluates the expression ~11+22~, creates a ~EmbeddedHopscotchWindow~ from the evaluated result. The ~EmbeddedHopscotchWindow~ then embeds the result (instance of Number 33 presented as a div) in the DOM inside the original div.

We can look in the browser debugger how the result looks after the result div is inserted. After evaluating 11+22, the result 33 is inserted in it's own <a href> link:

[[file:img/newspeak---a-few-notes.org-ampleforth-evaluator-expression-in-debuger.png]]


Not only that, clicking on the 33 link leads to Newspeak class presenting the instance of 33! See TL;DR for links.


** How does Newspeak displays itself in DOM and HTML?

In addition to the ~Ampleforth~ class which can "insert" Newspeak elements live in any HTML page, there is a method that does a similar work for the purpose of presenting Newspeak IDE elements in the browser (when we run the IDE).

This method that does this work is ~HopscotchForHTML5>>Presenter#:ampleforth: h <String> mapping: m <Map[String, Fragment]>~. It is responsible for presenting the whole Newspeak IDE as HTML.

Let us look at this method first, before we look at an example of it's application: 

#+name:  HopscotchForHTML5>>Presenter>>#:ampleforth:mapping:
#+begin_example
ampleforth: h <String> mapping: m <Map[String, Fragment]> = (
  ^AmpleforthFragment html: h mapping: m
  )
#+end_example

*To investigate how ~HopscotchForHTML5>>Presenter>>#:ampleforth:mapping:~ results in presenting something in the IDE (that is, in the DOM) on an example, let us look at the ~Browsing>>ObjectPresenter~ class in the ~Browsing.ns~ module.*

We will show how clicking on the "Help" button [[file:img/newspeak---a-few-notes.org-help-button.png]] on an object will call a method of ~Browsing>>ObjectPresenter>>helpText~, and how this results in presenting the help text in the IDE.

The ~ObjectPresenter~ class provides a viewer for objects in the IDE. An example of ~Browsing>>ObjectPresenter~'s work is result of clicking on the "Help" button [[file:img/newspeak---a-few-notes.org-help-button.png]] on an object.

For the ~Browsing>>ObjectPresenter~ to be used, we need a place in the IDE where we see a blue link which presents an object (rather than for example class, which would use Browsing>>ClassPresenter). Go to "Workspaces" where we see a situation similar to

[[file:img/newspeak---a-few-notes.org-workspaces.png]]

This shows instance of an object. To activate ~Browsing>>ObjectPresenter>>helpText~, click on the [[file:img/newspeak---a-few-notes.org-help-button.png]] beside Workspace1. The help coming from the ObjectPresenter shows:

[[file:img/newspeak---a-few-notes.org-help-from-object-presenter.png]]
(we cut the text here)

Let us investigate how the Newspeak IDE arrives at presenting the above shown help in the IDE's DOM. As mentioned above, the core of this functionality is the method ~HopscotchForHTML5>>Presenter>>#:ampleforth: h <String> mapping: m <Map[String, Fragment]>~ .

But we need to start one level above to explore this step by step:

1. Open code for ~Browsing>>ObjectPresenter>>#helpText~.
   
2. It shows clearly the text is the same as the one displayed in the help text above:
   #+begin_example
       helpText ^ <Fragment> = (
       | mapping = Map new. |
       mapping 
         at: #hopscotchClearResultsButton put: subject evaluator presenter clearResultsButton;
         at: #classExpander put: classExpansionLink;
         at: #evaluateSelectionButton put: subject evaluator presenter evaluateSelectionButton;
         at: #invertEvalStatusButton put: subject evaluator presenter invertEvalStatusButton.
  
       ^ampleforth: 'This is an object presenter (aka  inspector).  At the top you''ll see its description, a link to the object''s enclosing object, and an expandable link to its class: <div class="classExpander"> </div> Expanding it in place allows you to see the class in the context of the instance, which can be very handy.
       <br><br>
       You can enter and evaluate Newspeak expressions in the editor pane below. They will be evaluated in the scope of the object being inspected. Shift-Return evaluates the currently selected text; if no text is selected, the current line (i.e., the line where the cursor is) is evaluated. You can also initiate evaluation of any selected text by pressing: <div class = "evaluateSelectionButton"></div> which is located above the editor on the left.
       <br><br>
     The editor can also evaluate at every keystroke; you can toggle this behavior using <div class = "invertEvalStatusButton"></div>
     also located above the editor.
     <br><br>
     Evaluation results, if any, are displayed below the editor pane. Each result is a link; clicking on it takes you an object inspector on the result.  You can clear the results list by pressing the clear button to its right: <div class="hopscotchClearResultsButton"> </div>
     <br>
     If  there are no results to display, the  results list area is blank. Below the results list you will typically see the slots of the object listed; this the basic view of objects. Some objects, such as integers or strings, have customized views. An object can have multiple views (and you can define new views as well). If there are multiple views, tab links appear underneath the results list, and you can select between them.' mapping: mapping
     )
   #+end_example

3. In the code, we can see how it first prepares a ~mapping~ map, then returns a result of message send to self ~ampleforth: aHTMLString mapping: mapping~. The message accepts the long pure HTML string we see above, and the mapping.
   - In the Html snippet, we can find references to 'special' class names:
     - ~<div class="hopscotchClearResultsButton"> </div>~
     - ~<div class="classExpander">~
     - .. etc ..
     - Note those class names (e.g. classExpander) are equivalent to the 'special' class name evaluator used by AmpleforthEmbedder, in the section [[How does Ampleforth work to create live literate Newspeak demos such as http://bracha.org/Literate/literate.html?]]
   - Clearly those class names are keys in the ~mappings~ map.
     #+begin_example
       mapping 
         at: #hopscotchClearResultsButton put: subject evaluator presenter clearResultsButton;
         at: #classExpander put: classExpansionLink;
         .. etc ..
     #+end_example
4. We can look at "find references" on this method, and find it is defined by ~HopscotchForHTML5>>Presenter>>#ampleforth:mapping:~
   #+name:  HopscotchForHTML5>>Presenter>>#:ampleforth:mapping:
   #+BEGIN_EXAMPLE
     ampleforth: h <String> mapping: m <Map[String, Fragment]> = (
       ^AmpleforthFragment html: h mapping: m
     )
   #+END_EXAMPLE
   - Also note that from the ObjectPresenter primary factory method it is clear ObjectPresenter implements ProgrammingPresenter which implements Presenter where the method ~HopscotchForHTML5>>Presenter>>#ampleforth:mapping:~ is defined.

5. The above method constructs instance of ~HopscotchForHTML5>>AmpleforthFragment~ as follows

  #+name: HopscotchForHTML5>>AmpleforthFragment>>#html:mapping:
  #+begin_example
  public class AmpleforthFragment html: h <String> mapping: m <Map[String, Fragment]> = HTMLFragment html: h (
  	|
  	mapping <Map[String, Fragment]> = m.
      document_slot <Alien[Document]>
  	|
      processMappings.
  )
  #+end_example

6. In turn the ~HopscotchForHTML5>>AmpleforthFragment>>#processMappings~ does the following work - the core of the work is call the method ~#visual~ on all Fragments in the ~mappings~:

  #+name: HopscotchForHTML5>>AmpleforthFragment>>#processMappings
  #+begin_example
  public processMappings = (
    mapping keysAndValuesDo: [:k <String> :v <Fragment> |
      v parent: self.
  	  domElementsWithClass: k do:
  		  [:element | element appendChild: v visual]
    ]
  )
  #+end_example

7. The ~#visual~ simply calls ~#createVisual~ and decorates it. But where is ~#createVisual~ defined?  
   #+begin_example
     public visual = (
       visualX isNil ifTrue: [visualX:: decorate: createVisual].
       ^visualX
     )
   #+end_example  
8. which in turn calls ~HopscotchForHTML5>>Fragment>>createVisual~, then decorates the visual result.
9. The important item here is
   #+begin_example
     createVisual = (
       subclassResponsibility
     )
   #+end_example
10. which is implemented in a large number of ~Fragment~ subclasses, such as:
    #+begin_example
      createVisual in CheckboxFragment in HopscotchForHTML5
      createVisual in ColorPickerFragment in HopscotchForHTML5
      createVisual in DatePickerFragment in HopscotchForHTML5
      createVisual in PickerFragment in HopscotchForHTML5
      createVisual in ProgressBarFragment in HopscotchForHTML5
      createVisual in RadioButtonFragment in HopscotchForHTML5
      createVisual in RectangleFragment in HopscotchForHTML5
    #+end_example

11. From the last list, we can see those are all UI elements- checkboxes, pickers, radio buttons etc. Their concrete ~createVisual~ implementations use the document object to create a representation of UI elements which are clearly equivalent to DOM object, and can be converted to DOM objects. Let's look at ~CheckboxFragment#createVisual~ as an example:

  #+begin_example
  createVisual = (
      | 
      container <Alien[Div]> = document createElement: 'div'.
      label <Alien[Element]> = document createTextNode: text.
      |
  
  	container at: 'id' put: 'CheckboxContainer'.
  
      (container at: 'style')
          at: 'display' put: 'flex';
          at: 'flex-direction' put: 'row';
          at: 'align-items' put: 'center';
          at: 'justify-content' put: 'flex-start'.
          
      checkbox:: document createElement: 'input'. 
      checkbox
          at: 'type' put: 'checkbox';
          at: 'checked' put: checked;
          at: 'oninput' put: [:event |    
              checked:: checked not.
              holder isNil ifFalse: [         
                  holder value: checked.
              ].
              action isNil ifFalse: [
                  action value: checked.
              ].
              false
          ].
      container appendChild: checkbox.
  
      container appendChild: label.
  
      (checkbox at: 'style')
          at: 'min-width' put: styleCheckboxSize;
          at: 'min-height' put: styleCheckboxSize;
          at: 'margin-right' put: '5px'.
  
      ^container.
  
  #+end_example

Seeing the creation of an Alien DOM <div> equivalent object in this last method, we conclude our discovery of "How does Newspeak displays itself in DOM and HTML?"
  
*Summary of the discovery:*

- The ~#helpText~ contains a (almost) pure HTML and ~mappings~ of special class names such as ~hopscotchClearResultsButton~, ~classExpander~, etc.
    #+begin_example
      mapping 
        at: #hopscotchClearResultsButton put: subject evaluator presenter clearResultsButton;
        at: #classExpander put: classExpansionLink;
        .. etc ..
    #+end_example
- We saw the ~#helpText~, by calling ~#ampleforth:mapping:~  created and returned an instance of class ~HopscotchForHTML5>>ApleforthFragment~
- During creation, in it's factory ~HopscotchForHTML5>>AmpleforthFragment class>>#html:mapping:~ applies on each value from ~mapping~ the ~HopscotchForHTML5>>Fragment>>#createVisual~ at the end of the chain - building the DOM-like objects (called Fragments). Those visual instances are then inserted in the DOM, putting together the Newspeak IDE!. 


*Conclusion of sequence of calls from the "Help button" click to create DOM elements with Help contents*

We followed the sequence of method calls after the "Help button" was clicked:

- ~Browsing>>ObjectPresenter>>#helpText~                             - calls Presenter self by returning:
- ~HopscotchForHTML5>>Presenter>>#ampleforth:mapping:~               - Presenter constructs and returns a Fragment ~^AmpleforthFragment html: h mapping: m~ by calling:
- ~HopscotchForHTML5>>AmpleforthFragment class>>#html:mapping:~      - This AmpleforthFragment constructor does the core of the DOM-like child fragments creation by looping through mappings in:
- ~HopscotchForHTML5>>AmpleforthFragment>>#processMappings~          - For each mapping entry, one visual is created from "entry value" in the calls below; once the visual is returned back here, it is immediately inserted here into element with class="entry key" into ~domElementsWithClass~ 
- ~HopscotchForHTML5>>Fragment>>#visual~                             - which calls "#createVisual" below
- ~CheckboxFragment#createVisual~                                    - This uses "document createElement" to create, for each mapping entry, and return an Alien DOM <div> equivalent - it contains a DOM element such as a checkbox.

We saw how this sequence is responsible of presenting Help Text (with embedded Newspeak objects) as an navigatable live HTML browser-presented in the IDE, where we can explore and drill in instances, classes, or other Newspeak artifacts.




** What are Newspeak "Exemplars"?

Exemplars are small Newspeak code examples placed inside comments.  Their role is to provide live examples of code, as well as document typical use of a class and it's methods.

See [[*Exemplars: Enabling liveliness everywhere][Exemplars: Enabling liveliness everywhere]] for details.



** Why are slot instances sometimes using uppercase name?

Here we just produce instance of hopscotchIDE on slot (note: this is instance, despite the uppercase name HopscotchIDE)
#+begin_example
  class Ampleforth packageUsing: manifest = (
    |
    private AmpleforthEmbedder = manifest AmpleforthEmbedder.
    private HopscotchIDE = manifest HopscotchWebIDE packageUsing: manifest.
    |
  ) 
#+end_example

Still not sure why??


* The Newspeak UI, *HopscotchForHTML5*: Analysing it by code browsing; Discovering *Subject*, *Model*, *Presenter*, *Fragment*; Writing *CheckedItemApp* sample App

TL;DR: This section is a code-browsing tour which discovers Hopscotch, discovering the Hopscotch MVC: the *Subject*, *Model*, *Presenter*, as well as *Fragment*, the class that translates Hopscotch classes to HTML. [[* Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*][We use the acquired insights to write a sample App with an UI, the *CheckedItemApp*]].  If you prefer to learn from complete code, [[* 5. Complete code and UI of the *CheckedItemApp*][jump to the end of that section]].

** Discovery of the *HopscotchForHTML5* class basics

*** Chapter goal

*Hopscotsch is the Newspeak module used to write UIs in Newspeak.* The version of Hopscotch used in today's (year 2021) Newspeak is called *Hopscotch for HTML5*.  It is implemented in classes nested in the module's class (top level class) named ~HopscotchForHTML5~.

The intent of this chapter is to discover things about ~HopscotchForHTML5~ mostly by browsing it's code in the IDE, plus some previously developed intuition :)

I am trying to make the process of this chapter to be like discovering things about nature by observation. In our discovery, observation = browsing code only the Newspeak IDE. By observing, we should be able to extract knowledge and make generalizations and predictions.  In our discovery, extract knowledge = understand the core API;  make generalizations and predictions = be able to write a simple UI Application of our own.

Note: One important discovery tool is missing - in the current Newspeak, debugging anything in the UI is impossible, due to some known bugs.

In other words, during our discovery process in this chapter:

- Most of the information should come from browsing through the Newspeak IDE in the top level class ~HopscotchForHTML5~.

- The end goal of our process is to write a simple Newspeak Application with UI in Hopscotch. This simple Newspeak Application is developed in chapter [[*Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*][Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*]].

- There was also the benefit of previously looking at the ~CounterApp~ (aka cheating), but as much as possible, we are trying to extract everything we need from the "first principles" of browsing the Newspeak IDE top level class ~HopscotchForHTML5~.


Two most important nested classes in ~HopscotchForHTML5~ are ~Subject~, ~Presenter~.  This statement did not come necessarily from observation (although we could claim that), but from a bit of a "previously developed intuition", as well as from the paper "Hopscotch: Towards User Interface Composition" by Vassili Bykov, 8 pages https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.478.1098&rep=rep1&type=pdf. Note that the paper is about the original Hopscotch, not the HTML5 specific version. But I feel the core of the two versions seems close enough to start with the paper.


So this chapter makes a reasonable assumption that the ~Subject~ and ~Presenter~ classes are of core importance in building UIs in Newspeak. Further, opening class ~Presenter~ in the Newspeak IDE, we see that it has a parent class ~Fragment~.  ~Fragment~ is new to the new version ~HopscotchForHTML5~ as opposed to the original ~Hopscotch~.  Because we consider ~Presenter~ important, so must be ~Fragment~. 

So, enough meta talk, and let us browse the most important code of classes  ~Subject~ and ~Presenter~ - their *primary factory methods*. As with any Newspeak class, we should start at the primary factory methods to understand the class. Primary factory method is the only code which defines slots (slots as similar to members in other OO languages). Also we see that Fragment is parent of Presenter. So ~Fragment~ must be important; we added it's primary factory method to the constructor summary as well.

#+begin_example
public class Subject onModel: aModel = (
  |
	public model = aModel.
  presenterSlot <Presenter>
  public helpActive <Boolean> ::= false.
  |)

public class Presenter onSubject: aSubject <Subject> = Fragment (
  |
  public subject <Subject> ::= aSubject.
  substanceSlot <Fragment>
  public generation <Number> = uiGeneration.
  |)

class Fragment = (
  |
	visualX
	public parent
	public size ::= nil.
	public expansibility ::= 0.
	public compressibility ::= 0.
	decorators
	|)  
#+end_example

From the primary factory methods, it is immediately clear that:

1. For a subject to be created, a model is required. So model must be created before subject.
2. For a presenter to be created, a subject is required. So subject must be created before presenter.


*** Chapter conclusion

*Lifecycle of any Hopscotch UI code:*
- *We need to instantiate a Model first.*
- *We need to instantiate a Subject on the model next.*
- *We need to instantiate a Presenter on the subject last.* 

This is quite clear from the signatures of those classes primary factory methods - there can be no other way.

A note on Newspeak syntax: while the ~Subject>>model~ slot and ~Presenter>>subject~ slots are public, they have no setters, so they are final. The value they acquire in the primary factory method cannot be changed. This is because the slots are defined using " = ", for example in ~public model = aModel.~ If the " ::= " was used instead of " = " to define the slot ~model~, then the slot  would not be final - a setter would exist. But as is, we cannot, even in principle, create the instances of Model/Subject/Presenter with null slots, change the creation order, and set the slots later.

Next two chapters will look into details of *Presenter, Subject, and Model* classes, and associations between them.  The associations may not be important for writing UIs, but they are for understanding the Hopscotch framework.


** The formulaic required repetitive methods of #isMyKind: and #isKindOfX

This chapter is jumping right into a piece that is a bit difficult to understand: The required repetitive methods of ~#isMyKind: other~ and ~#isKindOfX~.

Comments in ~Fragment~ and ~Subject~ talk about this:

*Subclasses must implement #isMyKind: which tests whether another instance is of the same kind. The implementation is #isMyKind: is formulaic, calling #isKindOfX for whatever type X the instance represents*

Because ~Presenter~ is a subclass of ~Fragment~, the equivalent of the above statement applies to ~Presenter~.

Let us summarize a practical translation of this piece of documentation:

*Any time we write a concrete implementation of ~Presenter~, ~Subject~ or ~Fragment~, we must implement two methods.  Suppose a concrete Presenter class is named ~MyConcretePresenter~.  In this class, we have to implement methods ~#isMyKind: other~ and ~#isKindOfMyConcretePresenter~ as follows:*

#+begin_example
  isMyKind: other <Fragment> ^ <Boolean> = (
    ^other isKindOfMyConcretePresenter.
  )

  isKindOfMyConcretePresenter <Boolean> = (
    ^true.
  )
#+end_example

Similar code needs to be added to any concrete implementation of ~Fragment~ or ~Subject~. Just replace the "Presenter" with "Fragment" or "Subject".

In the chapters below, we will not come back to this in too much detail, and always add such methods in our code.


** The *Subject* class: primary factory method, instance methods, how Subject knows Presenter

*** Chapter goal: Overview of the *Subject* class

This chapter is about the ~Subject~ class, in particular about three "important parts" we should know to understand the Newspeak UI.  Those parts are also important when we write code for concrete implementations of ~Subject~.

Let us show the code for the ~Subject~ class, keeping only the "important parts" - each of them is discussed in subchapters below.

~From class Subject~
#+begin_example

(* 1. The primary factory method *)

public class Subject onModel: aModel = (
  |
  public model = aModel.
  presenterSlot <Presenter>
  public helpActive <Boolean> ::= false.
  |
) (


  (* 2. The methods that deal with associating Subject and Presenter instances *)
  
  public createPresenter ^<Presenter> = (
    subclassResponsibility
  )
  public presenter ^<Presenter> = (
    presenterSlot isNil ifTrue: [presenterSlot:: createPresenter].
    presenterSlot generation < uiGeneration ifTrue: [
      presenterSlot:: createPresenter.
      ].
    ^presenterSlot
  )

  
  (* 3. Unimplemented (abstract) methods which a concrete Subject implementation must provide *)
  
  isMyKind: s <Subject> ^ <Boolean> = (
    subclassResponsibility
  )

  
  (* Several other methods *)
)
#+end_example

In the subchapters below, we go over each of the "important parts".


*** The primary factory method *public class Subject onModel: aModel = (..)*

This is the code which creates instances, and should be called from implementations' primary factory methods. The code hold slots for ~model~, the associated ~presenterSlot~ and a help slot. For a practical purpose of writing UIs, this is the most important code.

Concrete implementations of Subject, should (in fact must, it is enforced) invoke the Subject's factory as 

~public class MyConcreteSubject onModel: aModel = Subject onModel: aModel (|pseudeSlots|) (pseudoInstanceMethods) : (pseudoClassMethods)~  

This should be sufficient for most concrete implementations of Subject.

**** Note on extending a Newspeak class

The syntax above shows how to *extend* a class in Newspeak. Here is how we read (parse) the syntax

~public class MyConcreteSubject onModel: aModel = Subject onModel: aModel (|pseudeSlots|) (pseudoInstanceMethods) : (pseudoClassMethods)~  

1. The section ~public class MyConcreteSubject onModel: aModel =~ defines the *primary factory* as usual, with name ~MyConcreteSubject>>onModel:~
2. However, the "inserted" section ~Subject onModel: aModel~ defines:
   - The *superclass* of ~MyConcreteSubject~ to be ~Subject~
   - The *primary factory* of ~Subject~
   - That at runtime, when the  *primary factory* of ~MyConcreteSubject~ (the  ~MyConcreteSubject>>#onModel:~) is invoked, Newspeak will *first invoke the 'superclass primary factory'*, the ~Subject>>#onModel:~.
3. The last section ~(|pseudeSlots|) (pseudoInstanceMethods) : (pseudoClassMethods)~ is the usual syntax which continues with the definition of the slots, instanceMethods, and classMethods of ~MyConcreteSubject~.

 
*** The unimplemented (abstract) methods: *Subject>>#createPresenter* and *Subject>>#isMyKind: otherSubject*

The full signatures of the unimplemented methods which each concrete Subject implementation must provide are:

- ~Subject>>#public createPresenter ^<Presenter>~ should return the concrete Presenter instance which will present the subject. This was also discussed in the chapter above.
- ~Subject>>#isMyKind: otherSubject ^<Boolean>~   is repetitive but required. We have a common chapter for this, see [[*The formulaic required repetitive methods of #isMyKind: and #isKindOfX][The formulaic required repetitive methods of #isMyKind: and #isKindOfX]]
  
#+begin_example
  public createPresenter ^<Presenter> = (
    subclassResponsibility
  )
    
  isMyKind: s <Subject> ^ <Boolean> = (
    subclassResponsibility
  )
#+end_example

In any concrete implementation of Presenter, those methods must be provided.

**** The method ~#Subject>>createPresenter~ discovery from existing implementations

Let us discover, from code browsing, what a concrete implementation of ~Subject>>#createPresenter~ should do.

From the name and signature, clearly the ~Subject>>#createPresenter~ should return a new instance of ~Presenter~. Supposedly this is the actual UI instance.

We can get some hints about Presenter implementations in existing Subject extensions from the IDE.  Here is an example of ~#createPresenter~ from ~HomeSubject~. All Subject implementations do something equivalent:

~From class HomeSubject~
#+begin_example
  public createPresenter = (
	  ^HomePresenter onSubject: self
  )
#+end_example

*Conclusion: It seems clear that in any concrete implementation of ~Subject~ the method  ~#createPresenter~ is intended to create and return the Presenter we want to use to present the Subject.*
 



*** The method *Subject>>#presenter* creates the subject's presenter by calling the *Subject>>#createPresenter*, then associate the instances

**** Chapter goal

Goal is to discuss how a ~Presenter~ instance is created, and where are the Subject <-> Presenter associations created.




**** Where is Subject -> Presenter association created? In *Subject>>#presenter*

The exact signature is ~Subject>>#public presenter ^<Presenter>~.

~Subject~ holds association to it's ~Presenter~ in the ~Subject>>presenterSlot~. This slot is instantiated lazily in ~Subject>>#presenter~ by calling ~Subject>>#createPresenter~, then storing the instantiated presenter on the ~presenterSlot~:

~Subject~
#+begin_example
  public presenter ^<Presenter> = (
    presenterSlot isNil ifTrue: [presenterSlot:: createPresenter].
    presenterSlot generation < uiGeneration ifTrue: [
      presenterSlot:: createPresenter.
      ].
    ^presenterSlot
  )
#+end_example

So as long as something calls ~Subject>>#presenter~, after a Subject is created, then *the ~Subject~ knows about it's ~Presenter~ and keeps in on slot ~presenterSlot~, establishing the Subject->Presenter association* - which is what we wanted to show.



**** Where is Presenter -> Subject association created? In the Presenter primary factory method *Presenter>>#class Presenter onSubject: aSubject = Fragment*

The exact signature is public class ~Presenter onSubject: aSubject <Subject> = Fragment (..)~

We can find our answer in a few steps, starting with ~Subject>>#presenter~:

1. ~Subject>>#public presenter ^<Presenter>~ calls ~Subject>>#public createPresenter ^<Presenter>~

2. ~Subject>>#public createPresenter ^<Presenter>~ creates the Presenter. While this method is abstract, we can discover what it is intended to do:
   - a) From its signature ~Subject>>#public createPresenter ^<Presenter>~
   - b) By looking as a concrete Presenter implementations in the IDE.  Here is an example of a concrete ~#createPresenter~ from ~HomeSubject~

      ~From class HomeSubject~
      #+begin_example
        public createPresenter = (
  	      ^HomePresenter onSubject: self
        )
      #+end_example
      Clearly the conclusion from both is this: The intent of ~Subject>>#public createPresenter ^<Presenter>~ is to create a presenter which presents the ~Subject~ instance, and return it
3. Next, let us study the concrete discovered example of ~HomePresenter~'s primary factory method.
   #+begin_example
     class HomePresenter onSubject: s = Presenter onSubject: s (
     )
   #+end_example
   This is a standard Newspeak syntax for a super call. The primary factory method ~HomePresenter>>#onSubject: subject~ calls the superclass ~Presenter>>#onSubject: subject~ 

   Having shown that, we can get back to this line:

   ~HomePresenter onSubject: self~ - note that self is subject

   This will cause the call to the "super" ~Presenter>>#onSubject: subject~. This "super" ~Presenter>>#onSubject: subject~ call places the passed subject on slot "subject" in the Presenter's primary factory method:

  #+begin_example
  public class Presenter onSubject: aSubject <Subject> = Fragment (
    |
    public subject <Subject> ::= aSubject.
    substanceSlot <Fragment>
    public generation <Number> = uiGeneration.
    |)
  #+end_example
  
4. So this line ~public subject <Subject> ::= aSubject~ creates the association from Presenter -> Subject. The associated subject instance is kept on slot ~Presenter>>subject~.


This is what we have shown in summary: Calling a concrete subject's #presenter such as ~HomeSubject#presenter~ will associate Presenter -> Subject.

Also, along with the previous chapter, callin ~Subject>>#presenter~ also creates the association "the other way". By calling ~Subject>>#presenter~, the bidirectional associations Presenter <-> Subject is established.

"Some code" must call the ~Subject>>#presenter~ though.


*** Chapter conclusion about principles of writing rudimentary Hopscotch UI

In the conclusion of chapter [[*Discovery of the *HopscotchForHTML5* class basics][Discovery of the *HopscotchForHTML5* class basics]] we already discovered an important lifecycle any UI code need to perform: *Create an instance of a Model first, a Subject next, a Presenter last*.
   
In this chapter [[*The *Subject* class: primary factory method, instance methods, how Subject knows Presenter][The *Subject* class: primary factory method, instance methods, how Subject knows Presenter]] we added the following conclusions:

*Conclusion 1: As long as the ~Subject>>#presenter~ is invoked (on an existing subject instance), two important things happen:*
- A ~Presenter~ instance is created.
- The bidirectional association between the subject and presenter instances is established.

*Conclusion 2: So, when creating UIs, our code must invoke the ~Subject>>#presenter~ method, directly, or indirectly by calling some other method that ends up calling ~Subject>>#presenter~.*

*Conclusion 3: Model can be any object.  ~ConcreteSubject~ must extend the ~Subject~.  Also the ~ConcreteSubject~ primary factory method must declare the primary factory method on the superclass ~Subject~ - see [[*The primary factory method *public class Subject onModel: aModel = (..)*][The primary factory method *public class Subject onModel: aModel = (..)*]] ; chapters below come to the equivalent conclusion for ~ConcretePresenter~.*

Based on the conclusions 1, 2, 3, we can already write some pseudocode for writing core UI:

*intermediary code - do not use yet*
#+begin_example
|concreteModel concreteSubject concretePresenter|
concreteModel:: ConcreteModel new.
concreteSubject:: ConcreteSubject onModel: concreteModel.
concreteSubject presenter.
#+end_example

Note the last line ~concreteSubject presenter.~: Why did we not use ~concreteSubject:: ConcretePresenter onSubject: concreteSubject.~ instead, as seemingly this would achieve the presenter creation anyway?

The answer to this question is as follows: While the latter code is certainly possible to use in principle, we have seen in the overview of Subject APIs above, that Hopscotch provides the method ~Subject>>#presenter~ which not only creates the Presenter instance by calling ~Subject>>#createPresenter~, but also wires up the Presenter <-> Subject associations!

Clearly, the framework intents application code not to create Presenter instances directly, but intends for application code to call ~Subject>>#presenter~. However, this call should not be made directly in application code either. In chapter [[*HopscotchForHTML5: Analyzing senders of *Subject>>#presenter* and why *HopscotchWindow>>#openSubject: subject* should be invoked instead][HopscotchForHTML5: Analyzing senders of *Subject>>#presenter* and why *HopscotchWindow>>#openSubject: subject* should be invoked instead]] we provided some long reasoning for the following conclusion:

*Conclusion 4: The root level of an application should not create ~Presenter~ directly or by calling ~Subject>>#presenter~ directly. Instead, application should invoke*

~HopscotchWindow>>#openSubject: subject~

This invocation eventually invokes ~Subject>>#presenter~ as intended, but does additional work of placing the creater ~Presenter~ instance in the context of the container body.

So we arrived at a summary conclusion.

*Summary conclusion: Here is the code for a barebones Hopscotch App*

#+begin_example
|concreteModel concreteSubject concretePresenter|
concreteModel:: ConcreteModel new.
concreteSubject:: ConcreteSubject onModel: concreteModel.
hopscotchWindow openSubject: concreteSubject.
#+end_example

The last line will create instance of ConcretePresenter by calling ~ConcreteSubject>>#presenter~ and open it in a new window where the Application will live! This snippet does not show definitions of ~ConcreteModel~ ~ConcreteSubject~ ~ConcretePresenter~, or how we obtain the ~hopscotchWindow~. We will get to that when creating a concrete Application in [[*Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*][Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*]]


** The *Presenter* class: primary factory method, instance methods, how Presenter knows Subject

*** Chapter goal: Overview of the *Presenter* class

This chapter is about the ~Presenter~ class, in particular about three "important parts" we should know to understand the Newspeak UI.  Those parts are also important when we write code for concrete implementations of ~Presenter~.

Let us show the code for the ~Presenter~ class, keeping only the "important parts" - each of them is discussed in subchapters below.

#+begin_example

(* The primary factory method.
   The constructor also creates the association from Presenter instance to Subject instance
   by keeping the associated subject slot
*)

public class Presenter onSubject: aSubject <Subject> = Fragment (
  |
  public subject <Subject> ::= aSubject.
  substanceSlot <Fragment>
  public generation <Number> = uiGeneration.
  |
) (
  
  
  (* The unimplemented (abstract) method "definition"
     which a concrete Presenter implementation must provide
  *)
  
  public definition ^<Fragment> = (
    subclassResponsibility
  )

  (* Further unimplemented (abstract) methods inherited from Fragment *)

  isMyKind: f <Fragment> ^ <Boolean> = (
    subclassResponsibility
  )
  
  (* A few selected methods which allow Presenter instances to create instances of Fragments - Fragments are UI Widgets
  *)

  row: definitions = (
	  ^RowComposer definitions: definitions
  )
  button: label <String> action: block <[]> = (
    ^ButtonFragment label: label action: block
  )
  checkbox: text <String> value: v <Holder> action: a <[:Boolean]> = (
    ^CheckboxFragment text: text value: v action: a
  )
  radioButton: text <String> value: v <Holder> group: g <Integer> action: a <[:Boolean]> = (
    ^RadioButtonFragment text: text value: v group: g action: a
  )
  rectangle = (
    ^RectangleFragment new
  )
)
#+end_example

In the subchapters below, we go over each of the "important parts".


*** The primary factory method *class Presenter onSubject: aSubject = Fragment (..)*

The primary factory method has the exact signature 

~public class Presenter onSubject: aSubject <Subject> = Fragment (..)~

It creates a presenter on subject, and also establishes the  association from Presenter instance to Subject instance as slot ~Presenter>>subject~.



*** The unimplemented (abstract) methods: *Presenter>>#definition* and *Presenter>>#isMyKind: fragment*

The precise signatures of unimplemented methods that each concrete Presenter must provide:

- ~Presenter>>#public definition ^<Fragment>~ should create and return the actual "widget" (presentation view)
  
- ~Presenter>>#isMyKind: f <Fragment> ^<Boolean>~ is repetitive but required. It is inherited from class ~Fragment~. We have a common chapter for this, see [[*The formulaic required repetitive methods of #isMyKind: and #isKindOfX][The formulaic required repetitive methods of #isMyKind: and #isKindOfX]]

**** The method *Presenter>>#definition* - provides the UI view

Full signature is ~Presenter>>#definition ^<Fragment>~.

This method is of core significance when writing UIs.

The concrete implementations should return the actual "widget" (presentation) - basically, *this method returns the widget we want to see in the UI*.

#+begin_example
  public definition ^<Fragment> = (
    subclassResponsibility
  )
#+end_example

For a sample implementation, see the ~#definition~ method in [[*Class CheckedItemPresenter][Class CheckedItemPresenter]], or in the complete code in [[*5. Complete code and UI of the *CheckedItemApp*][5. Complete code and UI of the *CheckedItemApp*]].


*** Instance methods on Presenter that create instances of Fragments

Fragments are UI Widgets.

It is worth realizing there are instance methods on Presenter which can create Fragments (widgets). Such widgets perform
- layout (see method ~#row:~ or ~#column:~ on class Presenter)
- "atomic" widgets (see method ~#button: label~ or ~checkbox: text~

Browse the IDE for more details.



*** Presenter extends Fragment

In addition, from the Presenter factory

  #+begin_example
  public class Presenter onSubject: aSubject <Subject> = Fragment (
    |
    public subject <Subject> ::= aSubject.
    substanceSlot <Fragment>
    public generation <Number> = uiGeneration.
    |)
  #+end_example

we see that Presenter extends Fragment.

What is Fragment and what is it's role? Let us look at Fragment in a separate chapter.



** The *Fragment* class

From looking at ~Presenter~, we have already seen that ~Fragment~ is a base class for Presenter. ~Fragment~ is the root of the hierarchy for logical UI tree nodes.

Although an important part of HopscotchForHTML5, we will not talk about Fragments beside showing it's slots - reason is we will not need Fragment to write our concrete simple app.

#+begin_example
class Fragment = (

  |
	visualX
	public parent
	public size ::= nil.
	public expansibility ::= 0.
	public compressibility ::= 0.
	decorators
	|)
#+end_example


** Summary of *Subject* and it's model, *Presenter* and *Fragment*, their associations, and their lifecycle

Let us summarize the core classes of Hopscotch: *Subject* and it's model, *Presenter* and *Fragment* described in chapters above.

1. ~Subject~: can be thought of as "address + viewport"; is passed to NavigationHistory; instantiates it's Presenter;

   See [[*The *Subject* class: primary factory method, instance methods, how Subject knows Presenter][The *Subject* class: primary factory method, instance methods, how Subject knows Presenter]]

2. ~Presenter~: presents domain objects; is part of hierarchical structure of presenters; instantiates and controls Widgets (Fragments); once instantiated, is the UI presentation of it's Subject;

   See [[*The *Presenter* class: primary factory method, instance methods, how Presenter knows Subject][The *Presenter* class: primary factory method, instance methods, how Presenter knows Subject]]

3. Important methods:
   
   - ~Subject>>#presenter~ - calls ~Subject>>#createPresenter~ then *associates Subject -> Presenter*. See [[*Where is Subject -> Presenter association created? In *Subject>>#presenter*][Where is Subject -> Presenter association created? In *Subject>>#presenter*]]
   - ~Subject>>#createPresenter~ creates and returns the presenter instance by calling the concrete Presenter's primary factory method. See [[*The unimplemented (abstract) methods: *Subject>>#createPresenter* and *Subject>>#isMyKind: otherSubject*][The unimplemented (abstract) methods: *Subject>>#createPresenter* and *Subject>>#isMyKind: otherSubject*]]
   - ~Presenter>>#definition~ creates the Fragment the presenter uses to present itself (view). See [[*The unimplemented (abstract) methods: *Presenter>>#definition* and *Presenter>>#isMyKind: fragment*][The unimplemented (abstract) methods: *Presenter>>#definition* and *Presenter>>#isMyKind: fragment*]]
   - ~class Subject>>#onModel: aModel~ - *primary factory method associates Subject -> Model*. See [[*The primary factory method *public class Subject onModel: aModel = (..)*][The primary factory method *public class Subject onModel: aModel = (..)*]]
   - ~class Presenter>>#onSubject: selfSubject~ - *primary factory method associates Presenter -> Subject*. See [[*The primary factory method *class Presenter onSubject: aSubject = Fragment (..)*][The primary factory method *class Presenter onSubject: aSubject = Fragment (..)*]]
 
4. We established that associations between ~*Subject* and it's model, *Presenter* and *Fragment*~ are as follows:
   - *Presenter -> Subject -> Model*
   - *Presenter <- Subject <-w Model* (-> and <- means association, <-w means weak association- may not exist in some implementations)
   - Both directions in the *Presenter <-> Subject* association are established by calling the ~Subject>>#presenter~ method
   - The *Subject -> Model* association is established in the Subject primary factory method ~Subject class>>#onModel: aModel~.
   
   See [[*Where is Subject -> Presenter association created? In *Subject>>#presenter*][Where is Subject -> Presenter association created? In *Subject>>#presenter*]] and [[*Where is Presenter -> Subject association created? In the Presenter primary factory method *Presenter>>#class Presenter onSubject: aSubject = Fragment*][Where is Presenter -> Subject association created? In the Presenter primary factory method *Presenter>>#class Presenter onSubject: aSubject = Fragment*]]
   
5. Lifecycle discoveries: We need to create a model first, a subject next, a presenter last. See [[*Chapter conclusion about principles of writing rudimentary Hopscotch UI][Chapter conclusion about principles of writing rudimentary Hopscotch UI]] for many details and also  [[*Discovery of the *HopscotchForHTML5* class basics][Discovery of the *HopscotchForHTML5* class basics]]

6. Presenter should not be constructed in code directly using it's primary factory method. It should be constructed indirectly as ~hopscotchWindow openSubject: concreteSubject.~. See [[*Chapter conclusion about principles of writing rudimentary Hopscotch UI][Chapter conclusion about principles of writing rudimentary Hopscotch UI]].

7. To implement some concrete UI, developer should:
   - implement classes for ~ConcreteModel~,  ~ConcreteSubject~, and ~ConcretePresenter~
   - All abstract methods in the above classes must be implemented. In particular, code methods to implement are
     - ~ConcreteSubject>>#createPresenter~ which should create and return presenter for the subject. This should return typically, ~ConcretePresenter onSubject: self~
     - ~ConcretePresenter>>#define~ which should create and return the Fragment (Presenter). This is a widget or multiple widgets layed out (e.g. row with a checkbox, label, and an icon) 
   - Write rudimentary code in [[*Chapter conclusion about principles of writing rudimentary Hopscotch UI][Chapter conclusion about principles of writing rudimentary Hopscotch UI]]

     
The above steps should be sufficient to write a basic Application with Hopscotch UI, which we will do in later chapter [[*Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*][Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*]].



** Back to *HopscotchForHTML5* and how it relates to *HopscotchForHTML5Runtime*

*** Chapter goal

The goal of this chapter is to discover more about ~HopscotchForHTML5~ and how it relates to ~HopscotchForHTML5Runtime~.

Ok, so we "know" that ~HopscotchForHTML5~ provides the Newspeak UI for the web version. We have seen it defines (as nested classes) the core UI classes ~Subject~, ~Presenter~, and ~Fragment~.

Looking at the top level, we see two related classes, ~HopscotchForHTML5~ and ~HopscotchForHTML5Runtime~. So what is the latter class good for?



*** The *HopscotchForHTML5* class

Let us get back for a minute to ~HopscotchForHTML5~. We have seen, that is has a ton of slots and classes we would associate with UI elements, such as

#+begin_example
  (* primary factory method *)
  class HopscotchForHTML5 usingPlatform: p images: images ducts: ds = (
    |
    (* Imports *)
  	private Color = p graphics Color.
  	private Context = p graphics Context.
    private Holder = ds Holder.
    private Font = p fonts Font.
    .. etc ..
    public styleZebraPrimaryColor = Color white.
  	public styleZebraSecondaryColor = Color gray: 0.97.
  	|)
#+end_example

#+begin_example
(* Selected nested classes *)
class ButtonFragment
class DatePickerFragment
.. etc ..
class Subject
class Presented
class Fragment
.. etc ..
#+end_example

We alreary concluded that we will need an instance of ~HopscotchForHTML5~ if we want to build any UI for our Apps.


*** The *HopscotchForHTML5Runtime* class

Analyzing the class ~HopscotchForHTML5Runtime~, we see that:

- It has the primary factory method ~#packageUsing: manifest~. From the Api chapters, for example  [[*4. Application module: API of module that needs to be distributed as an App][4. Application module: API of module that needs to be distributed as an App]] we know that such top level classes are apps, but, lacking the ~#main: platform args: args~ method, such module is used as library module.
  
- It packages the UI class, ~HopscotchForHTML5~, on it's slot

- It has a instance method ~#using: platform~, which calls the primary factory method of ~PlatformWithHopscotch~ and returns it's instance.

~HopscotchForHTML5Runtime~
#+begin_example
(* primary factory method *)
class HopscotchForHTML5Runtime packageUsing: manifest = (
	|
	private Fonts = manifest FontsForHTML5.
  private Graphics = manifest GraphicsForHTML5.
	private TextModule = manifest TextModule.
	private Hopscotch = manifest HopscotchForHTML5.
  private Ducts = manifest Ducts.
	private images = Images packageUsing: manifest.
	|
)

(* instance method *)
public using: platform = (
	^PlatformWithHopscotch usingPlatform: platform
)
#+end_example

The presence of the two methods clearly shows  ~HopscotchForHTML5Runtime~ packages all three classes (HopscotchForHTML5, Ducts, images) that we will need to create ~HopscotchForHTML5~ using its primary factory method ~HopscotchForHTML5>>#usingPlatform: p images: images ducts: ds~.

*So, the HopscotchForHTML5Runtime packages everything we need for HopscotchForHTML5*

In addition, we see that the inner class ~HopscotchForHTML5Runtime>>PlatformWithHopscotch~ is a convenience class which already pre-creates instance of ~HopscotchForHTML5~ in this ~PlatformWithHopscotch~ snippet:

#+begin_example
(* primary factory method *)
class PlatformWithHopscotch usingPlatform: platform = (
	|
    public isKindOfPlatformWithElectron = platform isKindOfPlatformWithElectron.	
    public kernel = platform kernel.
    public collections = platform collections.
    public actors = platform actors.
    public mirrors = platform mirrors.    
    public js = platform js.
    public operatingSystem = platform operatingSystem.
    public fonts = Fonts usingPlatform: self.
    public graphics = Graphics usingPlatform: self.
    public text = TextModule usingPlatform: self.
    public hopscotch = Hopscotch usingPlatform: self images: images ducts: (Ducts usingPlatform: self).
    public local = platform.
    public victoryFuel = platform operatingSystem = 'emscripten' ifTrue: [platform victoryFuel].
	|
)
#+end_example

*A core question: what object is in the slot ~hopscotch~ in the above factory?* Let's follow these points:

1. ~HopscotchForHTML5Runtime~, the outer class of ~PlatformWithHopscotch~ creates this slot:

  ~private Hopscotch = manifest HopscotchForHTML5.~

  clearly, the ~Hopscotch~ slot on ~HopscotchForHTML5Runtime~ holds the class ~HopscotchForHTML5~.
  
2. Next we see this line in the ~PlatformWithHopscotch~ primary factory method above - the ~class PlatformWithHopscotch usingPlatform: platform~:
   
  ~public hopscotch = Hopscotch usingPlatform: self images: images ducts: (Ducts usingPlatform: self)~

  uses the expression ~Hopscotch~. What does it refer to?? In Newspeak, an expression like this used in a primary factory method slot, must be somewhere in the scope of the primary factory method's scope! The only items in scope there, must be in a slot of a parent class! Parent class of ~PlatformWithHopscotch~ is ~HopscotchForHTML5Runtime~. So this ~Hopscotch~ we are talking about here refers to a ~Hopscotch~ slot in ~HopscotchForHTML5Runtime~. And we have seen in item 1, that it holds the class ~HopscotchForHTML5~. As a result, the primary factory method in

  ~public hopscotch = Hopscotch usingPlatform: self images: images ducts: (Ducts usingPlatform: self)~

  is the same as

  ~public hopscotch = HopscotchForHTML5 usingPlatform: self images: images ducts: (Ducts usingPlatform: self)~



From there we have the answer to our core question of this paragraph: *The slot ~hopscotch~ in the factory for PlatformWithHopscotch is instance of ~HopscotchForHTML5~*

*Now let's draw two conclusions we arrived at in this paragraph:*

1. *Conclusion 1. The module HopscotchForHTML5Runtime is a packaging library for instances of HopscotchForHTML5. By packaging the runtime, everything we need to write UI code is available in the HopscotchForHTML5 instance. How do we get such instance? This is described in Conclusion 2.*

2. *Conclusion 2. Any code that is able to create ~hopscotchForHTML5Runtime~, an instance of ~HopscotchForHTML5Runtime~ will have access to instance of ~HopscotchForHTML5~ using the second line below:*

  ~hopscotchForHTML5Runtime using: platform.~ <== this is instance of PlatformWithHopscotch
  ~(hopscotchForHTML5Runtime using: platform) hopscotch.~ <== hopscotch is the slot on PlatformWithHopscotch. It is instance of HopscotchForHTML5 as we have seen above.


Summary: In this chapter, we deduced code we need to obtain ~hopscotch~, an instance of ~HopscotchForHTML5~. This instance is all we need to write any Newspeak UI!


** Using Hopscotch discovery a Model-Presenter-Subject Application, the *CheckedItemApp*

*** Chapter goal

This chapter uses Hopscotch knowledge acquired in the above chapters, to develop a sample UI Application in Newspeak. 

As with other Applications with UI, we will need two top level classes. Let us name the Application class ~CheckedItemApp~ and it's UI class ~CheckedItemUI~.  The basic structure of an Application with UI was already described on several examples, including [[* Code, run, and debug the CounterApp in Newspeak][Code, run, and debug the CounterApp in Newspeak]] .

The knowledge about a structure of a UI class, the Model-Presenter-Subject was developed by browsing the ~HopscotchForHTML5~ in [[* Discovery of the *HopscotchForHTML5* class basics][Discovery of the *HopscotchForHTML5* class basics]], and is used below in [[*3. Write code for *CheckedItemUI*, the class showing the UI][3. Write code for *CheckedItemUI*, the class showing the UI]].


*** 1. Start coding the Application class *CheckedItemApp*

We will use information about APIs that define a Newspeak Application from chapter [[*4. Application module: API of module that needs to be distributed as an App][4. Application module: API of module that needs to be distributed as an App]]  and [[*3. Hello World from Application][3. Hello World from Application]] to create the application class ~CheckedItemApp~.

First, we create the class for a top level Application module.  We can create this class in the IDE, or create the class in a text file, then [[compile-files]["Compile file(s)"]].  We start with a text file.

Regarding the methods the ~CheckedItemApp~ class should have, there should be a primary factory ~#packageUsing: manifest~ and an instance method ~#main: platform args: args~. This makes the class a packageble, distributable, and runnable Newspeak app (an Application module).  See [[* Newspeak modules API zoo][Newspeak modules API zoo]] for Newspeak "convention methods" signatures.


  ~class CheckedItemApp~
  #+begin_example 
  class CheckedItemApp packageUsing: manifest = ()
  (
    public main: platform args: args = (
      'Hello World from HelloWorldApp' out.
    )
  )
  #+end_example
  
*** 3. Write code for *CheckedItemUI*, the class showing the UI

Chapter introduction and goal: In this chapter, we will write  ~CheckedItemUI~, the UI of the application.  The UI code will be spread over several nested classes of the top level class ~CheckedItemUI~.  To write this UI, we will use the knowledge discovered and summarized in chapter [[*Summary of *Subject* and it's model, *Presenter* and *Fragment*, their associations, and their lifecycle][Summary of *Subject* and it's model, *Presenter* and *Fragment*, their associations, and their lifecycle]].   We will need to create concrete nested classes for the *Model, Subject and Presenter*, then we will need to instantiate those classes (in that order) to form the UI.

The UI will be extremely simple: a label with text "check this", and one check box. We should be able to check the checkbox. That is all.

Note that we will not write any *Fragment* (Widget) classes, we only use some preexisting fragment-creation methods discovered by browsing ~HopscotchForHTLM5>>Presenter~ such as ~#row:~, ~#label:~ and ~#checkbox:~.

Chapters below describe writing the code for *CheckedItemUI* step by step.

**** Class CheckedItemUI

Let's add a new top level class ~CheckedItemUI~.

We plan for the new top level class ~CheckedItemUI~ to contain:

1. Slots needed to create elements in the instance of this class. 
  
2. Nested classes ~CheckedItemModel~, ~CheckedItemSubject~ and ~CheckedItemPresenter~ which we will create below. Important: Notice that these classes are nested in the top level class (module) ~CheckedItemUI~.  This is a natural modularization we would use in Newspeak; so the classes' naming prefix ~CheckedItem~ in ~CheckedItemModel~ and other nested classes introduced in this chapter is not needed. We will keep the class names prefix for the purpose of clarity of the text.  Also notice this nesting mimics the nesting of ~Subject~ and ~Presenter~ in the module ~HopscotchForHTML5~.


We can start only with the barenones of our UI, like this:

~class CheckedItemUI~
#+begin_example
  class CheckedItemUI = () ()
#+end_example

We will add it's primary factory method, slots, and it's nested classes along the way in later chapters.  In particular we will add:

- The nested classes will be added naturally by adding them inside ~CheckedItemUI~ in the IDE. This happens in chapters [[*Class CheckedItemModel][Class CheckedItemModel]],  [[*Class CheckedItemSubject][Class CheckedItemSubject]],  and [[*Class CheckedItemPresenter][Class CheckedItemPresenter]] .
  
- The primary factory method and slots will be added once we finish the rest of the app code and the UI code - in chapter [[*When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*][When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*]] and its subchapters.


**** Class CheckedItemModel

As discussed in [[*Summary of *Subject* and it's model, *Presenter* and *Fragment*, their associations, and their lifecycle][Summary of *Subject* and it's model, *Presenter* and *Fragment*, their associations, and their lifecycle]], we start writing UI with writing the model class. As this is a part of the UI, a natural way to express such composition is to make the model class *a nested class in ~CheckedItemUI~.*

Let's name the model class ~CheckedItemModel~.

To support the UI, we need two slots in our model: a string for the ~itemText~, and a Boolean ~isChecked~, representing if the checkbox was selected. We also add a third slot ~itemTextWithStatus~ for tracking the ~isChecked~ as text.  Our model class extends Object by default; it's primary factory method is the default ~#new~ method. Neither the default parent class Object nor the default primary factory method ~#new~ need to be specified in Newspeak. 

~class CheckedItemModel~
#+begin_example
public class CheckedItemModel = (
|
  public itemText = 'Not Editable Todo itemText: '.
  public itemTextWithStatus ::= itemText, ' : STILL TODO'.
  public isChecked ::= false.
  |
) (
)
#+end_example



**** Class CheckedItemSubject

Having defined a model class ~CheckedItemModel~, we need to define our UI's concrete Subject class, let's name it ~CheckedItemSubject~. Naturally, it will be an extension of Subject. As mentioned, it will be nested in ~CheckedItemUI~.

Recall from [[*The *Subject* class: primary factory method, instance methods, how Subject knows Presenter][The *Subject* class: primary factory method, instance methods, how Subject knows Presenter]] that the primary factory method of Subject is ~Subject>>#onModel: model~. This will associate subject with it's model.  We will use the same name for the primary factory method for our ~CheckedItemSubject~ and call the super factory from Subject.

We will also use the knowledge from the same chapter regarding it's primary factory method and abstract methods we need to implement. Let us summarize it here again: 

- The primary factory method of our ~CheckedItemSubject~ will call the primary factory method of it's parent, ~Subject>>#onModel: model~.  This is expressed by the signature ~public class CheckedItemSubject onModel: model = Subject onModel: model~ where our new class calls the super primary factory ~Subject>>#onModel: model~.

- ~Subject~ class has an abstract method ~#createPresenter~ (indicated by "subclassResponsibility") which should return a presenter. In the same link, we saw that ~#createPresenter~ should create an instance of Presenter (the yet-to-be-created ~CheckedItemPresenter~). The instance should then be returned. 

- We need to add the formulaic implementations of ~#isMyKind~ and ~#isKindOfCheckedItemSubject~. See [[*The formulaic required repetitive methods of #isMyKind: and #isKindOfX][The formulaic required repetitive methods of #isMyKind: and #isKindOfX]].

So the code for our concrete Subject ~CheckedItemSubject~ which implements the desired primary factory method and all abstract methods implemented should be:

~class CheckedItemSubject~
#+begin_example
public class CheckedItemSubject onModel: model = Subject onModel: model (
) (
(* Important override: Creates Presenter. Called by the framework in openSubject called
   from ~CheckedItemApp>>#main:args:~ when calling ~HopscotchWindow openSubject: checkedItemSubject.~
   Framework also associates Subject -> Presenter via Subject>>#presenterSlot:: ^createPresenter
*)
createPresenter = (
    ^CheckedItemPresenter onSubject: self.
  )
(* required isMyKind and isKindOfX formulaic methods *)
isMyKind: other = (
    ^ other isKindOfCheckedItemSubject.
  )
isKindOfCheckedItemSubject = (
    ^ true.
  )
)
#+end_example



**** Class CheckedItemPresenter

Having defined a model class ~CheckedItemModel~ and a subject class ~CheckedItemSubject~, we will need the last piece of our UI, the concrete Presenter class.

Presenter is the class which does the work of creating the UI widgets. We have seen in chapter [[*The *Presenter* class: primary factory method, instance methods, how Presenter knows Subject][The *Presenter* class: primary factory method, instance methods, how Presenter knows Subject]] that Presenter is created in the primary factory method ~Presenter>>#onSubject: subject~, and it contains important wiring of the subject and presenter associations. Our concrete class primary factory method must do the same, so it needs to call this parent factory. This is done using /primary primary factory method/ ~CheckedItemPresenter onSubject: subject = Presenter onSubject: subject ()~  

For a concrete UI, method which creates the UI view is ~#definition~. It does that by creating and returning Fragmets or Presenter objects. The created objects can be a composition of both layout elements such as rows and columns, and widgets such as checkboxes and labels.

Also, we will need [[*The formulaic required repetitive methods of #isMyKind: and #isKindOfX][The formulaic required repetitive methods of #isMyKind: and #isKindOfX]].

As with the model and subject, we make the ~CheckedItemPresenter~ an inner class of ~CheckedItemUI~, by clicking the + beside Classes inside CheckedItemUI.


~class CheckedItemPresenter~
#+begin_example
public class CheckedItemPresenter onSubject: subject = Presenter onSubject: subject (
) (
public definition = (

    ^column: {
      (* Note: #label: and #checkbox:value:action: are methods on presenter *)
      label: 'Rudimentary TODO App'.
      checkbox: subject model itemTextWithStatus
      value: subject model isChecked
      action: [  :aaachecked | updateGUI:
                           [  (subject model isChecked)
                                  ifTrue: [
                                    subject model isChecked: false.
                                    subject model itemTextWithStatus: subject model itemText, ' : STILL TODO'.
                                    ]
                                  ifFalse: [
                                    subject model isChecked: true.
                                    subject model itemTextWithStatus: subject model itemText, ' : DONE'.
                                  ]
                            ]
                        ]
      .
    }. 
  )

  isMyKind: other = (
    ^other isKindOfCheckedItemPresenter.
  )

  isKindOfCheckedItemPresenter = (
    ^true.
  )

)
#+end_example


*** 4. Integrate the *CheckedItemUI* into the *CheckedItemApp*

So far we have prepared two separate classes:

1. ~CheckedItemApp~: We created this class as a (so far almost empty) top level class in [[* 1. Start coding the Application class *CheckedItemApp*][1. Start coding the Application class *CheckedItemApp*]]. We equipped the class with API methods that make the class instance an application.
2. ~CheckedItemUI~: We added this class in step [[*3. Write code for *CheckedItemUI*, the class showing the UI][3. Write code for *CheckedItemUI*, the class showing the UI]]. In that step, we also added the code that creates a row of widgets (fragments) in the ~CheckedItemUI>>#define~ method.


In the rest of this chapter, we finish integrating the ~CheckedItemUI~ into the ~CheckedItemApp~ by creating an instance of ~CheckedItemUI~ in the main method of the ~CheckedItemApp~.  This instance creation will perform the process of showing our UI, defined in the ~CheckedItemUI>>#define~ method.

**** Package the *CheckedItemUI* class into the *CheckedItemApp*

As we know, Newspeak must explicitly package all dependencies that may not exist on the target system where we deploy our ~CheckedItemApp~ app.

The packaging is done inside the IDE in "convention method" named ~CheckedItemApp>>#packageUsing: manifest~.

The code changes we need to make to achieve the dependency packaging is marked here:

~class CheckedItemApp~
#+begin_example
class CheckedItemApp packageUsing: manifest = (
  |
  (* Added 1-line to package the CheckedItemUI class on slot with same name *)
  CheckedItemUI = manifest CheckedItemUI.
  |
)
#+end_example

The ~CheckedItemUI~ class is pulled (from manifest) and stored on a slot named ~CheckedItemUI~ (this is customary, to name the slot same as the class name, but does not have to be). This is similar to importing the class ~CheckedItemUI~ into ~CheckedItemApp~ in other languages.

However, packaging in Newspeak performed by placing some object or class on slot does more.  Apart from declaring the dependency of ~CheckedItemApp~ on ~CheckedItemUI~, the actual CODE for the class ~CheckedItemUI~ will be serialized and shipped with the ~CheckedItemApp~, when it is serialized as ~CheckedItemApp.vfuel~.

**** When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*

When the ~CheckedItemApp~ starts (which we know is in the ~#main:args~ method), we need to create an instance of ~CheckedItemUI~. Once we have the instance, we need to create instances of the nested model, then subject, then presenter. 

In the summary conclusion in [[*Chapter conclusion about principles of writing rudimentary Hopscotch UI][Chapter conclusion about principles of writing rudimentary Hopscotch UI]] we have summarized how a rudimentary Hopscotch UI should be created. Let us repeat it here:

#+begin_example
|concreteModel concreteSubject concretePresenter|
concreteModel:: ConcreteModel new.
concreteSubject:: ConcreteSubject onModel: concreteModel.
hopscotchWindow openSubject: concreteSubject.
#+end_example

So let us expand this snippet to the full UI code that will run when the app starts.  Instead of the above snippet names starting with /Concrete/ start them with /CheckedItem/.

 ~class CheckedItemApp~
 #+begin_example
  public main: platform args: args = (
    |
    (* WHILE WE DEDUCED HOW THIS BEHAVES IN THE IDE, THE VFUEL BEHAVIOR IS ONLY DESCRIBED HERE.
       In IDE: When main is invoked by clicking [run] or [debug] in the IDE,
         we just pass it the platform. Note that calling 'platform hopscotch' returns hopscotchForHTML5.
         
       Electron and vfuel: platform behaves same as IDE platform.

       LEGACY vfuel note: When main was invoked in the vfuel app, the passed platform
                 did not contain hopscotch. That is why the legacy primary factory
                 App>#packageUsing: manifest had to package slot hopscotchForHTML5Runtime, then use it here.
                 This is no longer needed. 
    *)

    (* Added 1-line to instantiate CheckedItemUI from the platform - which has hopscotch available *)
    checkedItemUI = CheckedItemUI usingPlatform: platform.

    (* Added 3 temporary slots to verbosely process *)
    checkedItemModel
    checkedItemSubject
    |

    (* Added 3-lines to show steps very verbosely.
       The last line creates a window, instantiates a Presenter
       and it's definition fragments.
    *)
    checkedItemModel:: checkedItemUI CheckedItemModel new.
    checkedItemSubject:: checkedItemUI CheckedItemSubject onModel: checkedItemModel.
    platform hopscotch HopscotchWindow openSubject: checkedItemSubject.

    (* Note that the above code does NOT EXPLICITLY instantiate the Presenter here -
       that is already done implicitly by the super Subject,
       during ~checkedItemSubject:: checkedItemUI CheckedItemSubject onModel: checkedItemModel~
       by the super calling the ~Subject#createPresenter~
    *)
       
    (* also removed: 'Hello World from HelloWorldApp' out. *)
  )
 #+end_example

 See [[HopscotchWindow-openSubject-core-code]] for how  ~Subject#createPresenter~ is implicitly invoked.


Let's go over the added lines, and why they were added this way.


***** Why did we add, in CheckedItemApp, the line calling primary factory method of CheckedItemUI?

So, why did we add this line to the ~CheckedItemApp>>#main:args:~ method:

~checkedItemUI = CheckedItemUI usingPlatform: platform.~?

Explanation:

- The Application module ~CheckedItemApp~ is merely a (packagable) wrapper around the general module ~CheckedItemUI~. The ~CheckedItemUI~ needs a /primary factory method/ such as  ~CheckedItemUI>>#usingPlatform: platform.~  which is passed a platform object.  At runtime, during their instantiation, instances of top level classes "import" dependencies from the ~platform~.  All top level classes that are general modules need such /primary factory method/. It was discussed at length in the early sections, around and after section [[*Application and library modules in Newspeak][Application and library modules in Newspeak]] and summarized in [[* Newspeak modules API zoo][Newspeak modules API zoo]]. This is what the added line expresses: It creates an instance of CheckedItemUI and stores it on a local variable.

- Looking back to chapter [[*Class CheckedItemUI][Class CheckedItemUI]], we did not add any slots or constructors for the top level class ~CheckedItemUI~ so far.  Our ~CheckedItemUI~ will definitely need to "import" and "hold on" classes or instances of ~Subject~ and ~Presenter~ for use in it's nested classes ~CheckedItemSubject~ and ~CheckedItemPresenter~.

This explanation also leads to the need to beef up the module ~CheckedItemUI~ by adding both a /primary factory method/ and /slots/ for classes needed by nested children.

So as discussed in the explanation, let's add the /primary factory method/ and it's slots to ~CheckedItemUI~.

Replace the ~CheckedItemUI>>#new~ constructor with the following:

~class CheckedItemUI~
#+begin_example
class CheckedItemUI usingPlatform: platform = (
(* Added this primary factory method and slots for Subject and Presenter *)
|
Subject   = platform hopscotch Subject.
Presenter = platform hopscotch Presenter.
|
)
#+end_example

~platform hopscotch~ returns instance of HopscotchForHTML5 which has access to the ~HopscotchForHTML5>>#Subject~ and ~HopscotchForHTML5>>#Presenter~ nested classes (among others).  The added code above just stores them on slots of ~CheckedItemUI~ with same names.

To recap, the classes stored on slots ~Subject~ and ~Presenter~ are needed in the ~CheckedItemUI~ for use by its nested classes, the ~CheckedItemPresenter~ and  ~CheckedItemSubject~.  When the nested classes refer to ~Subject~ and ~Presenter~ in their code - for example in the constructor line ~CheckedItemSubject onModel: model = Subject onModel:~ - the ~Subject~ can only be found if it is on a slot of either the CheckedItemSubject or the owner CheckedItemUI. *As always in Newspeak, all dependencies must be found somewhere in the slot scope going up*.

A note: The need to put ~Subject~ on slot of ~CheckedItemUI~ rather than (for example) on the ~CheckedItemSubject~ is due to the fact that any element used in the constructor of ~CheckedItemSubject~ must be available in the scope of slots in nesting classes all the way up, when the contructor is called.

In summary, as the ~CheckedItemApp>>#main:args:~ is called, it should:
- instantiate the class on it's slot ~CheckedItemUI~ and store instance on local slot ~checkedItemUI~
- declare some local variables checkedItemModel/Subject/Presenter for their instances
- create model instance using   ~checkedItemModel:: checkedItemUI CheckedItemModel new~. Note how inner class ~CheckedItemModel~ is referred to from instance ~checkedItemUI~
- create subject instance using ~checkedItemSubject:: checkedItemUI CheckedItemSubject onModel: checkedItemModel~.
- open hopsotch window on the subject using ~platform hopscotch HopscotchWindow openSubject: checkedItemSubject~.
- See [[HopscotchWindow-openSubject-core-code]] on how Presented is instantiated and Subject -> Presenter associated


The local variable ~checkedItemUI~ will be used to create and show the UI in the code detailed in the next chapter.


***** What are the lines at the end of *CheckedItemApp#main:args*?

This is the last step we need to discuss!

The last three lines below create the rudimentary Hopscotch UI with a window, and an instance of ~CheckedItemPresenter~ placed in the window. For details, see [[*When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*][When the app runs in the *#main:args:* method, instantiate the *CheckedItemUI*]] and in detail in [[*Chapter conclusion about principles of writing rudimentary Hopscotch UI][Chapter conclusion about principles of writing rudimentary Hopscotch UI]].

 ~class CheckedItemApp~
#+begin_example
    (* Added 3-lines to show steps very verbosely.
       The last line creates a window, instantiates a Presenter
       and it's definition fragments.
    *)
    checkedItemModel:: checkedItemUI CheckedItemModel new.
    checkedItemSubject:: checkedItemUI CheckedItemSubject onModel: checkedItemModel.
    platform hopscotch HopscotchWindow openSubject: checkedItemSubject.
#+end_example

Notice this code is at the very end of the method ~CheckedItemApp>>#main:args:~ which we know as the "convention method" that executes the Application.  The line

~platform hopscotch HopscotchWindow openSubject: checkedItemSubject.~

is the last line of our application. *Executing this line, Hopscotch takes over, creates the UI and starts interaction with user's input devices*. 

In the last chapter, we merely summarize code for all classes we created for our App, the ~CheckedItemApp~.


*** 5. Complete code and UI of the *CheckedItemApp*

The complete code and UI of the ~CheckedItemApp~ can be found here:

https://github.com/mzimmerm/newspeak-doc/tree/main/newspeak---a-few-notes-code/checked-item-app

To skip the coding details above, we can [[compile-files]["Compile file(s)"]] to load full finished code from there and study it.  The classes will appear in the IDE.

[[file:img/newspeak---a-few-notes.org-checked-item-classes-in-ide.png]]

Clicking the [run] executes the app from the IDE, and presents its UI: 

[[file:img/newspeak---a-few-notes.org-checked-item-app-ui-running.png]]

and after checking the item we get

[[file:img/newspeak---a-few-notes.org-checked-item-app-ui-running-checked.png]]

You can also package it and run the Application as a standalone .vfuel file from the IDE, by clicking the *[deploy]* link beside the class name, then selecting "As VictoryFuel with Mirrors".

[[file:img/newspeak---a-few-notes.org-deploy-checked-item-app.png]]

More details on deployment for another sample Application is in the intro section around [[make-deployment-file][Make deployment file for CounterApp]]

Note: The code for the *CheckedItemApp* built here is as simple as it can be, to focus on understanding ~HopscotchForHTML5~. The Application should be improved in the future. The main weakness of the current version is that it exposes model publicly - model should be private wrapped in Subject.

This concludes the chapter that explores writing UIs in ~HopscotchForHTML5~.



* Analyzing classes HopscotchForHTML5, Browsing, etc

** HopscotchForHTML5: Analyzing senders of *Subject>>#presenter* and why *HopscotchWindow>>#openSubject: subject* should be invoked instead

Motivation: We know that ~Subject>>#presenter~ is a crucial method that creates a presenter for an existing subject, and establishes their association. We want to find the method or methods applications should invoke that eventually lead to calling ~Subject>>#presenter~.


We know ~Subject>>#presenter~ invokes ~Subject>>#createPresenter~. This seems a good indication that the Hopscotch framework creators wanted us to invoke ~Subject>>#presenter~ to get us from a Subject instance to a Presenter instance (the one created in ~Subject>>#createPresenter~); the Presenter instantiated there would then present the UI. (We already discussed that it is reasonable to assume that implementations of ~Subject>>#createPresenter~ should create and return a concrete Presenter.)

But do we know whether:

1. We are supposed to invoke ~Subject>>#presenter~ directly in our application?
   
2. Or is the intent of Hopscotch that our application should invoke some other method and through several steps inside the Hopscotsch framework eventually call ~Subject>>#presenter~?

Well that is a good detective story. Let us take a wild assumption that item 2 is the intended method.

There is a vague weak supporting reason for possibility 2. An Application will have to create something like a Window, a Frame, or some such object into which our app will be presented. So maybe, a good place to look for a method our application should invoke (instead of ~Subject>>#presenter~, is some kind of Window creation in HopscotchForHTML5 (where we would expect ~Subject#presenter~ to be invoked).

Let us investigate that direction.

A) First, let's look for senders of ~Subject>>#presenter~, all the way up.  There are only four senders of ~#presenter~ in Hopscotch classes:

1. ~#enterSubject:~ in Subject in HopscotchForHTML5
2. ~#enterSubject:~ in HopscotchShell in HopscotchForHTML5
3. ~#refresh~ in HopscotchShell in HopscotchForHTML5
4. ~#refreshmentPresenter~ in Presenter in HopscotchForHTML5

The first just calls the second

~class Subject~
#+begin_example
  enterSubject: s = (
	  (* TODO: use sendUp and open a new window if undelivered *)
	  ^shell enterSubject: s
  )
#+end_example
We can ignore the third and forth, as they have to do with refresh. That leaves us with the second, ~HopscotchShell>>enterSubject:~. If we find who sends this message, (maybe following up a few of its senders) we should arrive at the method our application should invoke (which then would end up calling #createSubject, the method we are intrested in calling. 

B) So next, let's look for senders of ~HopscotchShell>>#enterSubject: subject~ only in Hopscotch classes, we get

1. enterSubject: in ToolbarPresenter in HopscotchWindow in HopscotchForHTML5
2. enterSubject: in Presenter in HopscotchForHTML5
3. enterSubject:fromSnippet: in EmbeddedHopscotchWindow in HopscotchForHTML5
4. find: in ToolbarPresenter in IDEWindow in Browsing
5. goHome in HopscotchShell in HopscotchForHTML5
6. homeButton in Presenter in HopscotchForHTML5
7. ~into:openSubject: in HopscotchWindow in HopscotchForHTML5~
8. openSubject: in Window in HopscotchProxy in AppPlatform in Browsing

Now a detective story becomes more of a guessing game. But anything that is creating a Window or invoked from Window is a good guess, as any application would have to place it's Presenter into a Window or Frame or some such.

So let's look further at 7.

~HopscotchWindow>>#into: container openSubject: subject~

This seems to be doing something useful, it creates a toolbar, adds it to container, etc.

C) So let's look for senders of ~HopscotchWindow>>#into:openSubject:~ only in Hopscotch classes, we get


1. into:openSubject: in EmbeddedHopscotchWindow in HopscotchForHTML5
2. openSubject: in EmbeddedHopscotchWindow in HopscotchForHTML5
3. openSubject: in HopscotchWindow in HopscotchForHTML5


~HopscotchWindow>>#openSubject: subject~

public openSubject: s = (
	^into: body openSubject: s
)

is promising.

~HopscotchWindow>>#openSubject: subject~ looks like may be the method that we should invoke in our app to eventually create the Presenter.

The invocations sequence would be <<HopscotchWindow-openSubject-core-code>>

~HopscotchWindow>>#openSubject: subject~ invokes ->
~HopscotchWindow>>#into: container openSubject: subject~  invokes ->
~HopscotchShell>>#enterSubject: subject~   invokes ->
~Subject>>#presenter~ invokes ->
~Subject>>#createPresenter~

The last method creates and returns the presenter; which is then entered and placed to the page container (body).

*Conclusion: We found through some assumption, a bit of detective work through code that included guesses, that our application should not create ~Presenter~ directly or by calling ~Subject>>#presenter~ directly. Instead, our application should invoke*


~HopscotchWindow>>#openSubject: subject~

*this invocation will do the work of creating the Presenter for the Subject, and entering the presenter into the appropriate place in the container body.*

We will use this conclusion as a core conclusion when writing our sample Application.



** Browsing.ns: Analysing how a vfuel file is created by clicking the [deploy] link on an App.

TL;DR: This section browses code following code execution after we click [deploy] on an Application module in IDE.  Application is a top level class with factory ~#packageUsing: manifest~ and instance method ~#main: platform args: args~, as explained in [[* Newspeak modules API zoo][Newspeak modules API zoo]].  This section will show both methods are called, followed by serialization, and the serialized bytes stored as ~.vfuel~. The result is not clear. This is still a low priority todo.

Let's say the App name is ~MyApp~.

The code executed after we click [deploy] starts in instance of ~Browsing~. 

~Browsing.ns~
#+begin_src

class Browsing usingPlatform: p ide: webIde = (
  |
  ..
  ide = webIde. (* ide BECOMES hopscotchWebIDE *)
  ..
  |
)

(* Inner class ClassActionsPresenter is the presenter of the line where
   the [deploy] action is.
   Somehow this presenter subject name = MyApp ????????
*)
public deployAction = (
        subject isApplicationConfiguration ifFalse: [^nothing].
        ^(link: '[deploy]' action: [
                        openMenu:: menuWithLabelsAndActions: {
                                {'as VictoryFuel'. [deployAsVictoryFuel]}.
                                {'as VictoryFuel with Mirrors'. [deployAsVictoryFuelWithMirrors]}.    (* 1 *)
                                {'as Web Page'. [deployAsWebPage]}.
                                {'as Web Page with Mirror Builders'. [deployAsWebPageWithMirrorBuilders]}.   
                        }
                ]).             
)
)

(* 2 *)
deployAsVictoryFuelWithMirrors = (
      (* subject name is MyApp by the speculation above *)
      | bytes = subject bytesForVictoryFuelWithMirrors. |
        ide webFiles downloadFileName: subject name, '.vfuel' fromBytes: bytes.
)                               

(* 3 *)
public bytesForVictoryFuelWithMirrors ^ <ByteArray> = (
  (* this becomes:
     bytesForVictoryFuelWithRuntime: hopscotchWebIDE RuntimeWithMirrorsForPrimordialSoup.
  *)
  ^bytesForVictoryFuelWithRuntime: ide psoupWithMirrorsDeploymentRuntime
)       

(* 4 *)
public bytesForVictoryFuelWithRuntime: runtimeClass ^ <ByteArray> = (
        (* name is the name of appDef becomes MyApp *)
        | appDef <Class> =  ide namespacing Root at: name. |
        (* call 5 *)
        ^ide deployment PSoupPackager packageApplicationConfiguration: appDef withRuntimeConfiguration: runtimeClass  usingNamespace: ide namespacing Root
)   

also see 

public runApp = (
        | appDef <Class> app <Object> |
        appDef:: ide namespacing Root at: name.
        app:: appDef packageUsing: ide namespacing manifest.
        app main: cachedPlatform args: {}
)

#+end_src

~DeploymentManager.ns~

#+begin_src 
public class PSoupPackager = (
) (
(* 5 *)
public packageApplicationConfiguration: appDef <Class> withRuntimeConfiguration: runtimeClass <Class> usingNamespace: ns  ^ <ByteArray> = (
        | 
    app <Object> 
    runtime <Object>
    accessedResources <List> = List new. 
    |  
    
    runtime:: runtimeClass packageRuntimeUsing:
                (RecordingManifest namespace: ns accessedResources: List new).

        (* this instance seems just lost  *)        
        appDef packageUsing:
                (RecordingManifest namespace: ns accessedResources: accessedResources).

        (* ****** THE PACKAGING OF appDef == MyApp is done here - MAYBE - UNCLEAR :
           this is in out/WebCompiler.ns>>Preloader: 

               ~^(applicationConfiguration packageUsing: manifest) main: platform args: args~

          the result (the package instance initialized) is set on app:
        *)
        (* calling 6 with appDef == MyApp *)
        app:: Preloader
                resources: (Array withAll: accessedResources)
                applicationConfiguration: appDef.

        (* The app == initialized package instance IS SNAPSHOTTED TO BYTES, AND THE BYTES RETURNED.
           BYTES GO BACK TO bytesForVictoryFuelWithRuntime
         *)

        ^Snapshotter new snapshotApp: app withRuntime: runtime keepSource: runtimeClass keepsSources.
)

#+end_src

~out/WebCompiler.ns>>Preloader~
#+begin_src
(* 6. a == MyApp *)
class Preloader resources: r <Array[{String. String. String | Class}]> applicationConfiguration: a <Class> = ( 
        |
        protected resources <Array[{String. String. String | Class}]> = r.
        protected applicationConfiguration <Class> = a.
        (* **** I think we need to instantiate: applicationConfiguration packageUsing: manifest here.
                without it, I do not understand where the MyApp is instantiated before serialization.
                Unless Preloader>>#main:args: is called, but where?
        *)
        |
) (
public main: platform args: args ^ <Object> = (
        | namespace <Map[String, Class | String | Alien]> manifest <Manifest> |
        namespace:: platform collections Map new.
        resources do:
                [:resource <{String. String. String | Class}> |
                | name <String> type <String> payload <String | Class> |
                 name:: resource at: 1.
                 type:: resource at: 2.
                 payload:: resource at: 3.
                 namespace
                        at: name
                        put: (unpackResourceType: type payload: payload platform: platform)].
        manifest:: Manifest forNamespace: namespace.

        (* *** If this is called, it would do the work:
               instantiate, run, return MyApp instance for serialization
               but I cannot find where it is called *)
        ^(applicationConfiguration packageUsing: manifest) main: platform args: args
)

#+end_src

~HopscotchWebIDE.ns~
#+begin_src 
class HopscotchWebIDE usingPlatform: p = (
  |
  ..
  public browsing = Browsing usingPlatform: p ide: self.
  .. 
  public psoupWithMirrorsDeploymentRuntime = RuntimeWithMirrorsForPrimordialSoup.
  ..
  |
#+end_src


* Todos todo-00

- read https://newspeaklanguage.org/ns101/ns101.html 

- Reactivity: Hudak's book The Haskell School of Expression

- What is "Hopscotch's component model* Gilad mentions as reactivity he added?
  
- change begin_example to begin_src??  - when the block is named such as ~MyClass~, add ".ns" to class, ~MyClass.ns~
   
- clarify - throughout the document, we should clarify that 'deploy' means 'create deployable artifact' - a file that can be deployed!! Also go over all text talking about 'deploy'

- Look for "Module type", and come up with a /term for it/ - maybe just /module type/.
   
- generally replace 'are called' 'abc is called' with 'are termed', 'abc is termed'

- Add to blog: 
     - around descriptrion of  sections:
       class MyClass primaryFactorySignature = 
       (|instanceSlots| 
        primaryFactoryCode
       ) 
       (innerClassesCode
        instanceMethodsCode
       ) :  
       (classMethodCode
       )
      clarify that the first section is definition of primary factory! Technically, the class line in IDE is Primary factory, NOT class
-  Check where in code the class names  ampleforthDocumentBody, and ampleforthDocumentClass and self_ampleforth are used.
-  Figure out how servable.zip is built. 
    
