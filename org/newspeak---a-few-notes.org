#+STARTUP: showall
#+STARTUP: hidestars
#+OPTIONS: H:5 num:t tags:t toc:t timestamps:t
#+LAYOUT: post
#+AUTHOR: mzimmerm
#+DATE: 2021-05-02 Sun 12:51
#+TITLE: Newspeak - a few notes
#+DESCRIPTION: Running, not yet published notes on Newspeak
#+TAGS: newspeak programming
#+CATEGORIES: category-newspeak category-blog category-programming
#+TODO: TODO IN-PROGRESS-NOW IN-PROGRESS-NOW-DONE IN-PROGRESS WAITING NOTE DONE

* This document: Introduction to Newspeak on Webassembly (Wasm)

TL;DR: The purpose of this document is to help starting with Newspeak version 3 (year 2021, runs on Webassembly). Hopefully reduce reader's start time a bit. It is intended that a reader follows this document sequentially, but of course jumping around is good too.

Much of this document is collected from the existing Newspeak sources:

- The Newspeak google groups posts at https://groups.google.com/g/newspeaklanguage
- The Newspeak core site at https://newspeaklanguage.org/


* Changelog

|       Date |   | Author           |   | Change                                                                                                                                               |
|------------+---+------------------+---+------------------------------------------------------------------------------------------------------------------------------------------------------|
| 2021-05-02 |   | Gilad Bracha     |   | Important clarifications throughout the document                                                                                                     |
| 2021-05-04 |   | Milan Zimmermann |   | Expanded on using the Newspeak IDE, mostly in the section [[Run the online version of the Newspeak IDE. Read docs, watch videos]] |
| 2021-06-07 |   | Milan Zimmermann |   | Wording changes and clarifications in several sections                                                                                               |
| 2021-07-05 |   | Milan Zimmermann |   | Clarifications on saving:  "lastSaved" vs "backup" in [[Saving changes in Newspeak]]                                                                               |
| 2021-07-05 |   | Milan Zimmermann |   |                                                                                                                                                      |

  
* Newspeak quickstart: Explore the IDE. Then develop ~CounterApp~, package it and deploy it

TL;DR: This quickstart section attempts to provide an incremental introduction to Newspeak. First, we introduce the Newspeak online IDE, then we build and deploy a sample Newspeak app called ~CounterApp~. A spoiler: we can look ahead and run the app we will be building - the ~CounterApp~ - online at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel. 

** Run the online version of the Newspeak IDE. Read docs, watch videos

TL;DR: This section introduces the online version of Newspeak IDE, and how to use it.

This is a brief section. Starting with Newspeak is easy. We just point the browser to https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel.

In more detail, let us try the following:

- Action: In a new browser tab, open the Newspeak online IDE at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- Result: The Newspeak IDE opens, similar to
  [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
- Action: To edit source code: Click the "Newspeak Source" link
  [[file:img/newspeak---a-few-notes.org-go-to-newspeak-source.png]]
- Result: A new page opens, showing Newspeak classes, similar to
  [[file:img/newspeak---a-few-notes.org-newspeak-source.png]]
- Note: The blue links are classes. To view, or change them, click the class link 
- Action: Click the "+" beside the "Root" to add a class.
- Result: A class editor opens, with a template of a new class definition. At first, let's just create a dummy class by editing the template
  [[file:img/newspeak---a-few-notes.org-newspeak-source-defining-a-new-class.png]]
- Action: Click the checkbox on the top right [[file:img/newspeak---a-few-notes.org-accept-image.png]] to "Accept" the new class definition. Note: Clicking the "Accept" button is important. If you make any code changes, or workspace code changes, do not forget to click "Accept", otherwise your changes will be lost immediately after moving away from the source editing page. See the discussions in [[*Saving changes in Newspeak]].

- Result: The class now appears in the list of classes (may need to scroll down, classes are sorted alphabetically)
  [[file:img/newspeak---a-few-notes.org-my-new-class-now-added.png]]
- Action: Return back to the main page by pressing the browser "Back" button, to get back to
  [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
- To run some Newspeak expressions: Click the "Workspaces" link
  [[file:img/newspeak---a-few-notes.org-go-to-workspaces.png]]
  - Result: A new page opens, similar to
    [[file:img/newspeak---a-few-notes.org-workspaces.png]]
- To run some simple one-liner code, type for example "1+2" into the text field, and press keyboard *Shift + ENTER*. This will evaluate the expression and print a result "3"
  - Result: expression "1+2" was evaluated to "3"
    [[file:img/newspeak---a-few-notes.org-workspaces-expression.png]]
- To run multi-line Newspeak code, type the code line by line. Press keyboard *ENTER* to open new lines. When ready tu run the code, *highlight all lines, then press keyboard Shift + ENTER* to run the code. Another term for running code like this, is "evaluating all highlighted lines"). The image below shows the Workspace after the *Shift + ENTER* was pressed, showing the evaluated code, and the result of the evaluated code: ~2~.
      [[file:img/newspeak---a-few-notes.org-workspaces-multiline-expression.png]]
  - The image above uses a white-mode image, as the dark-mode pages do not show highlight too well.
  - When running multi-line code, we can paste it from outside, instead of typing it.
- To save our changes "now", click on the diskette "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]]. The changes are saved in the browser local storage. See Notes below for discussion on the details.
  
Notes:

- We are now using Newspeak, in its full power.
- The browser tab opened on https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel IS the Newspeak live IDE.
- Everything we do in the IDE is alive, changes and actions have immediate responses in the running system.


Saving your changes:

*Any changes we make (for example: we add a class, we change a class, evaluate something in the workspace) are stored in the browser local storage in two entries: "lastSaved" and "backup".* The "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]] saves the changes in local storage under the key "backup", while the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], saves the changes under the key "lastSaved".  See [[*Saving changes in Newspeak]] for details.
  
Documentation:

- Some selected documentation sites and videos:
  - The core site for all Newspeak is https://newspeaklanguage.org/. It has *papers, talks, demos, and repo links.*
  - A great start would be the last 2 videos on the "talks" tab https://newspeaklanguage.org/talks.html
    - Live IDEs in the Web Browser: What's Holding Us Back - https://youtu.be/CJX_6B24Hho
    - What is a Live Programming System? - https://youtu.be/VUfZ1sL4aps

Summary:

- This section showed the simpliest way of starting with Newspeak - we just point the browser to https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and start using it.
  - In "Workspaces", we can experiment with Newspeak expressions, or snippets of code.
  - In "Newspeak Source", we can experiment with adding Newspeak classes, or creating a Newspeak app, such as the app created in the next section.

Potential "gotchas":

- If you make code changes, do not forget to click the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]]. Otherwise your changes will be lost immediately after moving away from the source editing page.
- What is the difference between The "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], and the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]]? 
  - The "Accept" button is needed to save your changes beyond moving away from the editor. For example, if you make a change to a class method, and do not click "Accept", your changes will be lost after pressing the browser "Back" button, browser "Reload" - generally any state changes.
    
Next:

In the next section [[Build, run, and debug the ~CounterApp~ in Newspeak (in the online version)]], we show how to create a simple ~CounterApp~ in Newspeak.


** Build, run, and debug the ~CounterApp~ in Newspeak (in the online version)

TL;DR: This section describes 

- How to create, run and debug a Newspeak app (~CounterApp~) in development mode, in the *online* Newspeak IDE. To concentrate on the IDE handling applications, we use pre-existing code for the ~CounterApp~.

Prerequisits:

- We should write code of the ~CounterApp~. However, for us to skip any implementation details and concentrate on the IDE, in this section, we will simply borrow the code. The code of the ~CounterApp~ already exists - in the Newspeak github repo at https://github.com/newspeaklanguage/newspeak. We borrow it without talking about Newspeak code until later. To fullfill the prerequisite, do one of the following:
  - Clone the newspeak repo locally and find two files, ~CounterApp.ns~ and ~CounterUI.ns~ from there. 
  - Alternatively, download the files ~CounterApp.ns~ and ~CounterUI.ns~ from Github to the local filesystem. To do that, just click https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterUI.ns, then https://raw.githubusercontent.com/newspeaklanguage/newspeak/master/CounterApp.ns, then right-click and select "Save as..." to save each file.
  - Either way, note the location of the two files.

 
Notes: 

- To deploy the ~CounterApp~, this section uses the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- However, a local Newspeak server could be used instead.
  - If we wanted to deploy the ~CounterApp~ in "production", we would need a local Newspeak - because there is no way to deploy the app to the online Newspeak site.
  - Deployment of the  ~CounterApp~ to "production" requires our "own" Newspeak, such as the local Newspeak server. See [[Download, install, and start a local Newspeak server]] for how to install Newspeak locally.
- We may ask, "what is an app in Newspeak"? In a nutshell, an "app" is an instance of a class - obviously. But which class, and what does the class need, to be able to "live" or "run" inside a Newspeak IDE or Newspeak runtime? Read on for details (actually, the coding details are todo).

*Steps: To create and run the ~CounterApp~ (from existing code that we borrow from Newspeak Github), follow the Action/Result steps below:*

- Action: In a new browser tab, open the online Newspeak IDE at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- Result: The Newspeak IDE opens, similar to [[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]
  - Note: The "Did you know" section is a ever-changing hint system
- Action: Click "Newspeak Source" in [[file:img/newspeak---a-few-notes.org-go-to-newspeak-source.png]] 
- Result: A new page opens, showing Newspeak classes, similar to [[file:img/newspeak---a-few-notes.org-newspeak-source.png]]
  - Note on the result: In the result, you should NOT see classes named ~CounterApp~ or ~CounterUI~. If you do, you have most likely run through this tutorial before, and the classes are already in your browser local storage. To clean any local changes saved locally for the online Newspeak, you can clean them in the browser local storage. See 
- *Motivation for the next action: We want to build the sample app ~CounterApp~. We choose to build it simply by downloading and compiling two files from the existing source from the Newspeak github repo.*
- Action: In the top right of the page (in the same line where we see "Root +") [[file:img/newspeak---a-few-notes.org-3-vertical-dots.png]], click the *vertical 3-dot* button on the far right.
- Result: A popup  [[file:img/newspeak---a-few-notes.org-compile-files.png]] shows

- Action: Click "Compile Files". This will ask us to select files stored on disk, and compile them.
- Result: OS file browser opens, and ask us to select files in the operating system filebrowser. 
- Action: Navigate to the directory where we checked out the Newspeak github repo, OR where we saved the source for the ~.ns~ files (see Prerequisits of this section). Select ~CounterApp.ns~ and ~CounterUI.ns~
- Result: *The classes from the selected ~.ns~ files compile, and show in your IDE.* In your class list (the list under Root +), you should now see a section similar to this [[file:img/newspeak---a-few-notes.org-counter-classes.png]]
  - Note 1: We have loaded the code of the  ~CounterApp.ns~ and
    ~CounterUI.ns~ classes into Newspeak by running "Compile
    file". Alternatively, we could have added the classes through the IDE by
    clicking the "+" button
    [[file:img/newspeak---a-few-notes.org-root-plus-button.png]] and typing or pasting the code in.
    Instead, we choose to load pre-existing files at the moment to concentrate on the process, not the code.   
  - Note 2: Click on the ~CounterApp~ or ~CounterUI~ link. This shows the corresponding class. 
  - Note 3: The ~CounterApp~ shows links to ~[deploy] [configuration] [run] [debug]~. Why do only the "app" classes such as ~CounterApp~ (and no other classes) show the ~[deploy] [configuration] [run] [debug]~ links in the Newspeak IDE? That is because the "app" classes represent a runnable Newspeak application.
  - *Question: What makes a Newspeak class a "runnable Newspeak application"?. todo*
- Action: To save the classes we added, (~CounterApp~ or ~CounterUI~) in the browser local storage explicitly "now", click on the diskette "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]]
- Result: The two classes are stored in the browser local storage. To read more about details of the browser local storage, see [[*Saving changes in Newspeak]].
- Action: Click on the *[run]* link beside the  ~CounterApp~. This runs the code in the app (specifically, the ~CounterUI~ code). 
- Result: The counter app opens and runs in the same browser tab; it should look like this:  [[file:img/newspeak---a-few-notes.org-counter-app-running.png]] The code presents a counter (integer), and 3 buttons, which actions are to "increment", "decrement" and "reset" the counter. 
- Action: click on "increment"
- Result: counter increments by one.
- Note: We can click [debug] instead of [run] and a debugger will open.

Summary: 

- We have shown how to build, run, and debug, a Newspeak app ~CounterApp~ in "development mode", inside the online Newspeak IDE. 
- Newspeak online is similar to (but we dare say superior to) running, in "development mode", a Java, Android or Flutter application in IntelliJ, Eclipse, Visual Studio, Atom, Emacs, vi, or any IDE.
- Your changes are always stored, as long as you "Accept". See [[*Saving changes in Newspeak]] for saving changes details.

Next: 

- Let's pretend the CounterApp is useful, useable, and production ready.
- How do we deploy it for us to use it as a browser app "in production mode"? Read the [[Deploy ~CounterApp~ as standalone app into local Newspeak server]] section.


** Download, install, and start a local Newspeak server

TL;DR: This section describes:

- How to download, install, and start a *local Newspeak server*.
- How opening a browser tab at http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel runs the local version of the Newspeak IDE (reaching the just installed local Newspeak server).

Prerequisits: 

- Python is installed on your system. This is needed for the ~serve.sh~ script to run an http server. 

Notes: 

- You can use a server of your choice instead of the Python server needed by ~serve.sh~. Just place all the files downloaded in the sections below to your server's serving directory.
- You can potentially skip this section. However, if you want to deploy a Newspeak app such as the ~CounterApp~, this section is needed.  

*Action steps to download, install, and start using a local Newspeak server*

- First, you may want to review the Newspeak downloads page at https://newspeaklanguage.org/downloads.html, in particular the *For all platforms* link.  
- Next, to install and start a local Newspeak server, you can 
  - Either download and unzip the file *servable.zip* from the link above (https://github.com/newspeaklanguage/newspeaklanguage.github.io/raw/master/servable.zip) to any directory, then start the Newspeak server by running ~serve.sh~ from the extracted file.
  - Or run the following commands from the command line 
    #+begin_src shell :noeval
      MY_SERVE_NEWSPEAK=$HOME/software/newspeak/my-serve-http
      mkdir --parent $MY_SERVE_NEWSPEAK || echo Unable to create directory $MY_SERVE_NEWSPEAK 
      cd $MY_SERVE_NEWSPEAK
      curl --location https://github.com/newspeaklanguage/newspeaklanguage.github.io/raw/master/servable.zip --output $MY_SERVE_NEWSPEAK/servable.zip
      unzip -o servable.zip
      
      # The directory just above "servable" must be the directory
      # where we saved the zip file, see above.
  
      cd servable
      # Make serve.sh executable, and start the Newspeak local server.
      chmod u+x serve.sh
      ./serve.sh
    #+end_src
- Expected Result: "serving at port 8080". Note: In *servable.zip* there is a file ~server.py~, which defines the Newspeak server port. The port is set to 8080. Edit the file and change port if needed.


To use the local Newspeak server, navigate browser to http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel. This should open the locally hosted Newspeak IDE, started using the ~./serve.sh~ command. 

Your browser should show a page similar to 
  [[file:img/newspeak---a-few-notes.org-local-ide.png]]

Note: The use of the local version is the same as the use of the online version. We can now start editing Newspeak code by clicking on the "Newspeak Source" link.

Summary: 

- In this section we installed the local Newspeak server, and started using the served Newspeak IDE.
- The installation method described here is the [[install-method-2][Installation method 2 (local Newspeak server)]]   

Next: [[*Deploy ~CounterApp~ as standalone app into local Newspeak server]]


** Deploy ~CounterApp~ as standalone app into local Newspeak server

TL;DR: This section describes 

- How to create and deploy the ~CounterApp~ into the local version of Newspeak.
- That the deployment is achieved by creating a deployable file, ~CounterApp.vfuel~, in the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and placing it in the running local Newspeak server.
- How to run the ~CounterApp~ from the local Newspeak server, by accessing the  ~CounterApp.vfuel~ from the local HTTP server.

Prerequisits: 

1. We have followed the online section [[*Build, run, and debug the ~CounterApp~ in Newspeak (in the online version)]]. In that section, we have downloaded (from Newspeak Github) and compiled two classes ~CounterApp~ and ~CounterUI~ *while attached to the online Newspeak*.
   - This statement requires a "fine point" explanation. 
     - In the earlier section  [[*Build, run, and debug the ~CounterApp~ in Newspeak (in the online version)]], the two classes, ~CounterApp~ and ~CounterUI~, were saved to the browser local storage. 
     - In this current section, we re-attach to online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel. 
     - As explained in [[*Saving changes in Newspeak]], the changes we made in the online version are still stored locally in the browser local storage. 
     - So, when we re-attach to online Newspeak in this section, the classes ~CounterApp~ and ~CounterUI~ are still available. We use them to "create the CounterApp" (by saving it "as victory fuels" - that is, as file ~CounterApp.vfuel~) which is the app. 
     - This app - the  file ~CounterApp.vfuel~ - can then be copied to the serving directory of local Newspeak, and can be opened from there.
2. We have installed the local version of Newspeak by following the section [[*Download, install, and start a local Newspeak server]].*


Notes: 

- We will create the deployable file, ~CounterApp.vfuel~ using the online Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel 
- *However, apps can NOT be deployed to the online version, since that would require write access to the newspeak web site. We can do the coding online (as described above), but the actual deployment has to be done into a Newspeak system we control.*
- The deployable file, ~CounterApp.vfuel~, will be deployed into the local Newspeak server as  http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel. (this link will only work when we finish all steps in this section)

One more "fine point" note:

- This flipping between the online Newspeak and local Newspeak could be confusing. We could have started by downloading Newspeak locally, and follow the whole turorial in local Newspeak. However, we thought that may discourage some people who want to "take the shortest path", start online, and expand from there.


*Steps: Now we have introduced the context, we start the core of this section: We create the deployable file, ~CounterApp.vfuel~ and deploy it to the local Newspeak, by following the Action/Result steps below:*

- Action: Navigate to the online version of Newspeak at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel and click the "Newspeak Source"
- Result: Under "Root" you should see an alphabetically organized list of classes, similar to [[file:img/newspeak---a-few-notes.org-newspeak-source.png]], 
  - Note: If you followed the online section [[*Build, run, and debug the ~CounterApp~ in Newspeak (in the online version)]], there should be ~CounterApp~ and ~CounterUI~ classes in the alphabetic list.
- Action: In the class list, find the ~CounterApp~, and click on the [deploy] to the right of the "CounterApp"
- Result: a popup showing deployment options (starting with ~asVictoryFuel~: [[file:img/newspeak---a-few-notes.org-click-deploy-on-counter-app.png]]
- Action: Select ~asVictoryFuelWithMirrors~. We choose the option 'asVictoryFuelWithMirrors' if our app uses the GUI (there's some mirror dependency in the UI) and 'asVictoryFuel' otherwise.
- Result: After a long wait, a file named ~CounterApp.vfuel~ is created, and asked to be saved.
- Action: Save the file ~CounterApp.vfuel~ on our disk to the directory where local Newspeak was deployed - for example ~$HOME/software/newspeak/my-serve-http/servable~
- Result: *The counter app is now deployed to the local Newspeak server!*


To prove the counter app is now deployed to the local Newspeak server, do the following:

- Action: Open a new browser tab, and navigate to the just saved application  ~CounterApp.vfuel~ in the local Newspeak server as http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel
- Result: In the new tab, you should see the "locally deployed" ~CounterApp~ is now running
  [[file:img/newspeak---a-few-notes.org-counter-app-local-run.png]]

Summary: 

- In this section, using the online Newspeak, we built our "Newspeak production deployable" file ~CounterApp.vfuel~, and deployed it to the local Newspeak version at http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel.

Next: This is the end of coding, building and running the ~CounterApp~


* Newspeak on Webassembly (Wasm) - using Newspeak online, and various local installation methods

TL;DR There are several ways of using Newspeak: Using the online web version (no installation required, see [[install-method-1][Installation method 1]]), installing and using your system-local web version ([[install-method-2][Installation method 2]]), or more "advanced" methods described in [[*Advanced methods to install and run Newspeak]] (this includes installing and using an Electron-based version in [[install-method-4][ Installation method 4]]. This section is describing all methods. Initially, users should consider [[install-method-1][Installation method 1]] or [[install-method-2][Installation method 2]].

** Simple methods to install and run Newspeak

*** <<install-method-1>> Installation method 1: No installation or setup, run Newspeak online

TL;DR: This section describes the simplest setup - in fact, this is a "no setup, no installation" method. We only need a browser and internet access. This is the recommended method to start with Newspeak.

- Action: Navigate your browser to Newspeak online at https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel, 
- Result: You should see a page similar to this

[[file:img/newspeak---a-few-notes.org-newspeak-ide-start.png]]


Notes:

- By using this page, you are now using the Newspeak IDE
- Click on "Newspeak Source" to see and edit code.
- Your changes will be stored in browser local storage.
- A more detailed description of what we can do with Newspeak is in the introduction section [[Run the online version of the Newspeak IDE. Read docs, watch videos]]  


*** <<install-method-2>> Installation method 2: Download and start a local version of Newspeak webserver

This method downloads a pre-packaged Newspeak, and allows you to start your local webserver, which starts the pre-packaged Newspeak. This method is described in detail in the "hands on" section [[Download, install, and start a local Newspeak server]]. Follow the steps there.

Differences of this installation from [[install-method-1][Installation method 1]] (no install - using Newspeak online)
- If we install using this method 2:
- Pros:
  - No need for internet access
  - Your version does not change if you need stability (this may be a cons too)
- Cons:
  - We have to run our own Newspeak server, and reinstall to care of any updates or bugs fixed.


** Advanced methods to install and run Newspeak 

*** <<install-method-3>> Installation method 3: Setup a local Newspeak webserver from code on Github.

This method is described in the "Just in Case" section in https://github.com/newspeaklanguage/newspeak.


*** <<install-method-4>> Installation method 4: Download or setup a local Electron version of Newspeak on MacOS or Windows

To install using this method, dowload the available versions for Windows and Mac, see https://newspeaklanguage.org/downloads.html, section "Dowloadable IDE App". 

Electron is basically Chromium underneath. It's just set up to read from a page that's built in to the app. So no server needs to be started. It starts with starting the app.

An advantage of Electron that I have seen is a better integration with OS File access dialogs.  It doesn't insist on using a downloads directory for everything (and while browsers let you set the directory, they don't let you change it on the fly, on a file-by-file basis).


*** <<install-method-5>> Installation method 5: Manual setup which will produce an equivalent of [[install-method-2][Installation method 2]] (local Newspeak server)

As this method produces an equivalent that is already downloadable, this is only if we want to dig in more details, but not going all the way to doing all the steps in [[install-method-3][Installation method 3]].

If the build isn't working for you there is one option that hasn't been discussed, which is relevant to Linux folk who don't have an Electron app. You can get the web IDE vfuel file at:

https://newspeaklanguage.org/samples/HopscotchWebIDE.vfuel 

BUT ... this isn't enough because you need a bunch more stuff, such as primordialsoup.html, primordialsoup.js, primordialsoup.wasm.
If you run that, you'll find that you also need a longish list of .png files for the various images used by the IDE. Here they are (proably a few that are no longer used too).

accept16px.png				hsHistoryDownImage.png
accept16pxDown.png			hsHistoryImage.png
accept16pxOver.png			hsHistoryOutImage.png
arrowGreenLeft.png			hsHistoryOverImage.png
arrowGreenRight.png			hsHomeDownImage.png
arrowOrangeLeft.png			hsHomeImage.png
cancel16px.png				hsHomeOutImage.png
cancel16pxDown.png			hsHomeOverImage.png
cancel16pxOver.png			hsNewDownImage.png
classPresenterImage.png			hsNewImage.png
classUnknownImage.png			hsNewOutImage.png
clearImage.png				hsNewOverImage.png
conflictRed.png				hsRefreshDownImage.png
disclosureClosedImage.png		hsRefreshImage.png
disclosureMinusImage.png		hsRefreshOutImage.png
disclosureOpenImage.png			hsRefreshOverImage.png
disclosurePlusImage.png			hsReorderDownImage.png
disclosureTransitionImage.png		hsReorderImage.png
downloadImage.png			hsReorderOutImage.png
editImage.png				hsReorderOverImage.png
findImage.png				hsToolsDownImage.png
findSquareLeftDownImage.png		hsToolsImage.png
findSquareLeftImage.png			hsToolsOutImage.png
findSquareLeftOutImage.png		hsToolsOverImage.png
findSquareLeftOverImage.png		itemBothOverride.png
helpImage.png				itemDeleteImage.png
hsAddDownImage.png			itemMenuImage.png
hsAddImage.png				itemReferencesImage.png
hsAddOutImage.png			itemSubOverride.png
hsAddOverImage.png			itemSuperOverride.png
hsBackDownImage.png			languageJS.png
hsBackImage.png				languageM.png
hsBackOutImage.png			languageNewspeak3.png
hsBackOverImage.png			languageSmalltalk.png
hsCollapseDownImage.png			menu16px.png
hsCollapseImage.png			menu16pxDown.png
hsCollapseOutImage.png			menu16pxOver.png
hsCollapseOverImage.png			menuButtonImage.png
hsDropdownDownImage.png			metaMenuDownImage.png
hsDropdownImage.png			metaMenuImage.png
hsDropdownOutImage.png			metaMenuOutImage.png
hsDropdownOverImage.png			metaMenuOverImage.png
hsExpandDownImage.png			operateMenuDownImage.png
hsExpandImage.png			operateMenuImage.png
hsExpandOutImage.png			operateMenuOutImage.png
hsExpandOverImage.png			operateMenuOverImage.png
hsFindDownImage.png			peekingeye1610.png
hsFindImage.png				privateImage.png
hsFindOutImage.png			protectedImage.png
hsFindOverImage.png			publicImage.png
hsForwardDownImage.png			repositoryGit.png
hsForwardImage.png			repositoryMercurial.png
hsForwardOutImage.png			saveImage.png
hsForwardOverImage.png			tinySubclassResponsibilityImage.png

You can place it all in the directory of your choice and serve from there (the serve.sh script wants it in the repo, in the out directory).
It seems easier to build, but I'm putting it out there.



* IN-PROGRESS Programming in Newspeak

** The Newspeak IDE

*** Updading one IDE related class that was fixed on Github source into local Newspeak IDE

Let's say that I am using local Newspeak.

The regular way of updating it to the latest (thus getting fixes done since the last deployment), would be to simply re-download as described in [[install-method-1]].

Could there be situations we do not want to simply reinstall the local Newspeak server? Perhaps one example of such situation is that we run our local Newspeak server with changed files, and we want to patch a class that has a known fix, without reinstalling the local Newspeak and losing changes.

To describe a concrete (somewhat artificial) situation: Let's say that on Github, there is a bug fix or change in a 'system' class, ~Browsing.ns~, and we want to update this single class locally. We can identify changed files or files with fixes, and compile them in (that is, start using them in) the local version, using the following process:
  
- Look for files committed on Github. 
- Find files changed since your last local install - let's say file ~Browsing.ns~ changed today to fix a bug. As your local server uses the servable.zip file, ~Browser.ns~ is already compiled in your local vfuel.
- So from the browser IDE, http://localhost:8080/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel from the 3-dot I "compile" the new version of Browsing.ns 
- Save the changes from IDE (clicking the save diskette image)
- You can confirm that your changes were "Compile"d, by exporting of Browsing.ns (click the "Save to file" button to export the code).
- The result of the above process is your local server are now using the github-fixed ~Browsing.ns~.
  

** Saving changes in Newspeak

TL;DR: Changes can be saved either /inside the browser/ in the browser's local storage, or, /outside the browser/ on the filesystem.  Any changes you make (for example: you add a class, change a class, evaluate something in the workspace) are stored in the browser local storage in two entries: *lastSaved* and *backup*. Clicking the "Accept" button  [[file:img/newspeak---a-few-notes.org-accept-image.png]] saves the changes in local storage under the key /backup/, while clicking the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], at any time after "Accept", saves the changes under the key /lastSaved/. Alternatively, you can `export` code by clicking the "three dot menu" button to the right of the class, then clicking the "Save to file" item in the popup menu. You can `import` code by clicking the "three dot menu" on the top, to the right of "Root +", then selecting the "Compile File(s)" in the popup menu.

*** Saving changes inside the browser

How is the browser local storage handled, and how is /lastSaved/ different from /backup/? Here is a detail description of how changes are saved and restored:

- After making any code change or addition, to keep your changes, you have to click the "Accept" button [[file:img/newspeak---a-few-notes.org-accept-image.png]]. Clicking "Accept" saves the changes in local storage under the key /backup/.
- while
- Clicking the "Save" button [[file:img/newspeak---a-few-notes.org-save-button.png]], at any time after "Accept", saves the changes under the key /lastSaved/ (the changes under /backup/ are added and merged in to the changes under /lastSaved/). Once saved using the "Save" button, changes are stored "forever", unless you reset browser local storage for the site. We need to clarify, that making a change, followed by just clicking "Save" without a previous "Accept", nothing is saved. So "Accept" and "Save" are sort of like two phase commit.
- You can view the changes made, in the browser debugger.  For example, in Chrome or Chromium:
  - Press F12 to open Chrome debuger. 
  - Then click the "Application" tab.
  - In the "Storage" section expand "Local Storage".
  - You can see our changes in the appropriate URL, both under the key /lastSaved/ and the key /backup/.

- How does the/lastSaved/ and /backup/ system work on browser restart? On restart, the Newspeak system checks to see if there are any changes under the key /backup/ and/or under the key /lastSaved/. If /lastSaved/ changes exists, we check if there are any subsequent changes under /backup/. If not, we use the /lastSaved/ version.  If there are unsaved changes (/backup/ entry exists), a dialog will come up asking you how to proceed:  [[file:img/newspeak---a-few-notes.org-message-restore-from-backup.png]]
  - This message tells us, we did make code changes, then clicked "Accept" [[file:img/newspeak---a-few-notes.org-accept-image.png]], without pressing "Save" [[file:img/newspeak---a-few-notes.org-save-button.png]], and reloaded the page. In other words, changes are stored under the key /backup/ but not(yet) under /lastSaved/. In most situations, pressing *Restore from backup* is the best choice. Your code will load the changes from the /backup/ key, and contain all your changes. At any time, you can click "Save" and merge the /backup/ changes to /lastSaved/.
  - For search purposes, here is the text of the message: "You have backup changes that are newer than your last save. Do you want to restore these changes, or load from the last save?"

- Note: There is a fine point we should make. Crudely, we can say that "the Newspeak IDE is the file ~HopscotchWebIDE.vfuel~ interpreted by the browser when pointing to the URL https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel. However, we need to realize that the browser immediately downloads and caches this file. Changing anything in Newspeak (adding a class, typing to the Workspace), causes the changes to be saved locally. If we close the browser, and visit the same online URL again, we will see the site as we left it - with the local changes "added" to the vanilla Newspeak IDE! Which local changes are "added" (/backup/ or /lastSaved/ or both), is determined by your answer to the dialog above.

- Caveats: There are a few caveats - a few classes are exempt from this "backup" and "lastSaved" method, due to bootstrap issues (things like KernelForPrimordialSoup and HopscotchWebIDE). If you tamper with these - save the class explicitly! Also, web storage can surprise you on mobile platforms, where things can be thrown out after a certain amount of time (7 days on iOS?) and the system as a whole may exhibit bugs.

*** Saving changes outside the browser:

Apart from the /lastSaved/ and /backup/ in-browser changes management, you can save changes outside the browser. This is typically needed for development.


- If you do clear your browser local storage, your changes will be lost, so saving outside the browser is valuable.
    
- During development in Newspeak, you will want to save your work. Until source control is integrated into the IDE, the current approach is to `export` ("Save to file") all classes you changed in a directory on your system as *.ns* files, and potentially create a code repository in that directory. If we later want to bring the repository version to Newspeak, we `import` ("Compile File(s)") the *.ns* files back to Newspeak. For how to access the "Save to file" and "Compile File(s)" buttons, see TL;DR in section [[*Saving changes in Newspeak]]


** IN-PROGRESS-NOW "Importing" a dependency class in Newspeak

Hmm, this again ended up a super-long context description. I hope the question section C) is not that long, and we can start with that, and refer back if needed.


So, I am still discovering things around packaging and building, on a concrete example. Seems like I am making one step forward, two steps back. But the steps forward are important, still means progress :) 

During the package / build exercise, I defined a simple first task: Add a dependency (let me alternatively call it "import" for the purpose of this question) to an axisting app, to add string translations for 3 strings. For the purpose of this question, I should stress I am *not yet* interested in distributing such dependency as a library - purely interested in adding such dependency in an IDE and using it.

As a note, I realize my questions have already been asked by Phil a few months ago, discussed and answered by Gilad. But my context (*at the moment*) is slightly different: I am not yet interested in distributing such dependency, purely working within the IDE.


A) Let me describe the concrete example I use:
--------------------- 

- I am starting with the existing ~CounterApp~ - this consists of two files, CounterApp.ns and CounterUI.ns. I have copied and renamed them as CounterAppWithDependencies.ns and CounterUIWithDependencies.ns. The code flow is unchanged, the CounterAppWithDependencies packages itself in #packageUsing:, then instantiates CounterUIWithDependencies in it's #main:args:, etc

- The task was to add a class which would provide a translation. This is called ATranslation.ns (The only purpose of the leading A is for the class to show up on top of the IDE to find it quickly :) )

- This ATranslation.ns is needed by the classes in CounterUIWithDependencies.

- So the task at hand is : How do I "import" ATranslation to CounterUIWithDependencies, so it can be instantiated there, and provide the translation for the strings 'increment', 'decrement' and 'reset'?

- Repeating the note from above,  I am not yet interested in distributing such dependency, purely working within the IDE.

- The "solution" I did seems obvious and works; my questions will be around if such pattern is "normative" or at least "intended" in Newspeak, and if not, what are better patterns, etc. See questions section


B) The "core" of the "import solution"
------------------

(I am pasting more complete snippets at the end)

1. ~CounterAppWithDependencies>>packageUsing: manifest~
   added 
   ~private ATranslation = manifest ATranslation.~ to pull the class from the IDE's manifest, and store in on the App's slot for use in #main:args: to move the dependency to CounterUIWithDependencies. 

2. ~CounterAppWithDependencies>>#main:platform args:args~
   changed the call to the factory method of CounterUIWithDependencies to reflect it's change (item 3)

3. ~CounterUIWithDependencies factory~ 
   to move the dependency to the class, changed signature of the factory method from 

   ~CounterUIWithDependencies>>usingPlatform: p~

   to
   
   ~CounterUIWithDependencies>>usingPlatform: p andTranslationClass: aTranslationClass~

4. ~CounterUIWithDependencies factory slots~ 
   saved the newly passed dependency (import) on ~slot ATranslation~ 

5. ~CounterUIWithDependencies at the point where the translation is needed~
  create ATranslation new instance and use it to translate.
  ~aTranslation:: (ATranslation new)~
  ~aTranslation translate: 'increment'~

C) How would this be in Java or Python
------------------

On a high level (I hope not missing something and cheating) it seems only 2 points of change:

1. ~CounterUIWithDependencies~, add  ~import ATranslation"~

2. ~CounterUIWithDependencies at the point where the translation is needed~
  create ATranslation new instance and use it to translate.
  ~aTranslation = (new) ATranslation()~
  ~aTranslation.translate('increment')~

3. At runtime, ensure that ~ATranslation~ is added to the (class)path. This would be done by the IDE if running in the IDE, and by the build script (but the fact remains something or someone has to ensure this)
   
C) The Questions and notes I have
------------------

1. Would the "import solution" consisting of the 5 points in items B)1 to B)5 be a "proper", "normative" or at least "ok" "pattern" for "importing a dependency" in Newspeak? (I am only interested in the Newspeak specifics, not, for example that ATranslation could be a singleton etc)  *If the answer is "no" I suppose the questions below are without a point but asking them still as any comments would still be helpful*
   
2. My next question is similar to what Phil already asked I think, related to B3: For every such new import/dependency to CounterUIWithDependencies, don't we have to change the signature and add
   ~CounterUIWithDependencies>>usingPlatform: p andImportedClass1: class1 andImportedClass2: class2 etc~? This would lead to a massively expanding factory signature with growing numbers of imports. I suppose we can either "wrap" all such imports to
   - either the platform (?)
   - or an ~andImportedClasses: importedMap~ addition to the map
     is that a possibly intended "pattern"?
     
3. An import requires a 3 code-change-points in other languages (of which 2 are likely done by the IDE), we have 5 code-change-points in Newspeak. (This may not be completely fair comparison, if we do not care about the CounterUIWithDependencies to be used in the app CounterAppWithDependencies, it is only 3 changes in Newspeak but still requiring the heavy feeling factory signature change in item 2 above). I accept a price like this to pay for modularity, but would like to make sure I understand how things are.

4. Note only: The factory signature change in B)3 does not leak to clients if CounterUIWithDependencies were to be distributed as a library by adding the #buildUsing: method as described in previous posts here, correct? (will confirm with experiments) 
   
5. I suppose the IDE eventually can make the amount of code changes required (5) to be reduced. Is it conceivable the IDE, upon developer adding a line like
     ~aTranslation:: ATranslation new~
     would
     - add a slot for it
     - and change the factory method by adding ~andTranslation: ATranslation~?


Thanks,

Milan


PS: The almost full code for the "solution" for "importing ATranslation"
------------------

Let me just paste the material part of the code. Only lines that include the string "translation" were added or changed, compared to original 

----------------------------
class CounterAppWithDependencies packageUsing: manifest = (
    |
    private hopscotchRuntime = manifest HopscotchForHTML5Runtime packageUsing: manifest.
    private CounterUIWithDependencies = manifest CounterUIWithDependencies.
    
    private ATranslation = manifest ATranslation.
    |
) (


  public main: platform args: args = (
    | 
    hopscotchPlatform = platform isKindOfPlatformWithHopscotch ifTrue: [platform] ifFalse: [hopscotchRuntime using: platform].
    ui = CounterUIWithDependencies usingPlatform: hopscotchPlatform andTranslationClass: ATranslation.
    |
          
    hopscotchPlatform hopscotch HopscotchWindow openSubject: (ui CounterSubject onModel: ui Counter new).
  )
)


----------------------------
class CounterUIWithDependencies usingPlatform: p andTranslationClass: aTranslationClass = (
  |
  private Subject = p hopscotch Subject.
  private Presenter = p hopscotch Presenter.
  
  private ATranslation = aTranslationClass.
  |
) (

  class CounterPresenter onSubject: s <CounterSubject> = Presenter  onSubject: s (
  ) (
      definition = (

        |aTranslation|
        aTranslation:: (ATranslation new).
    
        ^row: {
            label: subject count. 
            mediumBlank. 
            button: (aTranslation translate: 'increment') action: [updateGUI: [subject increment]].
            button: (aTranslation translate: 'decrement') action: [updateGUI: [subject decrement]].
            button: (aTranslation translate: 'reset')     action: [updateGUI: [subject clear]].     
            }.
      )
 ... etc ... 

-----------------------------
class ATranslation = (
	|
	slot1
	slot2
	|
) (

    public translate: text = (

      text == 'increment' ifTrue: [^ 'pridat'.].
      text == 'decrement' ifTrue: [^ 'ubrat'.].
      text == 'reset' ifTrue: [^ 'vymazat'.].
      
      ^ 'unable to translate'.
    )
)

** IN-PROGRESS Packaging and distributing a Newspeak app


*** IN-PROGRESS A Concrete Newspeak example: Packaging and distributing a concrete app

TL;DR: For a detail description of developing, packaging, running and deploying a Newspeak app, read the section [[Newspeak quickstart: Explore the IDE. Then develop ~CounterApp~, package it and deploy it]]

The text below is a general introduction.

How would I go about building and running a "Hello world" application? I know I can create a class, in the browser IDE .. ok .. but from there, how to I "create and deploy the application" so I end up with something like the ToDo app ... hmm, I should probably do my homework and study it, but any high level notes on that?

*There are two options to build an app*

1) Easy but flakey. There is a 'deploy' option that the IDE displays
   for apps.  It's buggy and slow, but mostly works if you are
   prepared to wait a ridiculous amount of time, and tolerate the fact
   that the app will be too large due to bugs in the serialization
   code :-(. We need to fix that, but you can deploy apps that way,
   especially if they are small. You choose the option
   'asVictoryFuelWithMirrors' if your app uses the GUI (there's some, probably gratuitous, mirror dependency in the UI)  and 'asVictoryFuel' otherwise.
   - Details:  where is the [deploy] button. Go to 'Newspeak source code". Look at HopscotchWebIDE class (it's the one app pre-loaded in the system). You'll see the deploy link in two places. In the Root namespace itself - if your window is wide enough, it will show on the same line as the link for the class. If you open the class, it will be at the top, to the right of the class name.

2) Slightly more complex, but works better. You use a script that runs the C version of the PSoup VM to do  the deployment. THis is faster, more reliable and produces smaller deployments. 

In either case, .vfuel file is produced.  Assuming you are running Newspeak using option 1 (a local server, [[install-method-1]]), you can then serve that file and run your app.

*Deployment of the app*

This .vfuel can then be deployed into a (locally installed) Newspeak server.

- For instructions on how to install the server see [[install-method-1]]
- For instructions on how to deploy a sample app, in particular the ~CounterApp~, see [[Deploy ~CounterApp~ as standalone app into local Newspeak server]].
  

*** IN-PROGRESS-NOW A Concrete Newspeak example: Develop, package, distribute ~AHelloWorldApp~ app

steps, local or web

- http://localhost:8081/primordialsoup.html?snapshot=HopscotchWebIDE.vfuel
- Newspeak Source
- top left, "Root +", click +, popup will show, in the popup, click "Add Class" with method  ~#main:args:~
  #+begin_src groovy
    class AHelloWorldApp = (
        |
        slot1
        slot2
        |
    )(
    public main: platform args: args = (
        |
        localVar1
        localVar2
        |        
        )
    ):(
    )
  #+end_src
- The above does NOT show *[deploy] [configurations] [run] [debug]* so it is not an app, despite defining method ~#main:args:~
- Now add a constructor ~#packageUsing:~
  
  #+begin_src groovy
    class AHelloWorldApp packageUsing: manifest = (
        |
        slot1
        slot2
        |
    )(
    public main: platform args: args = (
        |
        localVar1
        localVar2
        |        
        )
    ):(
    )
  #+end_src
- Now IDE DOES show *[deploy] [configurations] [run] [debug]*
- Deleting ~#main:args:~ still DOES show *[deploy] [configurations] [run] [debug]*
- *SO IF CLASS HAS A CONSTRUCTOR ~#packageUsing:~ it is considered an app by the IDE, and shows the *[deploy] [configurations] [run] [debug] buttons beside the class. However, the presence of  ~#main:args:~ is necessary for the class to function in any useful way.*
  
AAAAAAAAAAAAAAAAAAAAAA
ide namespacing manifest Collections



*** IN-PROGRESS-NOW Snippets of wisdom from various sources

Sources (may not be complete)
- Newspeak user group on Google groups: 

Snippets of wisdom

- StringTest>>#testShout is the Smalltalk way of identifying the testShout method of the StringTest class. When you actually type the code into the browser, you don’t have to type the class name or the >>; instead, you just make sure that the appropriate class is selected. Documentation example in text should show abstract argument names:
  #+begin_example
    History>>goBackward
      self canGoBackward ifFalse: [self error: 'Already on the first element'].
      stream skip: --2.
      ^ self next.

    History>>goTo: aPage
      stream nextPut: aPage.
  #+end_example
- In Newspeak, a top level class declaration is always a module declaration. So this is a module:
  #+begin_src groovy
    class HelloBraveNewWorld usingPlatform: platform = (
      platform squeak Transcript open show: ‘Hello, Oh Brave new world’.
    )
  #+end_src
  If we had written
  #+BEGIN_SRC groovy 
    class HelloBraveNewWorld = (
      Transcript open show: ‘Hello, Oh Brave new world’.
    )
  #+END_SRC
  and then created an instance via ~HelloBraveNewWorld new~ (if a class doesn’t specify a message for creating instances, new is the default), we would get a doesNotUnderstand: error, because HelloBraveNewWorld does not understand the message Transcript. There simply is no way to access the standard output stream, or any other system state, without having it passed in via a parameter when a module is instantiated.
- ~ide namespacing manifest Collections~
- Workspace: ~collections~
- If you are learning, make everything public. everything = each method, slot, and inner class. It may not be the right thing, but it helps as the error messages are not the best currently. You will just get "Does not understand" too many times. First time it took me a day to figure out hehe. 
- so, basically, if I have an HTML string with a <div class='helpButton'>, this code in ClassPresenter>>helpText:  can insert a Hopscotch(?) instance of  HelpButton (assuming HelpButton was implemented) and the HelpButton instance will present itself as Html on that div? Hmm, maybe that org-to-ampleforth just got more exciting - but I have to hold myselt. -- answer: Pretty much. You need to define the mapping from div classes to Newspeak widgets, as ClassPresenter>>helpText: does for the widgets it uses.
-  Library is an informal term. Any Newspeak module definition (i.e., a top level class) is a library, and to use, it you call its class methods, most likely to instantiate it.
If you want to deploy a module, well, you need to use it via an app (i.e, define something with #packageUsing: and #main:args:), directly or indirectly. 




*** IN-PROGRESS Concepts: Packaging and distributing an app in 'mainstream' software 

TL;DR: The intent of this section is to describe the "mainstream" lifecycle of developing, building, distributing, installing, and running a program, for the purpose of describing Newspeak builds.

This section is not meant to be a self-contained or axiomatic description of concepts - it will rely on terms and concepts that are not always uniquelly defined or described. Concepts may overlap, and are meta-circular so this section is vague.

We will use the following terms: 
  - The *program*, *app*, *application* interchangeably, these terms describe the software the /end-user/ interacts with to achieve some desired goal. These terms are overlapping, but generally are similar on the web, iOS, Android, or desktop. In addition, it is hard to define a /program/ simply, as some programs may have multiple components (client, server, database, etc). This section pretends a /program/ is the component the /end-user/ interacts with.
  - The *package* (noun) is the artifact (usually a file) that contains the /program/ in a form available for distribution in the /repository/. Often, this is called the /program package/ or the /packaged program/.
  - The *end-user* is the user of the /program/.
  - The *system* is the software which allows the /end-user/ to use the /program/. 
    - Examples:
      - /Web      system/  is the browser. However, a *web server* on which the /program package/ is installed, must be also available, making the whole web the /end-user's system/.
      - /Newspeak system/  is the browser. All comments from the web apply. 
        - Note: Newspeak development is development for the Web. Except it does not necessarily use HTML and CSS, and likely would not use Javascript. In addition, any Newspeak program can be /packaged/ as an iOS or an Android app.
      - /iOS      system/  is the operating system if /end-user/ uses Apple phone or tablet to install and run the /program/.
      - /Android  system/  is the operating system if /end-user/ uses Android phone or tablet to install and run the /program/.
      - /Linux    system/  is the operating system if /end-user/ uses Linux to install and run the /program/.
  - The *developer* is the person, persons, or organization who /create/ the /program/, and make it available to the /end-user/, by submitting it (copying it) to a /repository/ or to a /web server/. 
  - The *repository* is the location (accessible by a URI) where /package/s of /program/s are stored for public access by the /end-user/. 
    - The concept of /repository/ is different for the Web and in Newspeak on one end, and iOS, Android or desktop on the other end. 
      - On the web and Newspeak, there is no /repository/ the /end-user/ need to worry about. 
        - The developer (or organization) typically controls the webserver into which the /program package/ is /installed/.
        - The /repository/ and the /web server/ collapse into one. 
        - The /end-user/ does NOT /install/ any /program/ on their /system/, instead, they navigate their browser to an URL to /run/ or /use/ the /program/ which was placed there as a /package/ by the /developer/. 
        - The /install/ action is an action of the /developer/ (equivalent to the /submit to repository/ action), not an action by the end user. 
      - On iOS, Android or desktop, the /repository/ is some publicly provided site from which the /end-user/ can /install/ the /packaged program/.
    - However, there is a concept of *browser programs repository* as well: the browser authoring organization often maintains a *repository of extensions* to which a /program package/ can be submitted and made available to the end-user. 
  - To *build* a /program/ is the action of the /developer/, which makes the /program/ available for distribution in the /repository/ by creating a /program package/. Sometimes the verb 'to package' is used instead of 'to build'. We will avoid using 'to package' as a verb.
  - To *submit* a /program/ to a /repository/ is the action of the /developer/ which makes a /program/ which has been previously /built/, available to the /end-user/. 
  - To *install*, or *deploy* a /package/:
    - On the web, and in Newspeak, is an action of the /developer/ who places the program /package/ to a web server, from where the /end-user/ runs the /program/.
    - On the iOS, Android, or desktop, is an action of the /end-user/, who /install/ s the program from the /repository/ into their /system/. 
 
The main point of this section is that *a program may be /developed/ once, but the /system/ on which the program is made available to the /end-user/, dictates how the program is /build/, /submitted/, and /installed/.* (Some of those steps are overlapping or not needed depending on the /end-user/'s /system/.)

We can summarize the lifecycle of allowing the /end-user/ to use a program created by a developer as follows:

- Developer *develops* the *program*.
  - Examples:
    - /Web      developer/ *develops* a web program in a combination of HTML, CSS, and Javascript. 
    - /Newspeak developer/ *develops* a web program in Newspeak. 
    - /iOS      developer/ *develops* an iOS app.
    - /Android  developer/ *develops* an Android app.
    - /Linux    developer/ *develops* a Linux program.
- From the program, developer *builds* a *program package*.
  - Examples:
    - /Web      developer/ *builds* a ~.zip file or a .jar~ file of all the components needed to run his/her program inside the web server. The zip or jar file is the *web program package*
    - /Newspeak developer/ *builds* a ~.vfuel~ file from their Newspeak program. The ~.vfuel~ file is the *Newspeak program package for the web*. 
    - /iOS      developer/ *builds* an ~iOS app file~ for distribution in Apple store.
    - /Android  developer/ *builds* an ~.apk file~ for distribution in Google Playstore.
    - /Linux    developer/ *builds* an ~.rpm file~ for distribution (for example, in the Opensuse OSS repository).
    - Note: In the above examples, the *program package* is the .zip file, .vfuel file, .iOSapp file, .apk file, .rpm file. 
- Developer *submits* the *program package* into a *repository* of packages for *distribution* to end-user. 
  - /Web      developer/ *submits* (copies) the *web program package* (the zip or jar file) into a running (or to be started) webserver. This step is generally different from iOS, Android, or desktop, in that the /repository/ is not necessarrily publicly available. See discussion in the term /repository/ above.
  - /Newspeak developer/ *submits* the ~.vfuel~ file to the *Newspeak repository*. Note: there is currently no publicly available repository of Newspeak programs in the form of .vfuel files. The end-user must receive the .vfuel file from the developer by some secure means OR, run the ~.vfuel~ file on the web, where it is installed by the developer into a end-user-trusted website. The Newspeak program lifecycle is the same as the lifecycle for the web. 
  - /iOS      developer/ *submits* the ~iOS app~ for distribution in Apple store (*repository*).
  - /Android  programme/ *submits* the ~.apk file~ for distribution in Google Playstore (*repository*).
  - /Linux    developer/ *submits* the ~.rpm file~ for distribution in the *repository* (for example, OpenSUSE OSS repository)
- End-user *installs* (or copies) the *program package* from the *repository* into their *system*.
  - /Web      end-user/ generally does not have to do anything here. The developer /installs/ the program for the /end-user/.
    - Note: that there is an alternative to this process on the web. The /end-user/ can run their own /web server/, for example locally, and install the developer-provided /web program package/ (a .zip or .jar file) into the server they control.
  - /Newspeak end-user/ is generally in the same position as the /web end-user/ - he/she does not have to do anything here.
    - Note: As the Newspeak process generally is the same as the web process, there is an alternative: The /end-user/ can run their own /web server/, for example locally, and install the developer-provided Newspeak ~.vfuel~ file into their local Newspeak server. The ~.vfuel~ file is the *Newspeak program package for the web*. We haved used this process in our ~CounterApp~ local deployment. See section [[Deploy ~CounterApp~ as standalone app into local Newspeak server]].
  - /iOS      end-user/ *installs* the ~iOS app~ from Apple store (*repository*).
  - /Android  end-user/ *installs* the ~.apk file~ from Google Playstore (*repository*).
  - /Linux    end-user/ *installs* the ~.rpm file~ from the *repository* (for example, OpenSUSE OSS repository)
- End-user *runs* the *program* from the *program package* (which is now installed on their system) on their system.
  - /Web      end-user/ *navigates their browser* to the URL where the developer /installed/ the /program/. 
    - Note: If the /end-user/ runs their own (local) server, the URL would point to the local server, as discussed int the /install/ section above.
  - /Newspeak end-user/ *navigates their browser* to the URL where the developer /installed/ the /program/ (same as on the web) . For example, /end-user/ may navigate to the ~CounterApp~ on the Newspeak website, where it was installed: https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel.
    - Note: If the /end-user/ runs their own /web server/ for Newspeak, for example locally, and installed the developer-provided Newspeak ~.vfuel~ file into their local Newspeak server, the URL would be http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel. See section [[Deploy ~CounterApp~ as standalone app into local Newspeak server]].
  - /iOS      end-user/ *runs* the ~iOS app~ from Apple store (*repository*).
  - /Android  end-user/ *runs* the ~.apk file~ from Google Playstore (*repository*).
  - /Linux    end-user/ *runs* the ~.rpm file~ from the *repository* (for example, OpenSUSE OSS repository)
 


*** IN-PROGRESS Newspeak general: Packaging and distributing a Newspeak app - Namespace, Global namespace, manifest

**** IN-PROGRESS How to package a program for distribution, given a global namespace?

Next, there is the question of how you put together your program given the global namespace.  This is the domain of build scripts in traditional software. In Newspeak, you can write these scripts in Newspeak itself.  The build script would take a *namespace object* as a parameter (what we often call a *manifest*). You'd typically pass in the IDE's top level namespace (try evaluating ~ide namespacing manifest~ in a workspace). Of course, you can always override the behavior of a given manifest by wrapping it.

So you write class with a #packageLibraryUsing: method that takes a manifest and instantiates your library as you wish. The manifest needs have all the code you need. Importantly, the manifest is still under 'end user control' and should contain only top level classes (we can also enforce that) so no state or access to the outside world is provided. Thus, the #packageLibraryUsing: methods are like build scripts, and they can call other #packageLibraryUsing: methods, just like build scripts or makefiles refer to others. The difference being that none of this is hardwired to a specific global namespace.

This is very similar to how one builds apps.  There are no examples of this pattern, because we have no third party libraries yet.

**** IN-PROGRESS Example of bringing dependencies into an application and publishing an application

Imagine a convention whereby *every library intended for distribution is sent out as a class which:*

 - has a factory (or in general, class method) method ~#packageLibraryUsingManifest: manifest~ - 
 - has a ~#build: platform~ method - this method, given a platform object, produces a working instance of the module we actually want to distribute

Now developer A (Alice) intends to distribute a module MyMod1.
It depends on some other code she developed, say, MyMod2, which in turn depends on a 3rd party library from developer B (Bob).
The module Alice distributes is below.

#+BEGIN_SRC newspeak
class MyModules packageLibraryUsingManifest: manifest = ( 
 (* packageManager: ... metadata describing the expected dependencies *)
  |
  MyMod1 = manifest MyMod1.
  MyMod2 = manifest MyMod2.
  My3rdPartyDep = manifest My3rdPartyDep packageLibraryUsingManifest: manifest.
  |
) (
   public build: platform = (
      |
      my3rdPartDependency = My3rdPartyDep build: platform.
      myMod2 = MyMod2 usingPlatform: platform and: my3rdPartDependency.
      myMod1 = MyMod1 usingPlatform: platform mod2: myMod2.
      |
     ^myMod1
   )
)
#+END_SRC

The ~#build: platform~ method encapsulates the knowledge of how to build Alice's code, using an internal library she wrote (MyMod2) and Bob's library.  

Note that Alice is using the same convention as Bob, and builds Bob's code with no knowledge of its internal dependencies.
Developer C (Carol) uses these same conventions to build Alice's code. She can do so regardless of whether
- she is *building an app* (where she'd call ~#packageLibraryUsing: manifest~ from the app's factory, and ~#build: platform~ from ~#main: platform args: args~
- or she is *building another library* (where she'd call ~#packageLibraryUsing:~ from the library factory).

If Alice decides to replace Bob's code with code from developer D (David), she changes MyModules, but Carol's code does not change. Likewise, if Bob or David change their dependencies, neither Alice nor Carol change their code.

It isn't necessary for everyone to follow the exact same convention - what's critical is that a given module maintains its convention so its build API is stable. Of course, a common convention is good, especially for tools. 

Alice could just distribute an instance of MyModules, but this hardwires the versions of all the dependencies.  Assuming she doesn't do that, it is true that Carol needs to download all the pieces and their sub-pieces from Bob and Alice etc. She loads them into the IDE (or the IDE does so by reading the metadata) and the IDE's namespace is used to produce the manifest object passed in when anyone builds an app.

Note that ~platform~ and ~manifest~ need are quite different. Manifests are a development thing. Platforms are a deployment thing.

- ~Platforms~ are for runtime capabilities and are security critical. The platform is something that gives you the only connections to the world outside Newspeak. 
- ~Manifest~ are for code construction (see ~#packageUsing: manifest~). The Newspeak IDE provides a global namespace, which is a real object that you can pass around.  That object is a manifest.


Anyway, hopefully this helps to answer the question. 

--
Cheers, Gilad
Gilad Bracha
29 Apr 2021, 19:32:52
to newspeak...@googlegroups.com
(slightly edited and merged from other posts by Milan Zimmermann)

**** IN-PROGRESS What is a 'manifest'?

TL;DR: manifest is an object which shows known 'libraries' that can be 'imported'

In Workspaces, Evaluate
#+begin_src newspeak
ide namespacing manifest
#+end_src

- result shows instance of manifest, with field ~namespace~, instance of Map 
- ~namespace~ keys are things like "Kernel", "Icons", "CollectionsForPrimordialSoup"
- values are instances of those
- The point of the manifest is todo 


* Q&A - answers should be either here directly, or link to an earlier section

Much of this Q&A is sourced and expanded, or simply pasted from the Newspeak google group posts at https://groups.google.com/g/newspeaklanguage

** IN-PROGRESS-NOW Working with code

todo

*** How do I save my changes? 

Newspeak doesn't have an image. So what do I actually do to develop software? I mean, I presume I run a copy of Newspeak somehow, and start adding classes to it. But then where / how do my additions get saved if there isn't an image? When I've added a couple of classes to a running Newspeak environment, I presume they don't just disappear when I switch my computer off? So where do they go? Or where do I put them?

Changes in Newspeak are always saved locally, as long as you click the "Accept" button after making changes.

It won't save your state, but it will save your code. Bear in mind that the web-based system is young and will crash occasionally, but also that *the system saves your changes as backup regardless of whether you saved explicitly*. 

For a complete discussion, see [[*Saving changes in Newspeak]].
 

*** How would I build and deploy a ~AHelloWorldApp~ or a more complex ~CounterApp~ application?

For the ~CounterApp~ example, see section [[A Concrete Newspeak example: Packaging and distributing a concrete app]]



** When or why to refresh the online IDE?

Why will you refresh? Apart from the odd crash, the more common problem is the performance issues that have been discussed in this forum in December/January. Basically, we have an unresolved problem that the system slows down painfully under prolonged/heavy use. Refreshing and loading from backup works fairly well.  This is obviously unacceptable as you lose IDE state (debuggers, workspace/inspector contents, unsaved editors, presenter state such as what method presenters are expanded or collapsed) but it's better than an unresponsive (sluggish to dead) system.


** TODO Why do some classes show the [deploy] [run] [debug[ links?

Only classes that the IDE considers apps (applications) show these links.

IDE concludes a class is an app based on a convention: presence of certain methods. For details which method(s), see [[Develop, package, distribute ~AHelloWorldApp~ app]]


* TODO SECTIONS NOT READY. IGNORE FOR NOW 

** TODO Structure of paragraphs

TL;DR: This section describes 

- 

Assumptions: 

- 

Notes:

- 

*Steps: To achieve YYYYY, do the following:*


- Action: 
- Result:  
- Can contain:
  - Question: What makes a Newspeak class a "runnable Newspeak application"?. todo 
  - Note: 


Summary: 

- 

Next: 

** TODO Newspeak terms:

- ~.vfuel~ :: Files with this extension are essentially "deployable applications in wasm". They can be deployed by copying them into the running Newspeak web server. todo - this is not quite correct.

  
** TODO Newspeak syntax

*** Comments ~(* comment *)~ 

Code like ~(* comment *)~ is a comment. We use this in our examples, but sometimes, we just say ~( .. code here .. )~ - the latter would not compile.

*** TODO Class definition
#+begin_src 

#+end_src

*** Definitions in Newspeak have syntax similar to ~someName = ( .. code here ..)~

In any Newspeak code, we will quickly discover syntax segments such as ~someName = ( .. code here ..)~. The text below is somewhat vague, and somewhat incorrect, but should help orienting us in Newspeak code.

Note that the brackets ~(~ and ~)~ can be all inline, on lines by itself, or combined on one line for readability - whitespace is ignored during parsing.

At all places, such syntax is a definition of something: *a library*, *a class*, *a class initializer slots* (members)  *a method* etc.

Note that for example for class definition, there may be multiple sections, such as  ~someName = ( .. code here ..)( .. other code here ..)~

**** Class definition examples:

***** Class definition:

#+begin_src
class RGBCar = ()()
#+end_src

From the specs: the above also defines a constructor : Class definitions create a *class factory object* that can produce instances of the class. The factory object *supports at least one message* that produces new instances. This is known as the *primary factory method*. By default, it is called new.

***** A commented class definition:

This code shows the three blocks a class definition can have, with comments what code we define or write in each block:

#+begin_src
class RGBCar = (
  (* instance initializer: inits slots and runs initializer code*)
)(
  (* class body: defines instance methods or inner classes *)
):(
  (* class methods are in a group after : *)
)
#+end_src

What is initializer code? It is code that runs first before class instances are "returned" (visible) to context.

***** Class definition with uninitialized slot:

#+begin_src
class RGBCar = ( |rgbColor. numWheels.| )()
#+end_src

***** Class definition with initialized slot:

#+begin_src
class RGBCar = ( |rgbColor = "Blue". numWheels = 4. | )()
#+end_src

***** Class definition with uninitialized slot followed by some code:

#+begin_src
class RGBCar = ( |rgbColor.| rgbColor = "Blue". )()
#+end_src

***** Class definition defining a constructor which allow parameters passing:

#+begin_src
class RGBCar rgbColoe: aRgbcolor = (
  |rgbColor ::= aRgbColor.| (* ::= means mutable. immutable would be just = *)
)(
)
#+end_src

 
**** Instance method definition examples:

#+begin_src
class RGBCar = (
  | rgbColor = "Blue".
    numWheels = 4.
  |
)(
  public color = ^rgbColor.
  public commentColor: aComment = ( ^ rgbColor, aComment ). (* comma is string concatenator! *)
)

#+end_src
**** TODO A somewhat full flegded example of declaring *a library*, *a class*, *a class initializer slots* (members)  *a method* etc.

Note that classes can be nested. Library is just a class with nested classes.

#+begin_src 

class CarLibrary = (
    (* library initializer would usually be empty*)
  )
  (
    class RGBCar = (
      (*slots and initializer code*)
    )(
      (* instance methods or inner classes *)
    ):(
      (* class methods are in a group after : *)
    )
  )
:
(
)
#+end_src

**** TODO Instance Method definition examples:

Note: Method definition is normally called method definition. But let us keep the same term, definition.

Methods are defined in the second code section 
#+begin_src
class 


#+end_src

*** A rant about ~x:, x::, x::=, x=, x~ etc 

APL (https://aplwiki.com/wiki/Simple_examples) is beautiful (not that I ever learned it, not even close). I appreciate its extreme terseness, and its use of non-ascii characters. I would appreciate it much more if I was a pro in it. But I assume that would take a long time, and I would have to live in it daily.

I do not appreciate extreme terseness in "mainstream" programming languages as much. It can accumulate to the point, even working with a language daily, I scratch my head reading code "what is this sequence of ?, =, +, /" - or what you have it.

A language may start with duplicating some "common" arithmetics operators

~+, *, /, -, %~ (ok, why? math uses "mod". But I digress), then we may have ~++, ~/~ (ok, already I had to look that up) etc..

Then of course there may be the assignment versions of those

~+=, *=, /=, -=, %=~ etc.. not even talking ~|=~ etc..

Then we may have relational operators

~>, <, >=, <=~ - these are obvious as they are mostly borrowed from math .. sort of .. because mainstream keyboards are stuck on ascii, <= is a poor translation of it's math counterpart  

equality operators

~==, !=~ - not always obvious, as languages uses conflict 

Then we may have the bitwise and shift operators

~&, |, ^~ (another one I had to look up), shift left ~<<~, etc ..

and of course the logical operators

~||, &&, !~

and perhaps the "dot" and "dot dot" - the object member access syntactic elements

~., ..~ 

etc

I suppose, most of the curly braces languages do use all of the above the same way - that is why I only do not remember a relatively small subset of them :( , and I do not complain that much :)

But, reading code, many of those operators are still a pain and require some king of mental pause or a mental switch! Code is read much more often than written. When writing code, they are a bit of a pain as well, perhaps not as much, as one uses a relatively small subset (or the obvious subset such as those used in arithmetics).

Ok, fair enough .. well not quite fair, but accepted by years of burning this into our brains.

But later, the language users may start to complain: "I have to write this and that, and it's too much typing", or "oh we need to screen for null so much" and so we get:

~expr ? stmt : stmt2~ - most bracey languages have this, so it should go to the above

and

~?.~ - as in ~myObject.?myProperty~

and

~??~ - as in ~myStr ?? "empty"~

and

~??=~ as in ~value ??= 5~

and maybe

~...?~ as i ~['first', ...?aList]~


The mental pause with those, depending on how much you use the language in question, can be significant. To the point, one cannot really read the code fluently unless embedded in the particular language daily.


I realize this stuff is todo 

also


Operator	Name	Meaning
()	Function application	Represents a function call
[]	List access	Refers to the value at the specified index in the list
.	Member access	Refers to a property of an expression; example: foo.bar selects property bar from expression foo
?.	Conditional member access	Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)

todo


All this long story above gets me to my main point of syntax difficulty with Newspeak. When first studying Newspeak, it took me forever to figure out the ~x:, x::, x::=, x=, x~. What I mean:

#+begin_src 
class RGBCar = (
  (* instance initializer: inits slots and runs initializer code*)
  |
  numWheels = 4.
  mats ::= 'basic'.
  |
)(
  (* class body: defines instance methods or inner classes *)
):(
  (* class methods are in a group after : *)
)


#+end_src











