#    -*- mode: org -*-


Archived entries from file /home/mzimmermann/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org


* TODO SECTIONS NOT READY. IGNORE FOR NOW 
  :PROPERTIES:
  :ARCHIVE_TIME: 2021-07-14 Wed 12:02
  :ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
  :ARCHIVE_CATEGORY: newspeak---a-few-notes
  :ARCHIVE_TODO: TODO
  :END:

** TODO Structure of paragraphs

TL;DR: This section describes 

- 

Assumptions: 

- 

Notes:

- 

*Steps: To achieve YYYYY, do the following:*


- Action: 
- Result:  
- Can contain:
  - Question: What makes a Newspeak class a "runnable Newspeak application"?. todo 
  - Note: 


Summary: 

- 

Next: 

** TODO Newspeak terms:

- ~.vfuel~ :: Files with this extension are essentially "deployable applications in wasm". They can be deployed by copying them into the running Newspeak web server. todo - this is not quite correct.

  
** TODO Newspeak syntax

*** Comments ~(* comment *)~ 

Code like ~(* comment *)~ is a comment. We use this in our examples, but sometimes, we just say ~( .. code here .. )~ - the latter would not compile.

*** TODO Class definition
#+begin_src 

#+end_src

*** Definitions in Newspeak have syntax similar to ~someName = ( .. code here ..)~

In any Newspeak code, we will quickly discover syntax segments such as ~someName = ( .. code here ..)~. The text below is somewhat vague, and somewhat incorrect, but should help orienting us in Newspeak code.

Note that the brackets ~(~ and ~)~ can be all inline, on lines by itself, or combined on one line for readability - whitespace is ignored during parsing.

At all places, such syntax is a definition of something: *a library*, *a class*, *a class initializer slots* (members)  *a method* etc.

Note that for example for class definition, there may be multiple sections, such as  ~someName = ( .. code here ..)( .. other code here ..)~

**** Class definition examples:

***** Class definition:

#+begin_src
class RGBCar = ()()
#+end_src

From the specs: the above also defines a constructor : Class definitions create a *class factory object* that can produce instances of the class. The factory object *supports at least one message* that produces new instances. This is known as the *primary factory method*. By default, it is called new.

***** A commented class definition:

This code shows the three blocks a class definition can have, with comments what code we define or write in each block:

#+begin_src
class RGBCar = (
  (* instance initializer: inits slots and runs initializer code*)
)(
  (* class body: defines instance methods or inner classes *)
):(
  (* class methods are in a group after : *)
)
#+end_src

What is initializer code? It is code that runs first before class instances are "returned" (visible) to context.

***** Class definition with uninitialized slot:

#+begin_src
class RGBCar = ( |rgbColor. numWheels.| )()
#+end_src

***** Class definition with initialized slot:

#+begin_src
class RGBCar = ( |rgbColor = "Blue". numWheels = 4. | )()
#+end_src

***** Class definition with uninitialized slot followed by some code:

#+begin_src
class RGBCar = ( |rgbColor.| rgbColor = "Blue". )()
#+end_src

***** Class definition defining a constructor which allow parameters passing:

#+begin_src
class RGBCar rgbColoe: aRgbcolor = (
  |rgbColor ::= aRgbColor.| (* ::= means mutable. immutable would be just = *)
)(
)
#+end_src

 
**** Instance method definition examples:

#+begin_src
class RGBCar = (
  | rgbColor = "Blue".
    numWheels = 4.
  |
)(
  public color = ^rgbColor.
  public commentColor: aComment = ( ^ rgbColor, aComment ). (* comma is string concatenator! *)
)

#+end_src
**** TODO A somewhat full flegded example of declaring *a library*, *a class*, *a class initializer slots* (members)  *a method* etc.

Note that classes can be nested. Library is just a class with nested classes.

#+begin_src 

class CarLibrary = (
    (* library initializer would usually be empty*)
  )
  (
    class RGBCar = (
      (*slots and initializer code*)
    )(
      (* instance methods or inner classes *)
    ):(
      (* class methods are in a group after : *)
    )
  )
:
(
)
#+end_src

**** TODO Instance Method definition examples:

Note: Method definition is normally called method definition. But let us keep the same term, definition.

Methods are defined in the second code section 
#+begin_src
class 


#+end_src

*** A rant about ~x:, x::, x::=, x=, x~ etc 

APL (https://aplwiki.com/wiki/Simple_examples) is beautiful (not that I ever learned it, not even close). I appreciate its extreme terseness, and its use of non-ascii characters. I would appreciate it much more if I was a pro in it. But I assume that would take a long time, and I would have to live in it daily.

I do not appreciate extreme terseness in "mainstream" programming languages as much. It can accumulate to the point, even working with a language daily, I scratch my head reading code "what is this sequence of ?, =, +, /" - or what you have it.

A language may start with duplicating some "common" arithmetics operators

~+, *, /, -, %~ (ok, why? math uses "mod". But I digress), then we may have ~++, ~/~ (ok, already I had to look that up) etc..

Then of course there may be the assignment versions of those

~+=, *=, /=, -=, %=~ etc.. not even talking ~|=~ etc..

Then we may have relational operators

~>, <, >=, <=~ - these are obvious as they are mostly borrowed from math .. sort of .. because mainstream keyboards are stuck on ascii, <= is a poor translation of it's math counterpart  

equality operators

~==, !=~ - not always obvious, as languages uses conflict 

Then we may have the bitwise and shift operators

~&, |, ^~ (another one I had to look up), shift left ~<<~, etc ..

and of course the logical operators

~||, &&, !~

and perhaps the "dot" and "dot dot" - the object member access syntactic elements

~., ..~ 

etc

I suppose, most of the curly braces languages do use all of the above the same way - that is why I only do not remember a relatively small subset of them :( , and I do not complain that much :)

But, reading code, many of those operators are still a pain and require some king of mental pause or a mental switch! Code is read much more often than written. When writing code, they are a bit of a pain as well, perhaps not as much, as one uses a relatively small subset (or the obvious subset such as those used in arithmetics).

Ok, fair enough .. well not quite fair, but accepted by years of burning this into our brains.

But later, the language users may start to complain: "I have to write this and that, and it's too much typing", or "oh we need to screen for null so much" and so we get:

~expr ? stmt : stmt2~ - most bracey languages have this, so it should go to the above

and

~?.~ - as in ~myObject.?myProperty~

and

~??~ - as in ~myStr ?? "empty"~

and

~??=~ as in ~value ??= 5~

and maybe

~...?~ as i ~['first', ...?aList]~


The mental pause with those, depending on how much you use the language in question, can be significant. To the point, one cannot really read the code fluently unless embedded in the particular language daily.


I realize this stuff is todo 

also


Operator	Name	Meaning
()	Function application	Represents a function call
[]	List access	Refers to the value at the specified index in the list
.	Member access	Refers to a property of an expression; example: foo.bar selects property bar from expression foo
?.	Conditional member access	Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)

todo


All this long story above gets me to my main point of syntax difficulty with Newspeak. When first studying Newspeak, it took me forever to figure out the ~x:, x::, x::=, x=, x~. What I mean:

#+begin_src 
class RGBCar = (
  (* instance initializer: inits slots and runs initializer code*)
  |
  numWheels = 4.
  mats ::= 'basic'.
  |
)(
  (* class body: defines instance methods or inner classes *)
):(
  (* class methods are in a group after : *)
)


#+end_src












* IN-PROGRESS Concepts: Packaging and distributing an app in 'mainstream' software - OLD LONG VERSION, PROBABLY REMOVE
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-14 Wed 12:40
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Programming in Newspeak/Packaging and distributing a Newspeak app
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:ARCHIVE_TODO: IN-PROGRESS
:END:

TL;DR: The intent of this section is to describe the "mainstream" lifecycle of developing, building, distributing, installing, and running a program, for the purpose of describing Newspeak builds.

This section is not meant to be a self-contained or axiomatic description of concepts - it will rely on terms and concepts that are not always uniquelly defined or described. Concepts may overlap, and are meta-circular so this section is vague.

We will use the following terms: 
  - The *program*, *app*, *application* interchangeably, these terms describe the software the /end-user/ interacts with to achieve some desired goal. These terms are overlapping, but generally are similar on the web, iOS, Android, or desktop. In addition, it is hard to define a /program/ simply, as some programs may have multiple components (client, server, database, etc). This section pretends a /program/ is the component the /end-user/ interacts with.
  - The *package* (noun) is the artifact (usually a file) that contains the /program/ in a form available for distribution in the /repository/. Often, this is called the /program package/ or the /packaged program/.
  - The *end-user* is the user of the /program/.
  - The *system* is the software which allows the /end-user/ to use the /program/. 
    - Examples:
      - /Web      system/  is the browser. However, a *web server* on which the /program package/ is installed, must be also available, making the whole web the /end-user's system/.
      - /Newspeak system/  is the browser. All comments from the web apply. 
        - Note: Newspeak development is development for the Web. Except it does not necessarily use HTML and CSS, and likely would not use Javascript. In addition, any Newspeak program can be /packaged/ as an iOS or an Android app.
      - /iOS      system/  is the operating system if /end-user/ uses Apple phone or tablet to install and run the /program/.
      - /Android  system/  is the operating system if /end-user/ uses Android phone or tablet to install and run the /program/.
      - /Linux    system/  is the operating system if /end-user/ uses Linux to install and run the /program/.
  - The *developer* is the person, persons, or organization who /create/ the /program/, and make it available to the /end-user/, by submitting it (copying it) to a /repository/ or to a /web server/. 
  - The *repository* is the location (accessible by a URI) where /package/s of /program/s are stored for public access by the /end-user/. 
    - The concept of /repository/ is different for the Web and in Newspeak on one end, and iOS, Android or desktop on the other end. 
      - On the web and Newspeak, there is no /repository/ the /end-user/ need to worry about. 
        - The developer (or organization) typically controls the webserver into which the /program package/ is /installed/.
        - The /repository/ and the /web server/ collapse into one. 
        - The /end-user/ does NOT /install/ any /program/ on their /system/, instead, they navigate their browser to an URL to /run/ or /use/ the /program/ which was placed there as a /package/ by the /developer/. 
        - The /install/ action is an action of the /developer/ (equivalent to the /submit to repository/ action), not an action by the end user. 
      - On iOS, Android or desktop, the /repository/ is some publicly provided site from which the /end-user/ can /install/ the /packaged program/.
    - However, there is a concept of *browser programs repository* as well: the browser authoring organization often maintains a *repository of extensions* to which a /program package/ can be submitted and made available to the end-user. 
  - To *build* a /program/ is the action of the /developer/, which makes the /program/ available for distribution in the /repository/ by creating a /program package/. Sometimes the verb 'to package' is used instead of 'to build'. We will avoid using 'to package' as a verb.
  - To *submit* a /program/ to a /repository/ is the action of the /developer/ which makes a /program/ which has been previously /built/, available to the /end-user/. 
  - To *install*, or *deploy* a /package/:
    - On the web, and in Newspeak, is an action of the /developer/ who places the program /package/ to a web server, from where the /end-user/ runs the /program/.
    - On the iOS, Android, or desktop, is an action of the /end-user/, who /install/ s the program from the /repository/ into their /system/. 
 
The main point of this section is that *a program may be /developed/ once, but the /system/ on which the program is made available to the /end-user/, dictates how the program is /build/, /submitted/, and /installed/.* (Some of those steps are overlapping or not needed depending on the /end-user/'s /system/.)

We can summarize the lifecycle of allowing the /end-user/ to use a program created by a developer as follows:

- Developer *develops* the *program*.
  - Examples:
    - /Web      developer/ *develops* a web program in a combination of HTML, CSS, and Javascript. 
    - /Newspeak developer/ *develops* a web program in Newspeak. 
    - /iOS      developer/ *develops* an iOS app.
    - /Android  developer/ *develops* an Android app.
    - /Linux    developer/ *develops* a Linux program.
- From the program, developer *builds* a *program package*.
  - Examples:
    - /Web      developer/ *builds* a ~.zip file or a .jar~ file of all the components needed to run his/her program inside the web server. The zip or jar file is the *web program package*
    - /Newspeak developer/ *builds* a ~.vfuel~ file from their Newspeak program. The ~.vfuel~ file is the *Newspeak program package for the web*. 
    - /iOS      developer/ *builds* an ~iOS app file~ for distribution in Apple store.
    - /Android  developer/ *builds* an ~.apk file~ for distribution in Google Playstore.
    - /Linux    developer/ *builds* an ~.rpm file~ for distribution (for example, in the Opensuse OSS repository).
    - Note: In the above examples, the *program package* is the .zip file, .vfuel file, .iOSapp file, .apk file, .rpm file. 
- Developer *submits* the *program package* into a *repository* of packages for *distribution* to end-user. 
  - /Web      developer/ *submits* (copies) the *web program package* (the zip or jar file) into a running (or to be started) webserver. This step is generally different from iOS, Android, or desktop, in that the /repository/ is not necessarrily publicly available. See discussion in the term /repository/ above.
  - /Newspeak developer/ *submits* the ~.vfuel~ file to the *Newspeak repository*. Note: there is currently no publicly available repository of Newspeak programs in the form of .vfuel files. The end-user must receive the .vfuel file from the developer by some secure means OR, run the ~.vfuel~ file on the web, where it is installed by the developer into a end-user-trusted website. The Newspeak program lifecycle is the same as the lifecycle for the web. 
  - /iOS      developer/ *submits* the ~iOS app~ for distribution in Apple store (*repository*).
  - /Android  programme/ *submits* the ~.apk file~ for distribution in Google Playstore (*repository*).
  - /Linux    developer/ *submits* the ~.rpm file~ for distribution in the *repository* (for example, OpenSUSE OSS repository)
- End-user *installs* (or copies) the *program package* from the *repository* into their *system*.
  - /Web      end-user/ generally does not have to do anything here. The developer /installs/ the program for the /end-user/.
    - Note: that there is an alternative to this process on the web. The /end-user/ can run their own /web server/, for example locally, and install the developer-provided /web program package/ (a .zip or .jar file) into the server they control.
  - /Newspeak end-user/ is generally in the same position as the /web end-user/ - he/she does not have to do anything here.
    - Note: As the Newspeak process generally is the same as the web process, there is an alternative: The /end-user/ can run their own /web server/, for example locally, and install the developer-provided Newspeak ~.vfuel~ file into their local Newspeak webserver. The ~.vfuel~ file is the *Newspeak program package for the web*. We haved used this process in our ~CounterApp~ local deployment. See section [[Deploy ~CounterApp~ as standalone app into local Newspeak webserver]].
  - /iOS      end-user/ *installs* the ~iOS app~ from Apple store (*repository*).
  - /Android  end-user/ *installs* the ~.apk file~ from Google Playstore (*repository*).
  - /Linux    end-user/ *installs* the ~.rpm file~ from the *repository* (for example, OpenSUSE OSS repository)
- End-user *runs* the *program* from the *program package* (which is now installed on their system) on their system.
  - /Web      end-user/ *navigates their browser* to the URL where the developer /installed/ the /program/. 
    - Note: If the /end-user/ runs their own (local) server, the URL would point to the local server, as discussed int the /install/ section above.
  - /Newspeak end-user/ *navigates their browser* to the URL where the developer /installed/ the /program/ (same as on the web) . For example, /end-user/ may navigate to the ~CounterApp~ on the Newspeak website, where it was installed: https://newspeaklanguage.org/samples/primordialsoup.html?snapshot=CounterApp.vfuel.
    - Note: If the /end-user/ runs their own /web server/ for Newspeak, for example locally, and installed the developer-provided Newspeak ~.vfuel~ file into their local Newspeak webserver, the URL would be http://localhost:8080/primordialsoup.html?snapshot=CounterApp.vfuel. See section [[Deploy ~CounterApp~ as standalone app into local Newspeak webserver]].
  - /iOS      end-user/ *runs* the ~iOS app~ from Apple store (*repository*).
  - /Android  end-user/ *runs* the ~.apk file~ from Google Playstore (*repository*).
  - /Linux    end-user/ *runs* the ~.rpm file~ from the *repository* (for example, OpenSUSE OSS repository)
 



* Terms
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-16 Fri 00:27
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

- Description of what term means in Newspeak     
- Definition of term
- Equivalents and examples in other languages and platforms 


** Namespace

- Description of what term means in Newspeak     
- Definition of term
- Equivalents and examples in other languages and platforms 

*** Global namespace

- Description of what term means in Newspeak     
- Definition of term
- Equivalents and examples in other languages and platforms 


** Module

- Description of what term means in Newspeak     
- Definition of term
- Module Equivalents and examples in other languages and platforms 

** Top level class

- Description of what term means in Newspeak     
- Definition of term
- Equivalents and examples in other languages and platforms 



* Non-Newspeak Concepts: Packaging and distributing an app in 'mainstream' software
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-19 Mon 23:29
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

Let me start with my understanding of the current "mainstream" way of software distribution using package repositories.  I'd describe such lifecycle as follows:

** A0) 'configure' : 'developer' 'configures' a 'project', adding 'dependencies' using 'package manager'

The first step developer typically takes is to create a project.  Almost no software lives in vaccuum, a need to use other externally created pieces of software.  Such pieces of software are often called modules, libraries, packages, dependencies and similar. 

This section uses the term 'required package' for such external pieces of software.  The term 'required package' hopefully expresses both 
- that such external software comes in a form of a package, 
- and  that such external software is 'required' by the project being developed. 

The mainstream name for 'required package' is 'dependency' but I find that confusing (confusing which way the dependency goes).

** A1) 'develop' : 'developer' 'develops' the 'program' or 'app'. 

** A2) 'build' :   'developer' 'builds a 'program package' from the 'program' and (potentially) it's 'dependencies', using a 'build tool'. 

Such 'build tool' is generally part of a higher level 'package manager' - the 'package manager' may act in 2 steps, in this build step, and in the 'install' step 4.  The build tool may be gradle, rpm builder, docker image builder, snapcraft, flatpak builder etc.  The resulting 'program package' may be a war file, a vfuel file, an rpm file, etc.  The 'program package' may or may not be 'self-contained' (contain all needed components - dependencies -  to run the program).  Either way, 'dependencies' (libraries needed to run the program) must be resolved either at this build step (if the 'program package' is self-contained) or at the 'target system' 'install' step.  As an example, the war or snap file would contain all dependencies, while the rpm file would rely on dependencies to be resolved and installed during the 'install' step.


** A3) 'submit':   'developer' 'submits' the 'program package' to a 'package repository'. 

On the web, developer copies the jar or vfuel to a webserver (so the repository is skipped? unless the browser extensions store is used)


** A4) 'install':   'end-user' 'installs' the 'program' on the 'target system' from the 'program package' located in the 'package repository', using a 'package manager'. 

As discussed in A2, the 'package manager' of the 'non-self-contained' program packages must calculate and install 'dependencies'.


** A5) 'run':       'end-user' 'runs' the 'program' installed in step 4.

Notes:

- steps A1, A2 and A3 (develop, build, submit) generally are executed - or at least can be - on the 'source system' (where the software is developed). 
- step A3 (submit to a repository) copies the 'program package' to a  publicly available repository (available to both developer and end-user).
- steps A4 and A5 (install, run) are executed on the 'target system' - where the end-user installs and runs the program.  Well, unless we are on the web where the 'end-user' points browser to a URL.
- I tried not to use the verb "to package" here (only "to build").  Unless I am missing something, "to package a program" is pretty much equivalent of "to build a package from a program" - so "to build" <==> "to package".  These actions happen on the 'source system'.
- The difference between 'self-contained' program packages and the not-self-contained ones, and how they are handled by their 'package manager' programs, is similar to early and late binding, perhaps with somewhat similar pros and cons. 


** B) What are roles of the methods (verbs) 'build' and 'package' in the Newspeak lifecycle of develop/build/submit/install/run an application?
---------------------------------------

Grepping the Newspeak codebase for:

find . -type f -exec grep  -H  "package.*Using.*:" {} \;

Yields the following methods signatures (on code from like a month ago when I started writing this):

- SomeClass.ns:     #packageUsing: manifest = ..
- SomeTestsConfiguration.ns: #packageTestsUsing: manifest = .. (or ideNamespace but that's just a name?)

In addition, in the post

https://groups.google.com/g/newspeaklanguage/c/kHAIE_i7gTc/m/2KwHVGIFBQAJ

Gilad defines 

- #packageLibraryUsingManifest: manifest





* Newspeak modules API zoo renames
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-21 Wed 21:49
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Newspeak is different.  An ide-driven journey around the Newspeak platform/Modules: Application, library, test, general
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

wishing renames to : 


| Module type                              | Constructor. Role=package                        | Instance method. Role=build or execute          |
|------------------------------------------+--------------------------------------------------+-------------------------------------------------|
| Library                                  | *#packageLibraryUsingManifest: manifest*         | *#buildLibraryUsingPlatform: platform*          |
| App                                      | *#packageUsingManifest: manifest*                | *#runUsingPlatform: platform args: args*        |
| Test Configuration                       | *#packageTestsUsingManifest: manifest*           | #testModulesUsingPlatform: platform minitest: m |
|------------------------------------------+--------------------------------------------------+-------------------------------------------------|
|------------------------------------------+--------------------------------------------------+-------------------------------------------------|
|                                          | Factory Constructor.                             |                                                 |
|------------------------------------------+--------------------------------------------------+-------------------------------------------------|
| General module needing platform          | #usingPlatform: platform [andModule: m1]         | Note: name is completely free                   |
| General module dependent on other module | #andModule: m1                                   | Note: name is completely free                   |
| General module with no dependencies      | #new                                             |                                                 |
| Test module                              | #usingPlatform: platform testFramework: minitest |                                                 |



* Useful editing hints
:PROPERTIES:
:ARCHIVE_TIME: 2021-07-19 Mon 23:44
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

\[\[\*\([A-z 0-9()_\.\?~]+\)\]\] â†’ [[*\1][Chapter \1] ] <<=== remove space

visible-mode shows links expanded!!



* IN-PROGRESS-NOW Review of Hopscotch
:PROPERTIES:
:ARCHIVE_TIME: 2021-08-05 Thu 01:03
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:ARCHIVE_TODO: IN-PROGRESS-NOW
:END:

** Paper "Hopscotch: Towards User Interface Composition" by Vassili Bykov, 8 pages

*** Introduction 
- favours interaction model
- enables composition of interfaces
- discusses the deficiencies of the traditional approach, provides an overview of the Hopscotch alternative and analyses how it improves upon the status quo


*** Traditional Interface Construction

- based on form.
- window divided into areas, each has a widget
- widget: display simple data: string, list, input widget (checkbox, radio etc
- complex data broken to widgets  
- number of widgets interact in form
- In more modern environments, embellishments
such as movable view splitters and dockable panels may camouflage the underlying rigidity of such
form-based UIs, and a good tools framework may
ease the burden of creating a new tool. However,
they still suffer from the following inherent problems of the form metaphor:
- Domain structure replication.
- Information fragmentation.
- Arbitrary display constraints.
- Monolithic tools.
Let us consider these in detail

**** 2.1 Domain Structure Replication
- Complex domains have a hierarchical or directed graph-like structure. Presenting it in a truly graphical form typically involves considerable development
effort a

discussses list

-  list displays the arcs originating in a graph node,
and the application is programmed to respond to selection in the list by updating the UI to visualize the
arc's target.
- y Smalltalk implementation
since, the browser has four list views side-by-side
across the top of the window. Together they visualize the four levels of arcs leading to the four layers of
code objects in the system: class categories, classes,
method categories ("protocols") and methods.
- Its implication, however, is that the structure of
the domain is replicated and hard-coded in the
structure of the tool window. Such UI assumptions
place gratuitous constraints on the domain object
model.
- Two solutions appeared over the years to relax
this constraint: tree views and columnar lists. Tree
views are used in Windows Explorer and the current
VisualWorks browser. The most popular example of
a columnar list is the column view of OS X Finder.

**** 2.2. Information Fragmentation

- A tool
such as the Smalltalk browser designed to present
information in a highly structured form easily induces "tunnel vision", so that logically related entities such as closely related methods cannot be seen
simultaneously. Thus, information structure replicated by the tool, while pe
- Thus, UIs
presenting a hierarchical domain through reusable
widgets in a form-like arrangement appear to encourage modes by their very nature.
This tunnel vision and modality are likely to be
among the real reasons, besides the obvious inertia, why many users prefer plain source file view
to structured editors that are literally based on the
Smalltalk browser model.
- The primary
factor that determines the ideal size of a widget is
the content it displays at any given moment. The
primary factors that dictate the actual size of a widget in a form are the size of the window and its
overall layout including the sizes of other widgets it
contains. Cl
- They still do not
address the cause of the problem - the fact that
window layout is determined and fixed in advance
without regard to the display needs of the actual
content.

**** 2.4. Monolithic Tools

*** 3. The HOpscotch approach

- Accomodate nested classes 
- Composition 
- Browser-like: a tool holder 
- The displayed elements are generally documents not forms
- Reassuringly, the document metaphor has already once been used for structured code presentation in the browser of Strongtalk [16]. Despite its lack of consistent navigation model, the tendency to open too many windows and lack of simple tool composition capabilities, the Strongtalk browser shows that the document metaphor is indeed a context where the problems of information fragmentation and gratuitous modes can be solved
- The objects that implement individual Hopscotch tools are called presenters. The architecture is indeed an extension of the *MVP* idea.
-


**** 3.2 Interaction model

- Like in a web browser, clicking hyperlinks is the primary means of navigation. Auxiliary navigation mechanisms are the forward/back button
- Editing a method is not a mode. It is possible at any moment to navigate away to look at another class or senders or implementors of a message and then use the "back" button or the history page to come back and continue editing. 
- In contrast to the common model of a menu bar providing all possible actions, this approach makes it intuitively obvious in accordance with the Gestalt principle which object an action affects. It also avoids another vestige of modes in traditional UIs: menu items mysteriously disabled because they are not applicable to the currently selected object. (Which illustrates that in traditional UIs the concept of current selection or other UI state often introduce modes). In the Hopscotch model, the action menu of each object only includes the actions the object supports. In fact, with the adoption of the document metaphor and the dismissal of the menu bar, the concept of selection at the level higher than text editing becomes less prominent and the UI less stateful.
- In an inspector, each slot of an object can be expanded in place into a full inspector on the value of the slot. In a similar fashion, a class nested inside another can be expanded in place in the Newspeak class browser view as shown in the screenshot on the previous page. Getting a little ahead of the presentation, it is also entirely possible to embed a browser into an inspector view, or an inspector into a browser with a trivial one-line code change.
  

**** 3.3 Architecture Overview

***** ~Fragment~ The widget system used by Hopscotch are extensions of ~Fragments~


***** ~Presenter~ The basic unit of the framework is a ~Presenter~.
A ~Presenter~

- Is responsible for displaying and manipulating a domain object in a particular way.
  
- May contain other presenters (child presenters), and may or may not be contained inside a higherlevel presenter (parent presenter). A navigator window is considered to be the parent of the topmost ("page-level") presenter.
  
- Creates and controls widgets (Fragments) such as text labels, editors, buttons, hyperlinks, or graphical images required to present its model.
  
- Unlike the traditional ~MVP~ architecture, a Hopscotch ~Presenter~ does not interact directly with model objects. Instead, it does interact with model objects through a ~Subject~.


  Presenter -> has Subject -> has Model

  *So can we call this Subject - View - Presenter*?

***** ~Subject~ plays several roles in the framework.

  - It is a ~location marker~ identifying the domain object being presented. Continuing the web browser analogy, we could say that by representing a "place" in the information space, a *subject is similar to a URL*
    
  - Indeed, *subjects are used by the framework as ~addresses~:*  when the user clicks a link or initiates navigation in some other way, the request the ~Navigator~ receives holds an instance of the subject identifying the destination. The subject is then used by the navigator to manufacture the appropriate ~Presenter~

    - Navigation steps:     
      - user click 
        - is converted to NavigationRequest.
        - NavigationRequest is passed to Navigator as NavigationRequest of destination change.
      - the NavigationRequest contains ~Subject~ (address) identifying the destination
      - *the ~Subject~ (address) is then used to create the ~Presenter~ for the destination. The method doing it is Subject>>#createPresenter.*
      - Note: Navigator must be known in context which knows about clicks.
    
  - Besides identifying the location (address), a subject can also identify the ~viewpoint~ used. For example, a ~ClassSubject~ represents the full view of a class with its methods and other details. In contrast, a ~ClassInheritanceSubject~ represents a view of a class as part of the hierarchy that includes its superclasses and subclasses. *Together, the location and the viewpoint determine "the subject of the presentation,"* hence the term ~Subject~.
    
    - Consider this scenario: User clicks a link in source presenter to navigate to destination address and open it in a viewport (that is, open in one of potentially many frames or windows). We can shorten this to "User navigates to destination". Destination is subject of the sentence, hence the name "Subject" for it. Note that Subject implies two things: Address (which contains the contents) and viewport (the window or frame where to show the contents)
    
  - ~Indirection~ achieved by *using subjects rather than presenters as navigation targets* is important in separating the specification of navigation from a particular policy of displaying domain objects. *In different usage contexts with different display constraints, different presenters could be used for a particular subject*. For example, a ClassSubject can have two presenters, one of them optimized for smaller screens to include less information.

  - The final role a subject can play is to serve as a utility kit providing methods that help presenters extract and process domain data.

  

* Slide 30: Newspeak security is based on the Object-capability model.
:PROPERTIES:
:ARCHIVE_TIME: 2021-09-07 Tue 16:38
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Programming in Newspeak/Access control and access modifiers in Newspeak.
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

This section summarizes a core security slide from the main article.
- slide 30: 
   - Newspeak security is based on the Object-capability model.
   - Object reachability defines authority. Translation: 
      - Security is thus defined as authority, which is fully defined by reachability
      - If objectA can reach objectB, then objectA can use the accessible capabilities of ObjectB. Capabilities are method, slots and nested classes.  Access to capabilities can be restricted by 
         - access modifier keywords [ public, private, protected (default, no keyword)] 
         - lexical structure (class nesting)
         - inheritance                
   - Question: Is reachability just another term for accessibility?
- Message sends
   - Situation: When a message msg is sent to an object, the message  msg can exist in ("be declared in") the object's class, or the object's superclass, or the object's class enclosing or enclosed class. The msg may be declared on zero, one, or many such classes; each occurrence may be private, public, or protected (default) accessibility. This situation  leads to a set of rules that govern how the "correct" msg should be found, accessed, and executed.



* Slides 64 - 77: Algorithm and rules for message sends in Newspeak
:PROPERTIES:
:ARCHIVE_TIME: 2021-09-07 Tue 16:39
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Programming in Newspeak/Access control and access modifiers in Newspeak.
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:

- Types of message sends in Newspeak 
   - ordinary sends to explicit object : slide 64
      1. e msg (- aka e.msg *)
         - Lookup msg in class of receiver; if public, execute. If protected, fail (DNU). 
         - Ignore private versions If not found, recurse upwards (until Object).
   - self sends : slide 65
      1. self msg (- aka this.msg *) 
         - If the immediately enclosing class declares a private msg, execute it 
         - Otherwise, lookup public or protected msg in class of the receiver; ignore private versions
         -  If not found, recurse upwards (until Object).
   - super sends : slide 66
      1. super msg (- aka super.msg *) 
         - Lookup public or protected msg in superclass of receiver; ignore private versions. 
         - If not found, recurse upwards (until Object).
   - implicit receiver sends : slide 69-77 (from the scope we see this is complex)
      1. msg (- aka msg *) 
         - First try to find msg in lexical scope:
            - Lookup declaration of private msg in immediately surrounding class. If not found, recurse up lexical scope until lexical top.  If the previous lexical step finds a declaration of msg (private by the above rule definition), execute
            - else (msg is protected or public)
                  - let r be the corresponding enclosing object. Lookup public or protected msg in class of r. If not found, recurse upwards (until Object).
         - Next try find msg in inheritance scope
            - If no lexically visible declaration was found, lookup public or protected msg in superclass of receiver; ignore private versions. 
            - If not found, recurse upwards (until Object).
   - outer sends : slide 88
      1. outer N msg (- no obvious analog*) 
         - Find innermost enclosing class named C. If a private msg is defined in C, execute. 
         - If not found, let r be the corresponding enclosing object. Lookup public or protected msg in class of r; ignore private versions. 
         - If not found, recurse upwards (until Object).
- Types of message sends in Newspeak re-stated
   - outer send:
      1. From the definition, the outer msg lookup is the same as in implicit messase lookup, with one difference: The outer msg lookup may skip some lexical enclosures; the lookup starts at some (higher level enclosing) class named C. 
      2. Slide 89
         - self msg ~ outer C msg 
            - where C is immediately enclosing class 
         - msg ~ outer N msg 
            - where N is innermost lexically enclosing class that declares msg
         - From the second point, we see that implicit message send is an outer send to the innermost lexical enclosure which declares msg



* TODO Corollary on slides 61, 62, 63 - Extension
:PROPERTIES:
:ARCHIVE_TIME: 2021-10-25 Mon 19:10
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Programming in Newspeak/Access control and access modifiers in Newspeak./Slides 61, 62, 63: Rules for accessing members above and below the class in the nesting hierarchy
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:END:
This Corollary provides a "recipy" of looking at accessibility. todo - this is not finished, too wordy and likely wrong.

Every runtime operation in Newspeak is *message sent*, but wording around accessibility uses the term *member* not *message* or *message sent*.  How should we understand this discrepancy?

Recall that a (class) member can mean any of:

- instance slot (is object or class). We use the name memberSlot below.
- method. We use the name memberMethod below.
- nested class. We use the name memberClass below.

Any "atomic" expression may be: 

1. nonMemberObject
   - this MUST be an object in a locally declared slot, as any object used in any context can only be coming from either an instance slot (aka instance variable) or locally declared slot (aka local variable).
2. nonMemberObject msg
3. (implicitObject) msg
4. memberMethod
5. memberSlot
6. memberSlot msg
7. memberClass
8. memberClass msg

So we can change the above to

Any "atomic" expression may be: 

1. localSlot
2. localSlot msg
3. (implicitObject) msg
4. memberMethod
5. memberSlot
6. memberSlot msg
7. memberClass
8. memberClass msg

The reason the accessibility text can use the term *member* rather than *message sent* is complicated (to me) but does make some sense.  Let me try my best to explain. The way to resolve this is the following thought process.

Accessibility is evaluated through the process of looking at "lexical ownership"
- Any "msg" in items 1-8 is in the end, a memberMethod on some class. To distin. 

If we ask "does the "atomic" expression 1-8 succeed at runtime?  We go through the following 

 
 
So looking to evaluate accessibility of an expression such as  ~objA msgA msgB msgC~, we evaluate accessibility of all terms, starting from the left, using rules in Slides 61, 62, 63:

1. Find the class where the expression ~objA msgA msgB msgC~ is "lexically" located. We look for the class immediately "up" from the line where the expression is located: It may be in a factory, or in a method, or in a slot of a class, say it is ~C1~. *Note: Nested class of C1 is EXLUDED from the lexical location search - then the "lexical location" would be the nested class*.
2. ~objA~ : can be either a msg of ~C1~, or an instance of a class (say it is ~ObjA~), or a class (say it is ~C2~
   - We ask: is ~objA~ accessible?
     - If ~objA~ is msg of ~C1~ (can be slot, method, or nested class), YES
     - Else if ~objA~ is class ~C2~
       - If class ~C2~ is a nesting class lexically UP from the point of where the expression is located (with any modifier): YES
       - Else: NO
     - Else if ~objA~ is an instance of ~ObjA~:
       - If class ~ObjA~ is a nesting class lexically UP from the point of where the expression is located (with any modifier): YES
     - Else NO
   - If answer is NO, accessibility FAILED.
3. ~objA msgA~ : Find the class of which the result is instanceof (say it is ~ObjB~ todo this is getting complicated, archive this.
   - We ask: is ~ObjB~ accessible? To find the answer, use the same process described above, replacing ~ObjA~ with ~ObjB~
4. ~objA msgA msgB~ (which is accessibility of ~msgB~ from ~objB msgB~)


* IN-PROGRESS-NOW Accessibility summary
:PROPERTIES:
:ARCHIVE_TIME: 2021-10-26 Tue 16:04
:ARCHIVE_FILE: ~/dev/my-projects-source/public-on-github/mzimmerm.github.io/org/newspeak---a-few-notes.org
:ARCHIVE_OLPATH: Programming in Newspeak/Access control and access modifiers in Newspeak/Worked accessibility examples, using rules from slides 61, 62, 63/Execute expressions in C1, gradually adding terms, to study by example
:ARCHIVE_CATEGORY: newspeak---a-few-notes
:ARCHIVE_TODO: IN-PROGRESS-NOW
:END:

*This seems a good summary but it needs think-through. It is much more wordy than slides 62 and 63, but it explains the terminology shift from "message send" in Newspeak to the wording of accessibility using the term "member" instead.*

We can write any expression for which we evaluate accessibility as ~obj~, ~msg~ or ~obj msg~. The expression ~msg~ does have an implicit receiver, so any expression can be written as one of:

- ~obj~ 
- ~obj msg~

When we evaluate such expression for accessibility, we need to evaluate access using rules in slides 62, 63.  As Newspeak uses "lexical position" (that is, where in the code is the accessed message or class defined vs. where the accessed expression is located), accessibility evaluation boils down to this process

1. Find the "lexical point" - the class in which the expression is "lexically located". It may be
   - in a factory, 
   - or in a method, 
   - or in a slot declaration. 
   - *Note: Nested classes of C1 are EXLUDED from the "lexical point" search - then the "lexical point" would be the nested class.*
2. Let's say the class in which the expression is located is named ~C1~, then ~C1~ is the "lexical point". 
3. When evaluating ~obj~ for access, we ask: Can the class ~C1~ access the class of which ~obj~ is an instanceof? (Let's say the class is ~Cmember~. Also note that ~Cmember~ must be in some lexical relation to ~C1~: C1 is nested in Cmember, Cmember is nested in C1, C1 is same as Cmember, or none of the above.  Slide 62 gives us the answer to accessibility of Cmember from C1 (and hence accessibility of expression ~obj~ written in it's lexical point, class C1): The access is allowed, if ~Cmember~ is public, OR if ~Cmember~ is a nesting class of ~C1~ (UP from C1), or if ~Cmember~ is member class of ~C1~). 
4. When evaluating ~obj msg~ for access, we ask: Can the class ~C1~ access the *member method* corresponding to the ~msg~?  (Let's say the member is ~memberMethod~ declared on ~Cmember~. A note of ~Cmember~ lexical relation to ~C1~ applies.  Slide 63 gives us the answer to accessibility of ~memberMethod~ from C1 (and hence accessibility of expression ~obj msg~ written in it's lexical point, class C1): The access is allowed, if ~memberMethod~ is public, OR if ~Cmember~ is a nesting class of ~C1~ (UP from C1), or if ~Cmember~ is member class of ~C1~). 



Items 3 and 4 can be reduced to this algorithm in determining accessibility of the expression ~obj(instance of Cmember, )~ or ~obj msg(memberMethod on Cmember)~: 
   - Access is allowed if for ~Cmember~ and ~memberMethod~ at least one is true:
     1. ~Cmember~ and ~memberMethod~ are members of the "lexical point" ~C1~ 
     2. ~Cmember~ and ~memberMethod~ are members of classes which are "lexically enclosing (UP)" from the "lexical point" ~C1~. 
     3. ~Cmember~ and ~memberMethod~ are public, irrespective where they are in the nesting hierarchy relative to ~C1~.
   - All other members may NOT be accessed - notably, if  ~Cmember~ and ~memberMethod~ are non-public members of nested classes (DOWN).

Note: 1 and 2 apply irrespecrive of ~Cmember~ or ~memberMethod~ being public, private, protected. But note that "public" is included in item 3. 

